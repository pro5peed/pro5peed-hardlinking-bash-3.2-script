#!/bin/bash

# Movie Hardlink/Rename Simulator
# Mimics movie management's exact hardlinking and renaming process with directory batch support
# Naming formats based on TRaSH-Guides: https://trash-guides.info/Movies/Movie-recommended-naming-scheme/

set -e

# Global interrupt flag for immediate Ctrl+C response
INTERRUPTED=false

# Trap Ctrl+C and cleanup - more aggressive handling
cleanup_on_exit() {
    local exit_code=$?
    INTERRUPTED=true
    
    # Kill any child processes immediately
    pkill -P $$ 2>/dev/null || true
    
    # Clean up temp files
    rm -f /tmp/movie_*.$$* 2>/dev/null
    rm -rf /tmp/tv_lookup_locks/* 2>/dev/null
    
    # Clean up this instance's file locks (only ones we own)
    if [[ -d "$PROCESSING_LOCKS_DIR" ]]; then
        find "$PROCESSING_LOCKS_DIR" -name "*.lock" -type d 2>/dev/null | while read -r lockdir; do
            if [[ -f "${lockdir}/pid" ]]; then
                local lock_pid=$(cat "${lockdir}/pid" 2>/dev/null)
                if [[ "$lock_pid" == "$$" ]]; then
                    rm -rf "$lockdir" 2>/dev/null
                fi
            fi
        done
    fi
    
    if [[ $exit_code -ne 0 ]] || [[ "$INTERRUPTED" == "true" ]]; then
        echo "" >&2
        echo -e "\n${YELLOW:-}Script interrupted or exited.${NC:-}" >&2
    fi
    
    # Force exit
    exit ${exit_code:-130}
}

# More aggressive interrupt handler
interrupt_handler() {
    INTERRUPTED=true
    echo "" >&2
    echo -e "\n${YELLOW:-}Ctrl+C detected - stopping...${NC:-}" >&2
    exit 130
}

# Check for interrupt signal during processing
check_interrupt() {
    if [[ "$INTERRUPTED" == "true" ]]; then
        echo "\n[INFO] Processing interrupted by user" >&2
        exit 130
    fi
}

# Acquire lock for processing a specific file (returns 0 if acquired, 1 if already locked)
acquire_file_lock() {
    local file_path="$1"
    local file_inode=$(stat -f "%i" "$file_path" 2>/dev/null || stat -c "%i" "$file_path" 2>/dev/null)
    [[ -z "$file_inode" ]] && return 1
    
    local lockdir="${PROCESSING_LOCKS_DIR}/file_${file_inode}.lock"
    
    # Try to acquire lock (mkdir is atomic across processes)
    # Add small random delay (0-200ms) to reduce race condition likelihood
    local random_delay="0.$(printf "%03d" $((RANDOM % 200)))" 2>/dev/null || random_delay="0.001"
    sleep "$random_delay" 2>/dev/null || true
    
    local attempts=0
    while ! mkdir "$lockdir" 2>/dev/null; do
        attempts=$((attempts + 1))
        if [[ $attempts -gt 3 ]]; then
            # Timeout after 3 seconds - check if lock is stale
            if [[ -f "${lockdir}/timestamp" ]]; then
                local lock_time=$(cat "${lockdir}/timestamp" 2>/dev/null)
                local now=$(date +%s)
                local age=$((now - lock_time))
                # If lock is older than 30 seconds, assume it's stale
                if [[ $age -gt 30 ]]; then
                    local lock_pid=$(cat "${lockdir}/pid" 2>/dev/null)
                    # Check if the process is still running
                    if ! kill -0 "$lock_pid" 2>/dev/null; then
                        # Process is dead, remove stale lock
                        rm -rf "$lockdir" 2>/dev/null
                        mkdir "$lockdir" 2>/dev/null || return 1
                        break
                    fi
                fi
            fi
            # Lock is not stale or process still alive, file is being processed
            return 1
        fi
        sleep 1
    done
    
    # Store lock info immediately after acquiring
    echo "$$" > "${lockdir}/pid" 2>/dev/null
    echo "$(date +%s)" > "${lockdir}/timestamp" 2>/dev/null
    echo "$file_path" > "${lockdir}/file" 2>/dev/null
    return 0
}

# Release lock for a specific file
release_file_lock() {
    local file_path="$1"
    local file_inode=$(stat -f "%i" "$file_path" 2>/dev/null || stat -c "%i" "$file_path" 2>/dev/null)
    [[ -z "$file_inode" ]] && return 0
    
    local lockdir="${PROCESSING_LOCKS_DIR}/file_${file_inode}.lock"
    
    # Only remove if we own it
    if [[ -f "${lockdir}/pid" ]]; then
        local lock_pid=$(cat "${lockdir}/pid" 2>/dev/null)
        if [[ "$lock_pid" == "$$" ]]; then
            rm -rf "$lockdir" 2>/dev/null
        fi
    fi
}

# Set up traps - use interrupt_handler for INT for faster response
trap cleanup_on_exit EXIT TERM
trap interrupt_handler INT

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[1;36m'
CYAN='\033[0;36m'
PINK='\033[1;35m'
NEON_GREEN='\033[1;92m'
BRIGHT_RED='\033[1;91m'
DIM='\033[2m'
NC='\033[0m' # No Color

# Flash text helper - prints text with blink for 3 seconds then reprints without blink
flash_instruction() {
    local text="$1"
    local color="${2:-$YELLOW}"
    
    # Print with blink
    echo -e "${color}\033[5m${text}\033[25m${NC}"
    
    # Schedule to reprint without blink after 3 seconds in background
    (
        sleep 3
        # Move cursor up one line and clear it
        tput cuu1 2>/dev/null
        tput el 2>/dev/null
        # Reprint without blink
        echo -e "${color}${text}${NC}"
    ) &
}

# ═══════════════════════════════════════════════════════════════════════════════
# DEPENDENCY CHECK AND INSTALLATION
# ═══════════════════════════════════════════════════════════════════════════════

# Selective install menu
select_install_dependencies() {
    # Timer for flashing instruction
    local flash_start=$SECONDS
    
    # Build list of installable dependencies
    # Format: name|||desc|||pkg_info|||cmd|||checked (using ||| as delimiter to avoid conflicts)
    local -a install_items=()
    
    if ! command -v brew &>/dev/null; then
        install_items+=("brew|||Package manager for macOS|||Will install: Homebrew|||brewinstall|||1")
    fi
    
    if ! command -v mediainfo &>/dev/null; then
        install_items+=("mediainfo|||Extract accurate video/audio metadata|||Will install homebrew package: mediainfo|||brew install mediainfo|||0")
    fi
    
    if ! command -v ffprobe &>/dev/null; then
        install_items+=("ffprobe|||Alternative metadata extraction tool|||Will install homebrew package: ffmpeg (includes ffprobe)|||brew install ffmpeg|||0")
    fi
    
    if ! command -v imgcat &>/dev/null && ! command -v chafa &>/dev/null; then
        install_items+=("chafa|||Display poster images in terminal|||Will install homebrew package: chafa|||brew install chafa|||0")
    fi
    
    if ! command -v vipsthumbnail &>/dev/null; then
        install_items+=("vips|||Fast image resizer (vipsthumbnail)|||Will install homebrew package: vips|||brew install vips|||0")
    fi
    
    if ! command -v gawk &>/dev/null; then
        install_items+=("gawk|||GNU AWK - Enhanced text processing|||Will install homebrew package: gawk|||brew install gawk|||0")
    fi
    
    if ! command -v mawk &>/dev/null; then
        install_items+=("mawk|||Mike's AWK - Fastest AWK implementation|||Will install homebrew package: mawk|||brew install mawk|||0")
    fi
    
    if [[ ${#install_items[@]} -eq 0 ]]; then
        clear
        echo ""
        echo -e "${GREEN}All optional dependencies are already installed!${NC}"
        echo ""
        sleep 2
        return 0
    fi
    
    local selected_idx=0
    tput civis 2>/dev/null
    
    while true; do
        # Redraw full screen
        clear
        
        echo ""
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${CYAN}INSTALL DEPENDENCIES${NC}"
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
        # Flash instruction for 5 seconds
        if [[ $((SECONDS - flash_start)) -lt 5 ]]; then
            echo -e "${YELLOW}\033[5mSelect dependencies to install (use 'x' or Space to toggle, Enter to confirm, 'b' to go back)\033[25m${NC}"
        else
            echo -e "${YELLOW}Select dependencies to install (use 'x' or Space to toggle, Enter to confirm, 'b' to go back)${NC}"
        fi
        echo -e "${DIM}Note: Packages will be installed using Homebrew${NC}"
        echo ""
        
        # Display items
        for i in "${!install_items[@]}"; do
            local item="${install_items[$i]}"
            local name="${item%%|||*}"
            local rest="${item#*|||}"
            local desc="${rest%%|||*}"
            rest="${rest#*|||}"
            local pkg_info="${rest%%|||*}"
            rest="${rest#*|||}"
            local cmd="${rest%%|||*}"
            local checked="${rest##*|||}"
            
            local checkbox="[ ]"
            [[ "$checked" == "1" ]] && checkbox="[✓]"
            
            if [[ $i -eq $selected_idx ]]; then
                echo -e "  ${GREEN}► $checkbox $name${NC}"
                echo -e "        ${DIM}$desc${NC}"
                echo -e "        ${CYAN}$pkg_info${NC}"
            else
                echo -e "  ${DIM}  $checkbox $name${NC}"
                echo -e "        ${DIM}$desc${NC}"
            fi
            echo ""
        done
        
        echo ""
        # Flash instruction for 5 seconds
        if [[ $((SECONDS - flash_start)) -lt 5 ]]; then
            echo -e "${DIM}\033[5mPress 'x' or Space to toggle, Enter to install selected, 'b' to cancel\033[25m${NC}"
        else
            echo -e "${DIM}Press 'x' or Space to toggle, Enter to install selected, 'b' to cancel${NC}"
        fi
        
        # Read input
        read -rsn1 key 2>/dev/null
        
        if [[ "$key" == $'\x1b' ]]; then
            read -rsn2 -t 1 key 2>/dev/null
            case "$key" in
                '[A'|'OA') # Up
                    ((selected_idx--))
                    [[ $selected_idx -lt 0 ]] && selected_idx=$((${#install_items[@]} - 1))
                    ;;
                '[B'|'OB') # Down
                    ((selected_idx++))
                    [[ $selected_idx -ge ${#install_items[@]} ]] && selected_idx=0
                    ;;
            esac
        elif [[ "$key" == " " ]] || [[ "$key" == "x" ]] || [[ "$key" == "X" ]]; then
            # Toggle selection with space bar or 'x' key
            local item="${install_items[$selected_idx]}"
            local name="${item%%|||*}"
            local rest="${item#*|||}"
            local desc="${rest%%|||*}"
            rest="${rest#*|||}"
            local pkg_info="${rest%%|||*}"
            rest="${rest#*|||}"
            local cmd="${rest%%|||*}"
            local checked="${rest##*|||}"
            
            if [[ "$checked" == "1" ]]; then
                install_items[$selected_idx]="$name|||$desc|||$pkg_info|||$cmd|||0"
            else
                install_items[$selected_idx]="$name|||$desc|||$pkg_info|||$cmd|||1"
            fi
        elif [[ "$key" == "b" ]] || [[ "$key" == "B" ]]; then
            tput cnorm 2>/dev/null
            clear
            return 0
        elif [[ "$key" == "" ]]; then
            # Enter - install selected
            tput cnorm 2>/dev/null
            clear
            echo ""
            
            local -a to_install=()
            for item in "${install_items[@]}"; do
                local name="${item%%|||*}"
                local rest="${item#*|||}"
                local desc="${rest%%|||*}"
                rest="${rest#*|||}"
                local pkg_info="${rest%%|||*}"
                rest="${rest#*|||}"
                local cmd="${rest%%|||*}"
                local checked="${rest##*|||}"
                
                [[ "$checked" == "1" ]] && to_install+=("$name|||$pkg_info|||$cmd")
            done
            
            if [[ ${#to_install[@]} -eq 0 ]]; then
                echo -e "${YELLOW}No dependencies selected for install${NC}"
                echo ""
                sleep 2
                return 0
            fi
            
            echo -e "${CYAN}Installing selected dependencies...${NC}"
            echo ""
            
            for item in "${to_install[@]}"; do
                local name="${item%%|||*}"
                local rest="${item#*|||}"
                rest="${rest#*|||}"
                local cmd="${rest##*|||}"
                echo -e "${YELLOW}Installing $name...${NC}"
                
                # Special handling for brew install
                if [[ "$cmd" == "brewinstall" ]]; then
                    /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
                    
                    # Add brew to PATH for this session
                    if [[ -f "/opt/homebrew/bin/brew" ]]; then
                        eval "$(/opt/homebrew/bin/brew shellenv)"
                    elif [[ -f "/usr/local/bin/brew" ]]; then
                        eval "$(/usr/local/bin/brew shellenv)"
                    fi
                else
                    eval "$cmd"
                fi
                echo ""
            done
            
            echo -e "${GREEN}✓ Installation complete!${NC}"
            echo ""
            sleep 2
            return 0
        fi
    done
}

# Selective uninstall menu
select_uninstall_dependencies() {
    # Timer for flashing instruction
    local flash_start=$SECONDS
    
    # Build list of uninstallable dependencies
    # Format: name|||desc|||pkg_info|||cmd|||checked (using ||| as delimiter to avoid conflicts)
    local -a uninstall_items=()
    
    if command -v mediainfo &>/dev/null; then
        uninstall_items+=("mediainfo|||Extract accurate video/audio metadata|||Will uninstall homebrew packag using homebrew: mediainfo|||brew uninstall mediainfo|||0")
    fi
    
    if command -v ffprobe &>/dev/null; then
        uninstall_items+=("ffprobe|||Alternative metadata extraction tool|||Will uninstall homebrew package: ffmpeg (includes ffprobe)|||brew uninstall ffmpeg|||0")
    fi
    
    if command -v chafa &>/dev/null; then
        uninstall_items+=("chafa|||Display poster images in terminal|||Will uninstall homebrew package: chafa|||brew uninstall chafa|||0")
    fi
    
    if command -v vipsthumbnail &>/dev/null; then
        uninstall_items+=("vips|||Fast image resizer (vipsthumbnail)|||Will uninstall homebrew package: vips|||brew uninstall vips|||0")
    fi
    
    if command -v gawk &>/dev/null; then
        uninstall_items+=("gawk|||GNU AWK - Enhanced text processing|||Will uninstall homebrew package: gawk|||brew uninstall gawk|||0")
    fi
    
    if command -v mawk &>/dev/null; then
        uninstall_items+=("mawk|||Mike's AWK - Fastest AWK|||Will uninstall homebrew package: mawk|||brew uninstall mawk|||0")
    fi
    
    if command -v brew &>/dev/null; then
        uninstall_items+=("brew|||Package manager (REMOVES ALL BREW PACKAGES! including BREW itself)|||Will uninstall: Homebrew + all installed packages|||brewuninstall|||0")
    fi
    
    if [[ ${#uninstall_items[@]} -eq 0 ]]; then
        echo -e "${YELLOW}No optional dependencies to uninstall${NC}"
        echo ""
        sleep 2
        return 0
    fi
    
    local selected_idx=0
    tput civis 2>/dev/null
    
    while true; do
        # Redraw full screen
        clear
        
        echo ""
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${CYAN}UNINSTALL DEPENDENCIES${NC}"
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
        # Flash instruction for 5 seconds
        if [[ $((SECONDS - flash_start)) -lt 5 ]]; then
            echo -e "${YELLOW}\033[5mCheck items you WANT to uninstall (use 'x' or Space to toggle, Enter to confirm, 'b' to go back)\033[25m${NC}"
        else
            echo -e "${YELLOW}Check items you WANT to uninstall (use 'x' or Space to toggle, Enter to confirm, 'b' to go back)${NC}"
        fi
        echo -e "${DIM}Note: Only checked items will be uninstalled. System tools (curl, sips, imgcat) cannot be uninstalled.${NC}"
        echo ""
        
        # Display items
        for i in "${!uninstall_items[@]}"; do
            local item="${uninstall_items[$i]}"
            local name="${item%%|||*}"
            local rest="${item#*|||}"
            local desc="${rest%%|||*}"
            rest="${rest#*|||}"
            local pkg_info="${rest%%|||*}"
            rest="${rest#*|||}"
            local cmd="${rest%%|||*}"
            local checked="${rest##*|||}"
            
            local checkbox="[ ]"
            [[ "$checked" == "1" ]] && checkbox="[✓]"
            
            if [[ $i -eq $selected_idx ]]; then
                echo -e "  ${GREEN}► $checkbox $name${NC}"
                echo -e "        ${DIM}$desc${NC}"
                echo -e "        ${YELLOW}$pkg_info${NC}"
            else
                echo -e "  ${DIM}  $checkbox $name${NC}"
                echo -e "        ${DIM}$desc${NC}"
            fi
            echo ""
        done
        
        echo ""
        # Flash instruction for 5 seconds
        if [[ $((SECONDS - flash_start)) -lt 5 ]]; then
            echo -e "${DIM}\033[5mPress 'x' or Space to toggle, Enter to uninstall selected, 'b' to cancel\033[25m${NC}"
        else
            echo -e "${DIM}Press 'x' or Space to toggle, Enter to uninstall selected, 'b' to cancel${NC}"
        fi
        
        # Read input
        read -rsn1 key 2>/dev/null
        
        if [[ "$key" == $'\x1b' ]]; then
            read -rsn2 -t 1 key 2>/dev/null
            case "$key" in
                '[A'|'OA') # Up
                    ((selected_idx--))
                    [[ $selected_idx -lt 0 ]] && selected_idx=$((${#uninstall_items[@]} - 1))
                    ;;
                '[B'|'OB') # Down
                    ((selected_idx++))
                    [[ $selected_idx -ge ${#uninstall_items[@]} ]] && selected_idx=0
                    ;;
            esac
        elif [[ "$key" == " " ]] || [[ "$key" == "x" ]] || [[ "$key" == "X" ]]; then
            # Toggle selection with space bar or 'x' key
            local item="${uninstall_items[$selected_idx]}"
            local name="${item%%|||*}"
            local rest="${item#*|||}"
            local desc="${rest%%|||*}"
            rest="${rest#*|||}"
            local pkg_info="${rest%%|||*}"
            rest="${rest#*|||}"
            local cmd="${rest%%|||*}"
            local checked="${rest##*|||}"
            
            if [[ "$checked" == "1" ]]; then
                uninstall_items[$selected_idx]="$name|||$desc|||$pkg_info|||$cmd|||0"
            else
                uninstall_items[$selected_idx]="$name|||$desc|||$pkg_info|||$cmd|||1"
            fi
        elif [[ "$key" == "b" ]] || [[ "$key" == "B" ]]; then
            tput cnorm 2>/dev/null
            clear
            return 0
        elif [[ "$key" == "" ]]; then
            # Enter - uninstall selected
            tput cnorm 2>/dev/null
            clear
            echo ""
            
            local -a to_uninstall=()
            for item in "${uninstall_items[@]}"; do
                local name="${item%%|||*}"
                local rest="${item#*|||}"
                local desc="${rest%%|||*}"
                rest="${rest#*|||}"
                local pkg_info="${rest%%|||*}"
                rest="${rest#*|||}"
                local cmd="${rest%%|||*}"
                local checked="${rest##*|||}"
                
                [[ "$checked" == "1" ]] && to_uninstall+=("$name|||$pkg_info|||$cmd")
            done
            
            if [[ ${#to_uninstall[@]} -eq 0 ]]; then
                echo -e "${YELLOW}No dependencies selected for uninstall${NC}"
                echo ""
                sleep 2
                return 0
            fi
            
            # Show uninstall confirmation with details
            echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
            echo -e "${RED}⚠  WARNING: UNINSTALL CONFIRMATION${NC}"
            echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
            echo ""
            echo -e "${YELLOW}The following will be uninstalled:${NC}"
            echo ""
            
            local brew_selected=false
            for item in "${to_uninstall[@]}"; do
                local name="${item%%|||*}"
                local rest="${item#*|||}"
                local pkg_info="${rest%%|||*}"
                
                # Check if brew is being uninstalled
                [[ "$name" == "brew" ]] && brew_selected=true
                
                echo -e "  ${RED}✗ $name${NC}"
                echo -e "    ${DIM}$pkg_info${NC}"
                echo ""
            done
            
            if [[ "$brew_selected" == true ]]; then
                echo -e "${RED}⚠  CRITICAL: Uninstalling Homebrew will remove ALL brew-installed packages!${NC}"
                echo ""
            fi
            
            echo -e "${YELLOW}Type 'yes' to confirm uninstall, anything else to cancel:${NC}"
            read -r confirm
            echo ""
            
            if [[ "$confirm" != "yes" ]]; then
                echo -e "${GREEN}✓ Uninstall cancelled${NC}"
                echo ""
                sleep 2
                return 0
            fi
            
            echo -e "${YELLOW}Uninstalling selected dependencies...${NC}"
            echo ""
            
            local had_errors=false
            for item in "${to_uninstall[@]}"; do
                local name="${item%%|||*}"
                local rest="${item#*|||}"
                rest="${rest#*|||}"
                local cmd="${rest##*|||}"
                echo -e "${YELLOW}Uninstalling $name...${NC}"
                
                # Special handling for brew uninstall
                if [[ "$cmd" == "brewuninstall" ]]; then
                    /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/uninstall.sh)" || {
                        had_errors=true
                        echo -e "${RED}✗ Failed to uninstall Homebrew${NC}"
                    }
                else
                    # Try to uninstall, capture errors but continue
                    if ! eval "$cmd" 2>&1; then
                        had_errors=true
                        echo -e "${RED}✗ Cannot uninstall $name - it is required by other packages${NC}"
                        echo -e "${DIM}Other packages depend on this. Uninstall them first or use: brew uninstall --ignore-dependencies${NC}"
                    fi
                fi
                echo ""
            done
            
            if [[ "$had_errors" == false ]]; then
                echo -e "${GREEN}✓ Uninstall complete!${NC}"
            else
                echo -e "${YELLOW}⚠  Uninstall finished with some errors (see above)${NC}"
            fi
            echo ""
            echo -e "${DIM}Press any key to continue...${NC}"
            read -rsn1
            return 0
        fi
    done
}

# OS Selection Menu
select_operating_system() {
    local -a os_options=("macOS" "Ubuntu/Debian" "Fedora/RHEL/CentOS" "Arch Linux" "Other Linux")
    local selected_idx=0
    
    # Check if OS was already selected and saved
    if [[ -f "${CACHE_DIR}/selected_os.txt" ]]; then
        SELECTED_OS=$(cat "${CACHE_DIR}/selected_os.txt")
        return 0
    fi
    
    tput civis 2>/dev/null
    stty -echo 2>/dev/null
    
    while true; do
        {
        clear
        
        echo ""
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${CYAN}SELECT YOUR OPERATING SYSTEM${NC}"
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
        echo -e "${DIM}This will determine which package manager and dependencies are shown.${NC}"
        echo ""
        
        for i in "${!os_options[@]}"; do
            if [[ $i -eq $selected_idx ]]; then
                echo -e "  ${GREEN}▶ ${os_options[$i]}${NC}"
            else
                echo -e "    ${DIM}${os_options[$i]}${NC}"
            fi
        done
        
        echo ""
        echo -e "${DIM}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${YELLOW}↑/↓${NC}: Navigate  ${YELLOW}ENTER${NC}: Select  ${YELLOW}q${NC}: Quit"
        echo -e "${DIM}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        } </dev/null
        echo ""
        
        read -rsn1 key 2>/dev/null
        
        if [[ "$key" == $'\x1b' ]]; then
            read -rsn2 -t 1 key 2>/dev/null
            if [[ ${#key} -ne 2 ]]; then
                continue
            fi
            case "$key" in
                '[A'|'OA') # Up arrow
                    ((selected_idx--))
                    [[ $selected_idx -lt 0 ]] && selected_idx=$((${#os_options[@]} - 1))
                    ;;
                '[B'|'OB') # Down arrow
                    ((selected_idx++))
                    [[ $selected_idx -ge ${#os_options[@]} ]] && selected_idx=0
                    ;;
            esac
        elif [[ "$key" == "q" ]] || [[ "$key" == "Q" ]]; then
            stty echo 2>/dev/null
            tput cnorm 2>/dev/null
            clear
            echo ""
            print_warning "Cancelled"
            exit 0
        elif [[ "$key" == "" ]]; then
            # Enter - save selection
            SELECTED_OS="${os_options[$selected_idx]}"
            echo "$SELECTED_OS" > "${CACHE_DIR}/selected_os.txt"
            stty echo 2>/dev/null
            tput cnorm 2>/dev/null
            return 0
        fi
    done
}

check_and_install_dependencies() {
    local -a missing_deps=()
    local -a optional_deps=()
    local -a installed_deps=()
    
    # Load selected OS
    if [[ -f "${CACHE_DIR}/selected_os.txt" ]]; then
        SELECTED_OS=$(cat "${CACHE_DIR}/selected_os.txt")
    else
        SELECTED_OS="macOS"  # Default fallback
    fi
    
    # Determine package manager and install commands based on OS
    local pkg_manager=""
    local pkg_install_cmd=""
    case "$SELECTED_OS" in
        "macOS")
            pkg_manager="brew"
            pkg_install_cmd="brew install"
            ;;
        "Ubuntu/Debian")
            pkg_manager="apt"
            pkg_install_cmd="sudo apt-get install -y"
            ;;
        "Fedora/RHEL/CentOS")
            pkg_manager="dnf"
            pkg_install_cmd="sudo dnf install -y"
            ;;
        "Arch Linux")
            pkg_manager="pacman"
            pkg_install_cmd="sudo pacman -S --noconfirm"
            ;;
        "Other Linux")
            pkg_manager="package manager"
            pkg_install_cmd="use your package manager to install"
            ;;
    esac
    
    # Check required dependencies
    if ! command -v curl &>/dev/null; then
        missing_deps+=("curl|Required|API requests for movie metadata|$pkg_install_cmd curl")
    else
        installed_deps+=("curl|Required|API requests for movie metadata")
    fi
    
    # Check optional dependencies (package manager)
    if [[ "$SELECTED_OS" == "macOS" ]]; then
        if ! command -v brew &>/dev/null; then
            optional_deps+=("brew|Optional|Package manager for installing tools|/bin/bash -c \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"")
        else
            installed_deps+=("brew|Optional|Package manager for installing tools")
        fi
    fi
    
    if ! command -v mediainfo &>/dev/null; then
        optional_deps+=("mediainfo|Recommended|Extract accurate video/audio metadata|$pkg_install_cmd mediainfo")
    else
        installed_deps+=("mediainfo|Recommended|Extract accurate video/audio metadata")
    fi
    
    if ! command -v ffprobe &>/dev/null; then
        optional_deps+=("ffprobe|Recommended|Alternative metadata extraction tool|$pkg_install_cmd ffmpeg")
    else
        installed_deps+=("ffprobe|Recommended|Alternative metadata extraction tool")
    fi
    
    # Image resizing tools (available for all OS)
    # sips (macOS only)
    if [[ "$SELECTED_OS" == "macOS" ]]; then
        if ! command -v sips &>/dev/null; then
            optional_deps+=("sips|Optional|macOS built-in image resizer|N/A - Should be pre-installed on macOS")
        else
            installed_deps+=("sips|Optional|macOS built-in image resizer")
        fi
    fi
    
    # vipsthumbnail (libvips - all platforms)
    if ! command -v vipsthumbnail &>/dev/null; then
        if [[ "$SELECTED_OS" == "macOS" ]]; then
            optional_deps+=("vips|Optional|Fast image resizer (vipsthumbnail)|brew install vips")
        elif [[ "$SELECTED_OS" == "Ubuntu/Debian" ]]; then
            optional_deps+=("vips|Optional|Fast image resizer (vipsthumbnail)|$pkg_install_cmd libvips-tools")
        elif [[ "$SELECTED_OS" == "Arch Linux" ]]; then
            optional_deps+=("vips|Optional|Fast image resizer (vipsthumbnail)|$pkg_install_cmd libvips")
        else
            optional_deps+=("vips|Optional|Fast image resizer (vipsthumbnail)|$pkg_install_cmd vips")
        fi
    else
        installed_deps+=("vips|Optional|Fast image resizer (vipsthumbnail)")
    fi
    
    # gawk (GNU AWK - all platforms)
    if ! command -v gawk &>/dev/null; then
        if [[ "$SELECTED_OS" == "macOS" ]]; then
            optional_deps+=("gawk|Optional|GNU AWK - Enhanced text processing|brew install gawk")
        else
            optional_deps+=("gawk|Optional|GNU AWK - Enhanced text processing|$pkg_install_cmd gawk")
        fi
    else
        installed_deps+=("gawk|Optional|GNU AWK - Enhanced text processing")
    fi
    
    # mawk (Mike's AWK - fastest implementation - all platforms)
    if ! command -v mawk &>/dev/null; then
        if [[ "$SELECTED_OS" == "macOS" ]]; then
            optional_deps+=("mawk|Optional|Mike's AWK - Fastest AWK implementation|brew install mawk")
        else
            optional_deps+=("mawk|Optional|Mike's AWK - Fastest AWK implementation|$pkg_install_cmd mawk")
        fi
    else
        installed_deps+=("mawk|Optional|Mike's AWK - Fastest AWK implementation")
    fi
    
    # gawk (GNU AWK - all platforms)
    if ! command -v gawk &>/dev/null; then
        if [[ "$SELECTED_OS" == "macOS" ]]; then
            optional_deps+=("gawk|Optional|GNU AWK - Enhanced text processing|brew install gawk")
        else
            optional_deps+=("gawk|Optional|GNU AWK - Enhanced text processing|$pkg_install_cmd gawk")
        fi
    else
        installed_deps+=("gawk|Optional|GNU AWK - Enhanced text processing")
    fi
    
    # mawk (Mike's AWK - all platforms)
    if ! command -v mawk &>/dev/null; then
        if [[ "$SELECTED_OS" == "macOS" ]]; then
            optional_deps+=("mawk|Optional|Mike's AWK - Fastest AWK implementation|brew install mawk")
        else
            optional_deps+=("mawk|Optional|Mike's AWK - Fastest AWK implementation|$pkg_install_cmd mawk")
        fi
    else
        installed_deps+=("mawk|Optional|Mike's AWK - Fastest AWK implementation")
    fi
    
    # Check for terminal image viewers (imgcat or chafa)
    if command -v imgcat &>/dev/null; then
        installed_deps+=("imgcat|Optional|Display poster images in terminal")
    elif command -v chafa &>/dev/null; then
        installed_deps+=("chafa|Optional|Display poster images in terminal")
    else
        optional_deps+=("chafa|Optional|Display poster images in terminal|$pkg_install_cmd chafa")
    fi
    
    # Show installed dependencies full details (hidden - keep for reference)
    if false; then
        for dep in "${installed_deps[@]}"; do
            IFS='|' read -r name status desc <<< "$dep"
            
            # Add OS-aware uninstall instructions for optional tools
            case "$name" in
                mediainfo)
                    if [[ "$SELECTED_OS" == "macOS" ]]; then
                        echo -e "    ${DIM}Uninstall: brew uninstall mediainfo${NC}"
                    elif [[ "$SELECTED_OS" == "Ubuntu/Debian" ]]; then
                        echo -e "    ${DIM}Uninstall: sudo apt-get remove mediainfo${NC}"
                    elif [[ "$SELECTED_OS" == "Fedora/RHEL/CentOS" ]]; then
                        echo -e "    ${DIM}Uninstall: sudo dnf remove mediainfo${NC}"
                    elif [[ "$SELECTED_OS" == "Arch Linux" ]]; then
                        echo -e "    ${DIM}Uninstall: sudo pacman -R mediainfo${NC}"
                    fi
                    ;;
                ffprobe)
                    if [[ "$SELECTED_OS" == "macOS" ]]; then
                        echo -e "    ${DIM}Uninstall: brew uninstall ffmpeg${NC}"
                    elif [[ "$SELECTED_OS" == "Ubuntu/Debian" ]]; then
                        echo -e "    ${DIM}Uninstall: sudo apt-get remove ffmpeg${NC}"
                    elif [[ "$SELECTED_OS" == "Fedora/RHEL/CentOS" ]]; then
                        echo -e "    ${DIM}Uninstall: sudo dnf remove ffmpeg${NC}"
                    elif [[ "$SELECTED_OS" == "Arch Linux" ]]; then
                        echo -e "    ${DIM}Uninstall: sudo pacman -R ffmpeg${NC}"
                    fi
                    ;;
                chafa)
                    if [[ "$SELECTED_OS" == "macOS" ]]; then
                        echo -e "    ${DIM}Uninstall: brew uninstall chafa${NC}"
                    elif [[ "$SELECTED_OS" == "Ubuntu/Debian" ]]; then
                        echo -e "    ${DIM}Uninstall: sudo apt-get remove chafa${NC}"
                    elif [[ "$SELECTED_OS" == "Fedora/RHEL/CentOS" ]]; then
                        echo -e "    ${DIM}Uninstall: sudo dnf remove chafa${NC}"
                    elif [[ "$SELECTED_OS" == "Arch Linux" ]]; then
                        echo -e "    ${DIM}Uninstall: sudo pacman -R chafa${NC}"
                    fi
                    ;;
                vips)
                    if [[ "$SELECTED_OS" == "macOS" ]]; then
                        echo -e "    ${DIM}Uninstall: brew uninstall vips${NC}"
                    elif [[ "$SELECTED_OS" == "Ubuntu/Debian" ]]; then
                        echo -e "    ${DIM}Uninstall: sudo apt-get remove libvips-tools${NC}"
                    elif [[ "$SELECTED_OS" == "Fedora/RHEL/CentOS" ]]; then
                        echo -e "    ${DIM}Uninstall: sudo dnf remove vips${NC}"
                    elif [[ "$SELECTED_OS" == "Arch Linux" ]]; then
                        echo -e "    ${DIM}Uninstall: sudo pacman -R libvips${NC}"
                    fi
                    ;;
                sips)
                    echo -e "    ${DIM}Uninstall: N/A - macOS system utility${NC}"
                    ;;
                brew)
                    echo -e "    ${DIM}Uninstall: /bin/bash -c \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/uninstall.sh)\"${NC}"
                    ;;
            esac
        done
    fi
    
    # Show missing required dependencies (critical - exit if found)
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        echo -e "${RED}✗ Missing Required Dependencies:${NC}"
        echo ""
        for dep in "${missing_deps[@]}"; do
            IFS='|' read -r name status desc install <<< "$dep"
            echo -e "  ${RED}✗ $name${NC} - $status"
            echo -e "    ${DIM}Purpose: $desc${NC}"
            echo -e "    ${DIM}Install: $install${NC}"
            echo ""
        done
        echo -e "${RED}Cannot continue without required dependencies.${NC}"
        echo ""
        exit 1
    fi
    
    # Show optional dependencies (with checkmarks for installed and circles for not installed)
    # Build a comprehensive list of all optional dependencies
    local -a all_optional_deps=()
    
    # Check each optional tool and mark as installed or not
    local opt_mediainfo="[ ] mediainfo|Recommended|Extract video/audio metadata|$pkg_install_cmd mediainfo"
    command -v mediainfo &>/dev/null && opt_mediainfo="[✓] mediainfo|Recommended|Extract video/audio metadata|installed"
    all_optional_deps+=("$opt_mediainfo")
    
    local opt_ffprobe="[ ] ffprobe|Recommended|Alternative metadata tool|$pkg_install_cmd ffmpeg"
    command -v ffprobe &>/dev/null && opt_ffprobe="[✓] ffprobe|Recommended|Alternative metadata tool|installed"
    all_optional_deps+=("$opt_ffprobe")
    
    # sips (macOS built-in, but show for all OS)
    local sips_install="N/A - macOS system tool"
    if [[ "$SELECTED_OS" != "macOS" ]]; then
        sips_install="Not available on $SELECTED_OS (macOS only)"
    fi
    local opt_sips="[ ] sips|Optional|Image resizer (macOS built-in)|$sips_install"
    command -v sips &>/dev/null && opt_sips="[✓] sips|Optional|Image resizer (macOS built-in)|installed"
    all_optional_deps+=("$opt_sips")
    
    # vips install command varies by OS
    local vips_install_cmd="$pkg_install_cmd vips"
    if [[ "$SELECTED_OS" == "Ubuntu/Debian" ]]; then
        vips_install_cmd="$pkg_install_cmd libvips-tools"
    elif [[ "$SELECTED_OS" == "Arch Linux" ]]; then
        vips_install_cmd="$pkg_install_cmd libvips"
    elif [[ "$SELECTED_OS" == "macOS" ]]; then
        vips_install_cmd="brew install vips"
    fi
    local opt_vips="[ ] vips|Optional|Fast image resizer|$vips_install_cmd"
    command -v vipsthumbnail &>/dev/null && opt_vips="[✓] vips|Optional|Fast image resizer|installed"
    all_optional_deps+=("$opt_vips")
    
    local opt_chafa="[ ] chafa|Optional|Terminal image viewer|$pkg_install_cmd chafa"
    command -v chafa &>/dev/null && opt_chafa="[✓] chafa|Optional|Terminal image viewer|installed"
    all_optional_deps+=("$opt_chafa")
    
    # imgcat (iTerm2 built-in on macOS, but show for all OS)
    local imgcat_install="iTerm2 built-in (macOS)"
    if [[ "$SELECTED_OS" != "macOS" ]]; then
        imgcat_install="Not available on $SELECTED_OS (iTerm2/macOS only)"
    fi
    local opt_imgcat="[ ] imgcat|Optional|iTerm2 image viewer (macOS)|$imgcat_install"
    command -v imgcat &>/dev/null && opt_imgcat="[✓] imgcat|Optional|iTerm2 image viewer (macOS)|installed"
    all_optional_deps+=("$opt_imgcat")
    
    # gawk (GNU AWK - available on all platforms)
    local gawk_install="$pkg_install_cmd gawk"
    if [[ "$SELECTED_OS" == "macOS" ]]; then
        gawk_install="brew install gawk"
    fi
    local opt_gawk="[ ] gawk|Optional|GNU AWK - Enhanced text processing|$gawk_install"
    command -v gawk &>/dev/null && opt_gawk="[✓] gawk|Optional|GNU AWK - Enhanced text processing|installed"
    all_optional_deps+=("$opt_gawk")
    
    # mawk (Mike's AWK - available on all platforms)
    local mawk_install="$pkg_install_cmd mawk"
    if [[ "$SELECTED_OS" == "macOS" ]]; then
        mawk_install="brew install mawk"
    fi
    local opt_mawk="[ ] mawk|Optional|Mike's AWK - Fastest AWK|$mawk_install"
    command -v mawk &>/dev/null && opt_mawk="[✓] mawk|Optional|Mike's AWK - Fastest AWK|installed"
    all_optional_deps+=("$opt_mawk")
    
    # Show the list (compact)
    echo -e "${YELLOW}Optional:${NC}"
    for opt_dep in "${all_optional_deps[@]}"; do
        IFS='|' read -r checkbox_name status desc install <<< "$opt_dep"
        if [[ "$checkbox_name" == "[✓]"* ]]; then
            local name="${checkbox_name#[✓] }"
            echo -e "  ${GREEN}[✓]${NC} ${name} ${DIM}- $desc${NC}"
        else
            local name="${checkbox_name#[ ] }"
            echo -e "  ${YELLOW}[ ]${NC} ${name} ${DIM}- $desc → ${CYAN}$install${NC}"
        fi
    done
    echo ""
    
    # Interactive installation/uninstall menu
    local -a install_opts=()
    local selected_idx=0
    
    # Build menu options based on what's available
    if [[ ${#optional_deps[@]} -gt 0 ]]; then
        # Build list of what will be installed
        local install_list=""
        for dep in "${optional_deps[@]}"; do
            IFS='|' read -r name status desc install <<< "$dep"
            if [[ -n "$install_list" ]]; then
                install_list="$install_list, $name"
            else
                install_list="$name"
            fi
        done
        install_opts+=("install|Install Missing Dependencies|Will install using homebrew: $install_list")
    fi
    
    if [[ ${#installed_deps[@]} -gt 0 ]]; then
        install_opts+=("uninstall|Uninstall Dependencies|Selectively remove installed optional tools")
    fi
    
    # Always add uninstall as option if not already added
    if [[ ${#install_opts[@]} -eq 0 ]]; then
        install_opts+=("uninstall|Uninstall Dependencies|Selectively remove installed optional tools")
    fi
    
    # Add skip first, change OS, then exit
    local temp_opts=("${install_opts[@]}")
    install_opts=()
    install_opts+=("skip|Skip and Continue|Run script with available dependencies only")
    install_opts+=("${temp_opts[@]}")
    install_opts+=("change_os|Change OS|Go back and select a different operating system")
    install_opts+=("exit|Exit Script|Cancel and exit")
    
    # Timer for flashing instruction
    local flash_start=$SECONDS
    
    # Hide cursor
    tput civis 2>/dev/null
    
    # Function to redraw the entire screen
    redraw_dependency_screen() {
        clear
        echo ""
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${CYAN}DEPENDENCY CHECK${NC}"
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
        
        # Show installed dependencies (ultra-compact)
        if [[ ${#installed_deps[@]} -gt 0 ]]; then
            echo -e "${GREEN}✓ Installed:${NC}"
            local dep_names=()
            for dep in "${installed_deps[@]}"; do
                IFS='|' read -r name status desc <<< "$dep"
                dep_names+=("$name")
            done
            echo -e "  ${DIM}$(IFS=', '; echo "${dep_names[*]}")${NC}"
            echo ""
        fi
        
        # Show optional dependencies (compact with checkboxes)
        echo -e "${YELLOW}Optional:${NC}"
        for opt_dep in "${all_optional_deps[@]}"; do
            IFS='|' read -r checkbox_name status desc install <<< "$opt_dep"
            if [[ "$checkbox_name" == "[✓]"* ]]; then
                local name="${checkbox_name#[✓] }"
                echo -e "  ${GREEN}[✓]${NC} ${name} ${DIM}- $desc${NC}"
            else
                local name="${checkbox_name#[ ] }"
                echo -e "  ${YELLOW}[ ]${NC} ${name} ${DIM}- $desc → ${CYAN}$install${NC}"
            fi
        done
        echo ""
        
        # Flash instruction for 5 seconds
        if [[ $((SECONDS - flash_start)) -lt 5 ]]; then
            echo -e "${YELLOW}\033[5mUse ↑/↓ arrow keys to navigate, Enter to select\033[25m${NC}"
        else
            echo -e "${YELLOW}Use ↑/↓ arrow keys to navigate, Enter to select${NC}"
        fi
        echo ""
        
        # Display options
        for i in "${!install_opts[@]}"; do
            local opt="${install_opts[$i]%%|*}"
            local rest="${install_opts[$i]#*|}"
            local title="${rest%%|*}"
            local desc="${rest#*|}"
            
            if [[ $i -eq $selected_idx ]]; then
                echo -e "  ${GREEN}► [✓] $title${NC}"
                echo -e "        ${DIM}$desc${NC}"
            else
                echo -e "  ${DIM}  [ ] $title${NC}"
                echo -e "        ${DIM}$desc${NC}"
            fi
            echo ""
        done
    }
    
    while true; do
        # Redraw the entire screen
        redraw_dependency_screen
        
        # Read key input
        read -rsn1 key 2>/dev/null
        
        if [[ "$key" == $'\x1b' ]]; then
            read -rsn2 -t 1 key 2>/dev/null
            case "$key" in
                '[A'|'OA') # Up arrow
                    ((selected_idx--))
                    if [[ $selected_idx -lt 0 ]]; then
                        selected_idx=$((${#install_opts[@]} - 1))
                    fi
                    ;;
                '[B'|'OB') # Down arrow
                    ((selected_idx++))
                    if [[ $selected_idx -ge ${#install_opts[@]} ]]; then
                        selected_idx=0
                    fi
                    ;;
            esac
        elif [[ "$key" == "" ]]; then
            # Enter key pressed
            local selected_opt="${install_opts[$selected_idx]%%|*}"
            tput cnorm 2>/dev/null
            
            if [[ "$selected_opt" == "exit" ]]; then
                clear
                echo ""
                echo -e "${YELLOW}Setup cancelled.${NC}"
                echo ""
                exit 0
            elif [[ "$selected_opt" == "skip" ]]; then
                clear
                echo ""
                echo -e "${GREEN}✓ Continuing with available dependencies${NC}"
                echo ""
                return 0
            elif [[ "$selected_opt" == "change_os" ]]; then
                # Remove saved OS selection and go back to OS menu
                rm -f "${CACHE_DIR}/selected_os.txt" 2>/dev/null
                clear
                echo ""
                echo -e "${CYAN}Returning to OS selection...${NC}"
                echo ""
                sleep 1
                # Call OS selection again
                select_operating_system
                # After OS change, re-run dependency check
                check_and_install_dependencies
                return 0
            elif [[ "$selected_opt" == "uninstall" ]]; then
                # Show uninstall menu
                select_uninstall_dependencies
                # After uninstall, re-run dependency check
                check_and_install_dependencies
                return 0
            elif [[ "$selected_opt" == "install" ]]; then
                # Show install menu with checkbox selection
                select_install_dependencies
                # After install, re-run dependency check
                check_and_install_dependencies
                return 0
            fi
        fi
    done
}

# ═══════════════════════════════════════════════════════════════════════════════
# CACHE CONFIGURATION - How to manually edit cache entries
# ═══════════════════════════════════════════════════════════════════════════════
#
# CACHE FILE LOCATION:
#   Default: ~/.movie_simulator/MOVIE UNIFIED CACHE.txt
#   Each line is one movie in this format:
#
#   Title|Year|IMDb_ID|TMDb_ID|Timestamp
#
# EXAMPLE CACHE ENTRIES:
#   The Matrix|1999|tt0133093|603|1699564800
#   Blade Runner|1982|tt0083658|78|1699564900
#   Inception|2010|tt1375666|27205|1699565000
#
# HOW TO MANUALLY ADD OR FIX ENTRIES:
#   1. Open cache file: nano ~/.movie_simulator/MOVIE UNIFIED CACHE.txt
#   
#   2. Add a new line with this exact format (pipe-separated):
#      Movie Title Here|Year|tt#######|tmdb_number|unix_timestamp
#   
#   3. Find IMDb ID:
#      • Search on https://www.imdb.com/
#      • Copy ID from URL: https://www.imdb.com/title/tt0133093/ → tt0133093
#   
#   4. Find TMDb ID:
#      • Search on https://www.themoviedb.org/
#      • Copy number from URL: https://www.themoviedb.org/movie/603 → 603
#   
#   5. Generate timestamp: date +%s
#      (or just use any number like 1234567890)
#   
#   6. Save the file and re-run the script
#
# IMPORTANT NOTES:
#   • Title must EXACTLY match the filename's parsed title
#   • Year must be 4 digits
#   • IMDb ID must start with "tt" followed by 7-8 digits
#   • TMDb ID is just a number (no prefix)
#   • Use pipe symbol | to separate fields (no spaces around pipes)
#
# POSTER CACHE:
#   Location: ~/.movie_simulator/posters/
#   Files: {imdb_id}.jpg and {imdb_id}_resized.jpg
#
# TO CLEAR ALL CACHE:
#   rm -rf ~/.movie_simulator/
#
# ═══════════════════════════════════════════════════════════════════════════════

# Main cache directory (stores IMDb/TMDb lookups and posters)
CACHE_DIR="${HOME}/.movie_simulator"

# JSON Database directory for storing TMDb API responses
JSON_DB_DIR="$CACHE_DIR/json_db"

# Resolution-based cache files (set dynamically based on source content)
# Will be either MOVIE 4K CACHE.txt or MOVIE 1080p CACHE.txt
CACHE_FILE=""

# TV Show metadata cache file
TV_CACHE_FILE="$CACHE_DIR/SHOWS TV CACHE.txt"
ANIME_CACHE_FILE="$CACHE_DIR/SHOWS ANIME CACHE.txt"
CARTOON_TV_CACHE_FILE="$CACHE_DIR/SHOWS CARTOONS CACHE.txt"

# TV Show episode cache directories
TV_EPISODE_CACHE_DIR="$CACHE_DIR/SHOWS TV/episodes"
ANIME_EPISODE_CACHE_DIR="$CACHE_DIR/SHOWS ANIME/episodes"
CARTOON_EPISODE_CACHE_DIR="$CACHE_DIR/SHOWS CARTOONS/episodes"

# TV Show JSON database files
TV_JSON_DB_FILE="$JSON_DB_DIR/tvshow_json.db"
ANIME_TV_JSON_DB_FILE="$JSON_DB_DIR/tvshow_anime_json.db"
CARTOON_TV_JSON_DB_FILE="$JSON_DB_DIR/tvshow_cartoons_json.db"

# Movie metadata cache files
CARTOON_CACHE_FILE="$CACHE_DIR/MOVIE CARTOONS CACHE.txt"
ANIME_MOVIE_CACHE_FILE="$CACHE_DIR/MOVIE ANIME CACHE.txt"

# In-memory parse cache arrays (bash 3.x compatible)
declare -a PARSE_CACHE_PATHS      # Array of file paths
declare -a PARSE_CACHE_TITLES     # Array of titles
declare -a PARSE_CACHE_YEARS      # Array of years
declare -a PARSE_CACHE_NORMALIZED # Array of normalized titles
PARSE_CACHE_COUNT=0               # Number of cached entries

# User preferences cache
NAMING_PREFS="$CACHE_DIR/naming_scheme.txt"
TV_NAMING_PREFS="$CACHE_DIR/tv_naming_scheme.txt"
CUSTOM_FOLDER_FORMAT="$CACHE_DIR/custom_folder_format.txt"
CUSTOM_FILE_FORMAT="$CACHE_DIR/custom_file_format.txt"
TV_CUSTOM_FOLDER_FORMAT="$CACHE_DIR/tv_custom_folder_format.txt"
TV_CUSTOM_EPISODE_FORMAT="$CACHE_DIR/tv_custom_episode_format.txt"

# Poster cache directory
POSTER_CACHE_DIR="$CACHE_DIR/posters"
TV_POSTER_CACHE_DIR="$CACHE_DIR/tv_posters"

# Poster display preferences
POSTER_PREFS="$CACHE_DIR/poster_display.txt"
TV_POSTER_PREFS="$CACHE_DIR/tv_poster_display.txt"

# AWK Parser preference (default to system awk, can be set to gawk)
AWK_PARSER="awk"
[[ -f "${CACHE_DIR}/awk_parser.txt" ]] && AWK_PARSER=$(cat "${CACHE_DIR}/awk_parser.txt")

# Menu selection preferences (persist across runs)
LINK_TYPE_PREFS="$CACHE_DIR/link_type.txt"
HARDLINK_MODE_PREFS="$CACHE_DIR/hardlink_mode.txt"
COPY_MODE_PREFS="$CACHE_DIR/copy_mode.txt"
SYMLINK_MODE_PREFS="$CACHE_DIR/symlink_mode.txt"
EXTRAS_MODE_PREFS="$CACHE_DIR/extras_mode.txt"
TV_EXTRAS_MODE_PREFS="$CACHE_DIR/tv_extras_mode.txt"
TV_RENAME_EPISODES_PREFS="$CACHE_DIR/tv_rename_episodes.txt"

# Create cache directories
mkdir -p "$CACHE_DIR"
mkdir -p "$TV_EPISODE_CACHE_DIR"
mkdir -p "$ANIME_EPISODE_CACHE_DIR"
mkdir -p "$CARTOON_EPISODE_CACHE_DIR"
mkdir -p "$JSON_DB_DIR"
mkdir -p "$POSTER_CACHE_DIR"
mkdir -p "$TV_POSTER_CACHE_DIR"

# Fix any cache files missing trailing newline (one-time check at startup)
for cache in "$CACHE_DIR"/movie_cache*.txt "$CARTOON_CACHE_FILE" "$ANIME_MOVIE_CACHE_FILE" "$TV_CACHE_FILE" "$CARTOON_TV_CACHE_FILE"; do
    if [[ -f "$cache" && -s "$cache" ]]; then
        [[ "$(tail -c 1 "$cache" 2>/dev/null)" != "" ]] && echo "" >> "$cache"
    fi
done

# TMDb API Configuration
TMDB_API_BASE="https://api.themoviedb.org/3"

# Load TMDb API key from file (required - must be set via Settings menu)
if [[ -f "${CACHE_DIR}/tmdb_api_key.txt" ]]; then
    TMDB_API_KEY=$(cat "${CACHE_DIR}/tmdb_api_key.txt")
else
    TMDB_API_KEY=""
fi

# API delay between requests (seconds) - reduced for API calls
API_DELAY=0.25

# API call counter for statistics
API_CALL_COUNT=0

# ═══════════════════════════════════════════════════════════════════════════════
# MEDIAINFO EXTRACTION TOOL PREFERENCE
# ═══════════════════════════════════════════════════════════════════════════════
# Choose which tool to use for extracting video/audio metadata:
#
# "mediainfo" - Uses MediaInfo (more accurate, better HDR detection)
#               Install: brew install mediainfo
#               Pros: More detailed, better format detection, DTS-HD MA, HDR10+
#               Auto-fallback to ffprobe if not installed
#
# "ffprobe"   - Uses ffprobe (comes with ffmpeg, already installed)
#               Pros: Lightweight, fast, always available
#               Good for: basic codec, resolution, audio channel detection
#
# "off"       - Disable MediaInfo extraction (uses filename parsing only)
#               Faster but less accurate
#
MEDIAINFO_TOOL="mediainfo"

# Load saved MediaInfo tool preference if exists
if [[ -f "${CACHE_DIR}/mediainfo_tool.txt" ]]; then
    MEDIAINFO_TOOL=$(cat "${CACHE_DIR}/mediainfo_tool.txt")
fi

# ═══════════════════════════════════════════════════════════════════════════════
# MEDIAINFO/FFPROBE RESOLUTION ROUNDING
# ═══════════════════════════════════════════════════════════════════════════════
# Control whether resolution extracted from video files should be rounded
# to standard resolutions (applies to both movies and TV shows)
#
# "yes" - Round resolutions: 800p→1080p, 1028p→1080p, 719p→720p, etc.
# "no"  - Use exact resolution: 800p, 1028p, 719p, etc.
#
ROUND_RESOLUTION="yes"

# Load saved resolution rounding preference if exists
if [[ -f "${CACHE_DIR}/round_resolution.txt" ]]; then
    ROUND_RESOLUTION=$(cat "${CACHE_DIR}/round_resolution.txt")
fi

# ═══════════════════════════════════════════════════════════════════════════════
# POSTER DISPLAY PREFERENCES
# ═══════════════════════════════════════════════════════════════════════════════
# Control whether posters are displayed in terminal during processing
#
# "yes" - Display posters for movies/TV shows in terminal (requires chafa/imgcat)
# "no"  - Skip poster display (faster processing)
#
SHOW_MOVIE_POSTERS="yes"
SHOW_SERIES_POSTERS="yes"

# Load saved poster display preferences if they exist
if [[ -f "$POSTER_PREFS" ]]; then
    SHOW_MOVIE_POSTERS=$(cat "$POSTER_PREFS")
fi
if [[ -f "$TV_POSTER_PREFS" ]]; then
    SHOW_SERIES_POSTERS=$(cat "$TV_POSTER_PREFS")
fi
# ═══════════════════════════════════════════════════════════════════════════════

# Global variables
SOURCE=""
DESTINATION=""
TITLE=""
YEAR=""
IMDB=""
TMDB=""
EDITION=""
IS_3D=false
CUSTOM_FORMAT=""
QUALITY=""
AUDIO_CODEC=""
AUDIO_CHANNELS=""
HDR_TYPE=""
VIDEO_CODEC=""
RELEASE_GROUP=""
USE_COPY=false
USE_SYMLINK=false
COPY_ENTIRE_FOLDER=false      # When USE_COPY is true, copy entire source folder structure
HARDLINK_ENTIRE_FOLDER=false  # When hardlinking, hardlink entire source folder structure
SYMLINK_ENTIRE_FOLDER=false   # When USE_SYMLINK is true, symlink entire source folder structure
HARDLINK_EXTRAS=true          # Default: Hardlink and categorize extras/bonus/featurettes into proper folders
DISABLE_IMAGES=false          # Set to true to disable poster image display
NAMING_FOLDER="7"             # Default: Jellyfin (TMDb)
NAMING_FILE="18"              # Default: Jellyfin (TMDb)

# Parsed filename variables
PARSED_TITLE=""
PARSED_YEAR=""
PARSED_IMDB=""
PARSED_FULL_QUALITY=""
PARSED_AUDIO_CODEC=""
PARSED_AUDIO_CHANNELS=""
PARSED_HDR=""
PARSED_VIDEO_CODEC=""
PARSED_RELEASE_GROUP=""
PARSED_EDITION=""
PARSED_CUSTOM_FORMAT=""
PARSED_3D=false

# TV Show global variables
TV_SERIES_TITLE=""
TV_YEAR=""
TV_SEASON=""
TV_EPISODE=""
TV_EPISODE_END=""
TV_EPISODE_TITLE=""
TV_ABSOLUTE=""
TV_AIR_DATE=""
TV_IMDB=""
TV_TMDB=""
TV_TVDB=""
TV_NAMING_FOLDER=0
TV_NAMING_EPISODE=0
TV_RENAME_EPISODES="true"
TV_FETCH_TMDB_TITLES="false"

# Batch processing - cached series folder info (parsed once, reused for all episodes)
BATCH_SERIES_TITLE=""
BATCH_SERIES_YEAR=""
BATCH_SERIES_TMDB_HINT=""
BATCH_SERIES_IMDB_HINT=""
BATCH_SERIES_TVDB_HINT=""
SKIP_SOURCE_FOLDER=""  # Container folder path to skip (set dynamically)
TV_LINK_TYPE="hardlink"

# Track processed files to prevent duplicate hardlinks in same script run (space-separated list of inodes)
PROCESSED_FILES=""

# File-based lock directory for multi-instance coordination
# Will be set dynamically based on cache selection (initialized here, updated after cache selection)
PROCESSING_LOCKS_DIR="/tmp/movie_simulator_processing_locks"

# TV poster session cache (prevents re-fetching for same series)
CURRENT_SERIES_POSTER_URL=""
CURRENT_SERIES_POSTER_SHOWN=false
CURRENT_SERIES_NAME=""

# ═══════════════════════════════════════════════════════════════════════════════
# DEBUG MODE
# ═══════════════════════════════════════════════════════════════════════════════
# DEBUG MODE
# ═══════════════════════════════════════════════════════════════════════════════
# Enable debug logging for troubleshooting
# Set to "true" to enable detailed debug output
# Debug logs show:
# - Filename parsing results (title, year, season, episode extraction)
# - API calls and responses (TMDb, IMDb searches)
# - Cache lookups and metadata fetching
# - File matching and processing steps
#
# Load debug settings from cache (can be toggled via Settings menu)
# Levels: off, low, medium, high
# Backward compatible: "true" → "high", "false" → "off"
DEBUG_LEVEL_MOVIES="off"
DEBUG_LEVEL_TV="off"

if [[ -f "${CACHE_DIR}/debug_mode_movies.txt" ]]; then
    MOVIES_VALUE=$(cat "${CACHE_DIR}/debug_mode_movies.txt")
    case "$MOVIES_VALUE" in
        true) DEBUG_LEVEL_MOVIES="high" ;;
        false) DEBUG_LEVEL_MOVIES="off" ;;
        off|low|medium|high) DEBUG_LEVEL_MOVIES="$MOVIES_VALUE" ;;
        *) DEBUG_LEVEL_MOVIES="off" ;;
    esac
fi

if [[ -f "${CACHE_DIR}/debug_mode_tv.txt" ]]; then
    TV_VALUE=$(cat "${CACHE_DIR}/debug_mode_tv.txt")
    case "$TV_VALUE" in
        true) DEBUG_LEVEL_TV="high" ;;
        false) DEBUG_LEVEL_TV="off" ;;
        off|low|medium|high) DEBUG_LEVEL_TV="$TV_VALUE" ;;
        *) DEBUG_LEVEL_TV="off" ;;
    esac
fi

# Maintain backward compatibility with old DEBUG_MODE variables
DEBUG_MODE_MOVIES="false"
DEBUG_MODE_TV="false"
[[ "$DEBUG_LEVEL_MOVIES" != "off" ]] && DEBUG_MODE_MOVIES="true"
[[ "$DEBUG_LEVEL_TV" != "off" ]] && DEBUG_MODE_TV="true"

# Track current processing type (movie or tv) for context-aware debug messages
# Default to movie, will be set to "tv" by process_tv_episode()
PROCESSING_TYPE="movie"

# Helper function for level-based debug checks
# Usage: should_debug low && echo "[DEBUG] message"
# Levels: low (essential operations), medium (parsing details), high (verbose)
should_debug() {
    local required_level="$1"
    local current_level
    
    if [[ "$PROCESSING_TYPE" == "tv" ]]; then
        current_level="$DEBUG_LEVEL_TV"
    else
        current_level="$DEBUG_LEVEL_MOVIES"
    fi
    
    # Map levels to numeric values for comparison
    local current_val=0
    local required_val=0
    
    case "$current_level" in
        off) current_val=0 ;;
        low) current_val=1 ;;
        medium) current_val=2 ;;
        high) current_val=3 ;;
    esac
    
    case "$required_level" in
        low) required_val=1 ;;
        medium) required_val=2 ;;
        high) required_val=3 ;;
    esac
    
    # Return 0 (true) if current level >= required level
    [[ $current_val -ge $required_val ]]
}

# Diagnostics mode - detailed parallel job and resource logging
DIAGNOSTICS_MODE="false"
[[ -f "${CACHE_DIR}/diagnostics_mode.txt" ]] && DIAGNOSTICS_MODE=$(cat "${CACHE_DIR}/diagnostics_mode.txt")

# Load parallel processing settings from cache
PARALLEL_PROCESSING="false"
PARALLEL_JOBS=4
ROLLING_QUEUE_MODE="true"
[[ -f "${CACHE_DIR}/parallel_processing.txt" ]] && PARALLEL_PROCESSING=$(cat "${CACHE_DIR}/parallel_processing.txt")
[[ -f "${CACHE_DIR}/parallel_jobs.txt" ]] && PARALLEL_JOBS=$(cat "${CACHE_DIR}/parallel_jobs.txt")
[[ -f "${CACHE_DIR}/rolling_queue_mode.txt" ]] && ROLLING_QUEUE_MODE=$(cat "${CACHE_DIR}/rolling_queue_mode.txt")

# Load parallel parsing settings from cache
PARALLEL_PARSING="false"
PARALLEL_PARSE_JOBS=4
PARSING_ROLLING_QUEUE_MODE="false"
[[ -f "${CACHE_DIR}/parallel_parsing.txt" ]] && PARALLEL_PARSING=$(cat "${CACHE_DIR}/parallel_parsing.txt")
[[ -f "${CACHE_DIR}/parallel_parse_jobs.txt" ]] && PARALLEL_PARSE_JOBS=$(cat "${CACHE_DIR}/parallel_parse_jobs.txt")
[[ -f "${CACHE_DIR}/parsing_rolling_queue_mode.txt" ]] && PARSING_ROLLING_QUEUE_MODE=$(cat "${CACHE_DIR}/parsing_rolling_queue_mode.txt")

# JSON Database and API mode settings
USE_JSON_DB="true"        # Check JSON database before making API calls
USE_API_CALLS="true"       # Allow TMDb API calls when JSON DB doesn't have data
JSON_DB_MODE="hybrid"      # Options: "json_only", "api_only", "hybrid" (check JSON first, fallback to API)
[[ -f "${CACHE_DIR}/use_json_db.txt" ]] && USE_JSON_DB=$(cat "${CACHE_DIR}/use_json_db.txt")
[[ -f "${CACHE_DIR}/use_api_calls.txt" ]] && USE_API_CALLS=$(cat "${CACHE_DIR}/use_api_calls.txt")
[[ -f "${CACHE_DIR}/json_db_mode.txt" ]] && JSON_DB_MODE=$(cat "${CACHE_DIR}/json_db_mode.txt")

# Print functions
print_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
print_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
print_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
print_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Detect resolution and set appropriate cache file
set_cache_by_resolution() {
    local video_file="$1"
    
    # Use session cache mode if set, otherwise read from file
    local cache_mode="${SESSION_CACHE_MODE:-}"
    if [[ -z "$cache_mode" ]]; then
        local cache_mode_file="$CACHE_DIR/cache_mode.txt"
        cache_mode="4k"
        if [[ -f "$cache_mode_file" ]]; then
            cache_mode=$(cat "$cache_mode_file")
        fi
    fi
    
    # Set cache file and poster directory based on user's manual selection
    case "$cache_mode" in
        unified)
            CACHE_FILE="$CACHE_DIR/MOVIE UNIFIED CACHE.txt"
            JSON_DB_FILE="$JSON_DB_DIR/movie_json.db"
            POSTER_CACHE_DIR="$CACHE_DIR/posters"
            ;;
        4k)
            CACHE_FILE="$CACHE_DIR/MOVIE 4K CACHE.txt"
            JSON_DB_FILE="$JSON_DB_DIR/movie_4k_json.db"
            POSTER_CACHE_DIR="$CACHE_DIR/posters_4k"
            ;;
        1080p)
            CACHE_FILE="$CACHE_DIR/MOVIE 1080p CACHE.txt"
            JSON_DB_FILE="$JSON_DB_DIR/movie_1080p_json.db"
            POSTER_CACHE_DIR="$CACHE_DIR/posters_1080p"
            ;;
        1080p_softcore)
            CACHE_FILE="$CACHE_DIR/MOVIE 1080p SOFTCORE CACHE.txt"
            JSON_DB_FILE="$JSON_DB_DIR/movie_1080p_softcore_json.db"
            POSTER_CACHE_DIR="$CACHE_DIR/posters_1080p_softcore"
            ;;
        4k_softcore)
            CACHE_FILE="$CACHE_DIR/MOVIE 4K SOFTCORE CACHE.txt"
            JSON_DB_FILE="$JSON_DB_DIR/movie_4k_softcore_json.db"
            POSTER_CACHE_DIR="$CACHE_DIR/posters_4k_softcore"
            ;;
        cartoons)
            CACHE_FILE="$CARTOON_CACHE_FILE"
            JSON_DB_FILE="$CARTOON_JSON_DB_FILE"
            POSTER_CACHE_DIR="$CACHE_DIR/posters_cartoons"
            ;;
        anime)
            CACHE_FILE="$ANIME_MOVIE_CACHE_FILE"
            JSON_DB_FILE="$ANIME_MOVIE_JSON_DB_FILE"
            POSTER_CACHE_DIR="$CACHE_DIR/posters_anime"
            ;;
        *)
            # Default to 4K if unknown
            CACHE_FILE="$CACHE_DIR/MOVIE 4K CACHE.txt"
            JSON_DB_FILE="$JSON_DB_DIR/movie_4k_json.db"
            POSTER_CACHE_DIR="$CACHE_DIR/posters_4k"
            ;;
    esac
    
    # Set lock directory based on cache selection (so different cache = different locks)
    # This allows multiple instances using different caches to run without interfering
    PROCESSING_LOCKS_DIR="/tmp/movie_simulator_locks_${cache_mode}"
    mkdir -p "$PROCESSING_LOCKS_DIR" 2>/dev/null
    
    # Create poster cache directory if it doesn't exist
    mkdir -p "$POSTER_CACHE_DIR"
    
    # Ensure cache file exists
    touch "$CACHE_FILE" 2>/dev/null || true
}

# Manage Movie caches - clear/reset individual caches
manage_movie_caches() {
    local manage_cache_files=(
        "clear_unified|MOVIE UNIFIED CACHE.txt|Clear MOVIE UNIFIED CACHE.txt"
        "clear_4k|MOVIE 4K CACHE.txt|Clear MOVIE 4K CACHE.txt"
        "clear_1080p|MOVIE 1080p CACHE.txt|Clear MOVIE 1080p CACHE.txt"
        "clear_1080p_softcore|MOVIE 1080p SOFTCORE CACHE.txt|Clear MOVIE 1080p SOFTCORE CACHE.txt"
        "clear_4k_softcore|MOVIE 4K SOFTCORE CACHE.txt|Clear MOVIE 4K SOFTCORE CACHE.txt"
        "clear_cartoons|MOVIE CARTOONS CACHE.txt|Clear MOVIE CARTOONS CACHE.txt"
        "clear_anime|MOVIE ANIME CACHE.txt|Clear MOVIE ANIME CACHE.txt"
    )
    
    local manage_choice="clear_unified"  # Default to first option
    while true; do
        local -a manage_opts=()
        local total_entries=0
        
        for manage_info in "${manage_cache_files[@]}"; do
            IFS='|' read -r manage_key manage_filename manage_desc <<< "$manage_info"
            local manage_cache_path="$CACHE_DIR/$manage_filename"
            local manage_entry_count=0
            if [[ -f "$manage_cache_path" ]]; then
                manage_entry_count=$(awk 'NF' "$manage_cache_path" 2>/dev/null | wc -l | tr -d ' ')
                ((total_entries += manage_entry_count))
            fi
            manage_opts+=("${manage_key}|${manage_desc} - ${manage_entry_count} entries")
        done
        
        manage_opts+=("clear_all|⚠️  Clear ALL Movie caches - ${total_entries} total entries")
        
        if arrow_select_menu "MANAGE MOVIE CACHES" "$manage_choice" "manage_choice" "${manage_opts[@]}"; then
            case "$manage_choice" in
                clear_unified) > "$CACHE_DIR/MOVIE UNIFIED CACHE.txt" ;;
                clear_4k) > "$CACHE_DIR/MOVIE 4K CACHE.txt" ;;
                clear_1080p) > "$CACHE_DIR/MOVIE 1080p CACHE.txt" ;;
                clear_1080p_softcore) > "$CACHE_DIR/MOVIE 1080p SOFTCORE CACHE.txt" ;;
                clear_4k_softcore) > "$CACHE_DIR/MOVIE 4K SOFTCORE CACHE.txt" ;;
                clear_cartoons) > "$CACHE_DIR/MOVIE CARTOONS CACHE.txt" ;;
                clear_anime) > "$CACHE_DIR/MOVIE ANIME CACHE.txt" ;;
                clear_all) 
                    > "$CACHE_DIR/MOVIE UNIFIED CACHE.txt"
                    > "$CACHE_DIR/MOVIE 4K CACHE.txt"
                    > "$CACHE_DIR/MOVIE 1080p CACHE.txt"
                    > "$CACHE_DIR/MOVIE 1080p SOFTCORE CACHE.txt"
                    > "$CACHE_DIR/MOVIE 4K SOFTCORE CACHE.txt"
                    > "$CACHE_DIR/MOVIE CARTOONS CACHE.txt"
                    > "$CACHE_DIR/MOVIE ANIME CACHE.txt"
                    ;;
            esac
            # Menu will redraw automatically with updated counts - no flash
        else
            break
        fi
    done
}

# Manage Series caches - clear/reset individual caches
manage_series_caches() {
    local manage_tv_cache_files=(
        "clear_tv|SHOWS TV CACHE.txt|Clear SHOWS TV CACHE.txt"
        "clear_anime|SHOWS ANIME CACHE.txt|Clear SHOWS ANIME CACHE.txt"
        "clear_cartoons|SHOWS CARTOONS CACHE.txt|Clear SHOWS CARTOONS CACHE.txt"
    )
    
    local manage_choice="clear_tv"  # Default to first option
    while true; do
        local -a manage_opts=()
        local total_tv_entries=0
        
        for manage_tv_info in "${manage_tv_cache_files[@]}"; do
            IFS='|' read -r manage_tv_key manage_tv_filename manage_tv_desc <<< "$manage_tv_info"
            local manage_tv_cache_path="$CACHE_DIR/$manage_tv_filename"
            local manage_tv_entry_count=0
            if [[ -f "$manage_tv_cache_path" ]]; then
                manage_tv_entry_count=$(awk 'NF' "$manage_tv_cache_path" 2>/dev/null | wc -l | tr -d ' ')
                ((total_tv_entries += manage_tv_entry_count))
            fi
            manage_opts+=("${manage_tv_key}|${manage_tv_desc} - ${manage_tv_entry_count} entries")
        done
        
        manage_opts+=("clear_all|⚠️  Clear ALL Series caches - ${total_tv_entries} total entries")
        
        if arrow_select_menu "MANAGE SERIES CACHES" "$manage_choice" "manage_choice" "${manage_opts[@]}"; then
            case "$manage_choice" in
                clear_tv) > "$CACHE_DIR/SHOWS TV CACHE.txt" ;;
                clear_anime) > "$CACHE_DIR/SHOWS ANIME CACHE.txt" ;;
                clear_cartoons) > "$CACHE_DIR/SHOWS CARTOONS CACHE.txt" ;;
                clear_all)
                    > "$CACHE_DIR/SHOWS TV CACHE.txt"
                    > "$CACHE_DIR/SHOWS ANIME CACHE.txt"
                    > "$CACHE_DIR/SHOWS CARTOONS CACHE.txt"
                    ;;
            esac
            # Menu will redraw automatically with updated counts - no flash
        else
            break
        fi
    done
}

# Manage Episode caches - clear/reset episode cache directories
manage_episode_caches() {
    local manage_ep_choice="clear_tv_episodes"  # Default to first option
    while true; do
        local -a manage_ep_opts=()
        local manage_ep_cache_dirs=(
            "clear_tv_episodes|SHOWS TV/episodes|Clear TV Show Episode Caches"
            "clear_anime_episodes|SHOWS ANIME/episodes|Clear Anime Episode Caches"
            "clear_cartoon_episodes|SHOWS CARTOONS/episodes|Clear Cartoon Episode Caches"
        )
        
        local total_episode_files=0
        for manage_ep_info in "${manage_ep_cache_dirs[@]}"; do
            IFS='|' read -r manage_ep_key manage_ep_dir manage_ep_desc <<< "$manage_ep_info"
            local manage_ep_cache_path="$CACHE_DIR/$manage_ep_dir"
            local manage_ep_file_count=0
            if [[ -d "$manage_ep_cache_path" ]]; then
                manage_ep_file_count=$(find "$manage_ep_cache_path" -type f -name "*.txt" 2>/dev/null | wc -l | tr -d ' ')
                ((total_episode_files += manage_ep_file_count))
            fi
            manage_ep_opts+=("${manage_ep_key}|${manage_ep_desc} - ${manage_ep_file_count} files")
        done
        
        manage_ep_opts+=("clear_all_episodes|⚠️  Clear ALL Episode Caches - ${total_episode_files} total files")
        
        if arrow_select_menu "MANAGE EPISODE CACHES" "$manage_ep_choice" "manage_ep_choice" "${manage_ep_opts[@]}"; then
            case "$manage_ep_choice" in
                clear_tv_episodes) 
                    rm -rf "$TV_EPISODE_CACHE_DIR"/*.txt 2>/dev/null
                    ;;
                clear_anime_episodes) 
                    rm -rf "$ANIME_EPISODE_CACHE_DIR"/*.txt 2>/dev/null
                    ;;
                clear_cartoon_episodes) 
                    rm -rf "$CARTOON_EPISODE_CACHE_DIR"/*.txt 2>/dev/null
                    ;;
                clear_all_episodes)
                    rm -rf "$TV_EPISODE_CACHE_DIR"/*.txt 2>/dev/null
                    rm -rf "$ANIME_EPISODE_CACHE_DIR"/*.txt 2>/dev/null
                    rm -rf "$CARTOON_EPISODE_CACHE_DIR"/*.txt 2>/dev/null
                    ;;
            esac
            # Menu will redraw automatically with updated counts - no flash
        else
            break
        fi
    done
}

# API call helper - handles delay and counting
api_delay() {
    sleep $API_DELAY
    ((API_CALL_COUNT++))
    
    # Also write to file for parallel process tracking
    # Use atomic append which is safe for parallel writes on most filesystems
    if [[ -n "${API_COUNTER_FILE:-}" ]]; then
        printf '1\n' >> "$API_COUNTER_FILE"
    fi
}

# Cache functions
get_cached_movie() {
    local title="$1"
    local year="$2"
    
    if [[ -f "$CACHE_FILE" ]]; then
        $AWK_PARSER -F'|' -v title="$title" -v year="$year" '$1 == title && $2 == year {print; exit}' "$CACHE_FILE" 2>/dev/null
    fi
}

save_to_cache() {
    local title="$1"
    local year="$2"
    local imdb="$3"
    local tmdb="$4"
    local timestamp=$(date +%s)
    should_debug high && echo "[DEBUG] save_to_cache: CACHE_FILE='$CACHE_FILE' title='$title' year='$year' imdb='$imdb' tmdb='$tmdb'" >&2
    
    # Check if CACHE_FILE is set
    if [[ -z "$CACHE_FILE" ]]; then
        echo "[ERROR] CACHE_FILE is not set, cannot save to cache" >&2
        return 1
    fi
    
    # Check if entry already exists (match by title and year, or by IDs)
    if [[ -f "$CACHE_FILE" ]]; then
        local existing_entry=""
        # Check by title and year
        existing_entry=$($AWK_PARSER -F'|' -v title="$title" -v year="$year" '$1 == title && $2 == year {print; exit}' "$CACHE_FILE" 2>/dev/null)
        
        # Also check if TMDb ID already exists (avoid duplicate IDs)
        if [[ -z "$existing_entry" ]] && [[ -n "$tmdb" ]]; then
            existing_entry=$($AWK_PARSER -F'|' -v tmdb="$tmdb" '$4 == tmdb {print; exit}' "$CACHE_FILE" 2>/dev/null)
        fi
        
        # If entry exists, don't add duplicate
        if [[ -n "$existing_entry" ]]; then
            should_debug low && echo "[DEBUG] Movie already in cache: $title ($year)" >&2
            return 0
        fi
    fi
    
    echo "${title}|${year}|${imdb}|${tmdb}|${timestamp}" >> "$CACHE_FILE"
    echo "[INFO] Saved to cache" >&2
    # Increment cache counter if it exists (for statistics)
    [[ -n "$CACHE_COUNT" ]] && CACHE_COUNT=$((CACHE_COUNT + 1))
}

extract_from_cache() {
    local cache_line="$1"
    local field="$2"
    case "$field" in
        imdb) echo "$cache_line" | cut -d'|' -f3 ;;
        tmdb) echo "$cache_line" | cut -d'|' -f4 ;;
    esac
}

# Fast in-memory array-based parse cache lookup (bash 3.x compatible)
# Searches arrays using simple loop (no grep, no disk I/O, pure memory access)
lookup_parse_cache() {
    local filepath="$1"
    
    if [[ $PARSE_CACHE_COUNT -eq 0 ]]; then
        echo ""
        return 1
    fi
    
    # Linear search through arrays (still very fast for moderate sizes)
    local i=0
    while [[ $i -lt $PARSE_CACHE_COUNT ]]; do
        if [[ "${PARSE_CACHE_PATHS[$i]}" == "$filepath" ]]; then
            # Found match - return title|year
            echo "${PARSE_CACHE_TITLES[$i]}|${PARSE_CACHE_YEARS[$i]}"
            return 0
        fi
        ((i++))
    done
    
    echo ""
    return 1
}

# ═══════════════════════════════════════════════════════════════════════════════
# TV SHOW CACHE FUNCTIONS
# ═══════════════════════════════════════════════════════════════════════════════

# TV Show cache format: title|year|imdb|tmdb|tvdb|timestamp
get_cached_tvshow() {
    local title="$1"
    local year="$2"
    should_debug high && print_info "[DEBUG] get_cached_tvshow: ENTER title='$title' year='$year' cache_file='$TV_CACHE_FILE'" >&2
    
    if [[ -f "$TV_CACHE_FILE" ]]; then
        local result=""
        # Normalize search title: convert dashes/underscores to spaces, remove trailing punctuation
        local norm_title=$(echo "$title" | sed 's/[-_]/ /g; s/[?!:.,;]*$//; s/  */ /g')
        
        if [[ -n "$year" ]]; then
            # Try with fully normalized titles (dashes/underscores to spaces, case-insensitive)
            result=$(awk -F'|' -v title="$norm_title" -v year="$year" '{
                cache_title = $1
                search_title = title
                # Normalize both: convert separators to spaces, remove punctuation, collapse spaces
                gsub(/[-_]/, " ", cache_title)
                gsub(/[?!:.,;]*$/, "", cache_title)
                gsub(/[[:space:]]+/, " ", cache_title)
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", cache_title)
                gsub(/[[:space:]]+/, " ", search_title)
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", search_title)
                if (tolower(cache_title) == tolower(search_title) && $2 == year) {print; exit}
            }' "$TV_CACHE_FILE" 2>/dev/null)
        else
            # Try with fully normalized titles (no year filter)
            result=$(awk -F'|' -v title="$norm_title" '{
                cache_title = $1
                search_title = title
                gsub(/[-_]/, " ", cache_title)
                gsub(/[?!:.,;]*$/, "", cache_title)
                gsub(/[[:space:]]+/, " ", cache_title)
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", cache_title)
                gsub(/[[:space:]]+/, " ", search_title)
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", search_title)
                if (tolower(cache_title) == tolower(search_title)) {print; exit}
            }' "$TV_CACHE_FILE" 2>/dev/null)
        fi
        should_debug high && print_info "[DEBUG] get_cached_tvshow: RETURN result='${result:-NOT_FOUND}'" >&2
        echo "$result"
    else
        should_debug high && print_info "[DEBUG] get_cached_tvshow: RETURN (no cache file)" >&2
    fi
}

save_tvshow_to_cache() {
    local title="$1"
    local year="$2"
    local imdb="$3"
    local tmdb="$4"
    local tvdb="$5"
    local timestamp=$(date +%s)
    should_debug high && print_info "[DEBUG] save_tvshow_to_cache: ENTER title='$title' year='$year' imdb='$imdb' tmdb='$tmdb' tvdb='$tvdb'" >&2
    
    # Simple lock mechanism using mkdir (atomic operation on all systems)
    local lockdir="${TV_CACHE_FILE}.lock"
    local max_wait=10
    local waited=0
    
    # Try to acquire lock (mkdir is atomic)
    while ! mkdir "$lockdir" 2>/dev/null; do
        sleep 0.1
        waited=$((waited + 1))
        if [[ $waited -ge $((max_wait * 10)) ]]; then
            # Timeout - remove stale lock and try once more
            rmdir "$lockdir" 2>/dev/null
            mkdir "$lockdir" 2>/dev/null || return 1
            break
        fi
    done
    
    # Check if entry already exists (match by title and year, or by IDs) - case insensitive
    if [[ -f "$TV_CACHE_FILE" ]]; then
        local existing_entry=""
        if [[ -n "$year" ]]; then
            # Check by title and year (case-insensitive)
            existing_entry=$(awk -F'|' -v title="$title" -v year="$year" 'tolower($1) == tolower(title) && $2 == year {print; exit}' "$TV_CACHE_FILE" 2>/dev/null)
        else
            # Check by title only (case-insensitive)
            existing_entry=$(awk -F'|' -v title="$title" 'tolower($1) == tolower(title) && $2 == "" {print; exit}' "$TV_CACHE_FILE" 2>/dev/null)
        fi
        
        # Also check if IMDb ID already exists (avoid duplicate IDs with different title spelling)
        if [[ -z "$existing_entry" ]] && [[ -n "$imdb" ]]; then
            existing_entry=$(awk -F'|' -v imdb="$imdb" '$3 == imdb {print; exit}' "$TV_CACHE_FILE" 2>/dev/null)
        fi
        
        # Also check if TMDb ID already exists (avoid duplicate IDs)
        if [[ -z "$existing_entry" ]] && [[ -n "$tmdb" ]]; then
            existing_entry=$(awk -F'|' -v tmdb="$tmdb" '$4 == tmdb {print; exit}' "$TV_CACHE_FILE" 2>/dev/null)
        fi
        
        # If entry exists, don't add duplicate
        if [[ -n "$existing_entry" ]]; then
            should_debug high && print_info "[DEBUG] TV show already in cache: $title"
            rmdir "$lockdir" 2>/dev/null
            return 0
        fi
    fi
    
    # Add new entry - ensure newline at end of file first
    [[ -f "$TV_CACHE_FILE" ]] && [[ -n "$(tail -c 1 "$TV_CACHE_FILE" 2>/dev/null)" ]] && echo "" >> "$TV_CACHE_FILE"
    echo "${title}|${year}|${imdb}|${tmdb}|${tvdb}|${timestamp}" >> "$TV_CACHE_FILE"
    [[ "$DEBUG_MODE_TV" == "true" ]] && print_info "Saved TV show to cache: $title ($year)"
    
    # Release lock
    rmdir "$lockdir" 2>/dev/null
}

extract_from_tv_cache() {
    local cache_line="$1"
    local field="$2"
    should_debug high && print_info "[DEBUG] extract_from_tv_cache: field='$field' line='${cache_line:0:60}...'" >&2
    case "$field" in
        imdb) echo "$cache_line" | cut -d'|' -f3 ;;
        tmdb) echo "$cache_line" | cut -d'|' -f4 ;;
        tvdb) echo "$cache_line" | cut -d'|' -f5 ;;
    esac
}

# ═══════════════════════════════════════════════════════════════════════════════
# TV EPISODE CACHE FUNCTIONS
# ═══════════════════════════════════════════════════════════════════════════════

# Episode cache format: Season|Episode|Episode Title|Air Date|IMDb ID|TMDb ID|TVDb ID|Timestamp
# Cache file per series: ~/.movie_simulator/SHOWS TV/episodes/Series_Name_tt1234567.txt

get_episode_cache_file() {
    local series_name="$1"
    local series_imdb="$2"
    local category="${3:-tv}"  # tv, anime, or cartoon
    should_debug high && print_info "[DEBUG] get_episode_cache_file: ENTER series='$series_name' imdb='$series_imdb' category='$category'" >&2
    
    # Sanitize series name for filename (remove problematic chars, keep unicode letters, replace spaces with underscores)
    # Remove: / \ : * ? " < > | but keep unicode letters like Æ, é, etc.
    local safe_name=$(echo "$series_name" | sed 's/[\/\\:*?"<>|]//g' | tr ' ' '_')
    
    # Determine cache directory based on category
    local cache_dir="$TV_EPISODE_CACHE_DIR"
    case "$category" in
        anime) cache_dir="$ANIME_EPISODE_CACHE_DIR" ;;
        cartoon) cache_dir="$CARTOON_EPISODE_CACHE_DIR" ;;
    esac
    
    # Return cache file path: Category/episodes/Series_Name_tt1234567.txt
    echo "${cache_dir}/${safe_name}_${series_imdb}.txt"
}

get_cached_episode() {
    local cache_file="$1"
    local season="$2"
    local episode="$3"
    should_debug high && print_info "[DEBUG] get_cached_episode: ENTER file='$cache_file' S${season}E${episode}" >&2
    
    [[ ! -f "$cache_file" ]] && { should_debug high && print_info "[DEBUG] get_cached_episode: file not found" >&2; return 1; }
    
    local result=$(awk -F'|' -v s="$season" -v e="$episode" '$1 == s && $2 == e {print; exit}' "$cache_file" 2>/dev/null)
    should_debug high && print_info "[DEBUG] get_cached_episode: RETURN '${result:-NOT_FOUND}'" >&2
    echo "$result"
}

save_episode_to_cache() {
    local cache_file="$1"
    local season="$2"
    local episode="$3"
    local episode_title="$4"
    local air_date="$5"
    local imdb_id="$6"
    local tmdb_id="$7"
    local tvdb_id="$8"
    local timestamp=$(date +%s)
    should_debug high && print_info "[DEBUG] save_episode_to_cache: ENTER cache='$cache_file' S${season}E${episode} title='$episode_title'" >&2
    
    # Create cache file parent directory if needed
    mkdir -p "$(dirname "$cache_file")"
    
    # Simple lock mechanism
    local lockfile="${cache_file}.lock"
    local max_wait=10
    local waited=0
    
    while [[ -f "$lockfile" ]]; do
        sleep 0.1
        waited=$((waited + 1))
        if [[ $waited -ge $((max_wait * 10)) ]]; then
            rm -f "$lockfile" 2>/dev/null
            break
        fi
    done
    
    touch "$lockfile"
    
    # Check if episode already cached
    if [[ -f "$cache_file" ]]; then
        local existing=$(awk -F'|' -v s="$season" -v e="$episode" '$1 == s && $2 == e {print; exit}' "$cache_file" 2>/dev/null)
        if [[ -n "$existing" ]]; then
            rm -f "$lockfile"
            return 0
        fi
    fi
    
    # Add new episode entry
    [[ -f "$cache_file" ]] && [[ -n "$(tail -c 1 "$cache_file" 2>/dev/null)" ]] && echo "" >> "$cache_file"
    echo "${season}|${episode}|${episode_title}|${air_date}|${imdb_id}|${tmdb_id}|${tvdb_id}|${timestamp}" >> "$cache_file"
    
    rm -f "$lockfile"
}

extract_from_episode_cache() {
    local cache_line="$1"
    local field="$2"
    should_debug high && print_info "[DEBUG] extract_from_episode_cache: field='$field' line='${cache_line:0:50}...'" >&2
    
    case "$field" in
        season) echo "$cache_line" | cut -d'|' -f1 ;;
        episode) echo "$cache_line" | cut -d'|' -f2 ;;
        title) echo "$cache_line" | cut -d'|' -f3 ;;
        air_date) echo "$cache_line" | cut -d'|' -f4 ;;
        imdb) echo "$cache_line" | cut -d'|' -f5 ;;
        tmdb) echo "$cache_line" | cut -d'|' -f6 ;;
        tvdb) echo "$cache_line" | cut -d'|' -f7 ;;
        timestamp) echo "$cache_line" | cut -d'|' -f8 ;;
        *) echo "" ;;
    esac
}

# ═══════════════════════════════════════════════════════════════════════════════
# TV SHOW DETECTION AND PARSING
# ═══════════════════════════════════════════════════════════════════════════════

# Detect if file is a TV show episode
is_tv_episode() {
    local filename="$1"
    should_debug high && print_info "[DEBUG] is_tv_episode: ENTER filename='$(basename "$filename")'" >&2
    
    # Skip movies in Specials folders (e.g., X-Files movies with S00E01/S00E02 that are actually movies)
    # Check if file is in a Specials folder with a subdirectory (indicating it's a movie)
    if [[ "$filename" =~ /[Ss]pecials/[^/]+/[^/]+$ ]]; then
        should_debug high && print_info "[DEBUG] is_tv_episode: RETURN 1 (movie in Specials subfolder rejected)" >&2
        return 1  # Reject files that are in Specials/MovieTitle/ structure
    fi
    
    # ALWAYS reject files in extras folders - they should be handled by extras processing, not episode processing
    # This prevents files like "Featurettes/S01E02 - Preview.mkv" from being treated as episodes
    if [[ "$filename" =~ /[Ee]xtra(s)?/ ]] || \
       [[ "$filename" =~ /[Dd]eleted[[:space:]][Ss]cene(s)?/ ]] || \
       [[ "$filename" =~ /[Bb]ehind[[:space:]][Tt]he[[:space:]][Ss]cene(s)?/ ]] || \
       [[ "$filename" =~ /[Ff]eaturette(s)?/ ]] || \
       [[ "$filename" =~ /[Ii]nterview(s)?/ ]] || \
       [[ "$filename" =~ /[Bb]onus(es)?/ ]] || \
       [[ "$filename" =~ /[Tt]railer(s)?/ ]] || \
       [[ "$filename" =~ /[Ss]ample(s)?/ ]] || \
       [[ "$filename" =~ /[Cc]lip(s)?/ ]] || \
       [[ "$filename" =~ /[Ss]hort(s)?/ ]] || \
       [[ "$filename" =~ /[Ss]cene(s)?/ ]] || \
       [[ "$filename" =~ /[Oo]ther/ ]]; then
        should_debug high && print_info "[DEBUG] is_tv_episode: RETURN 1 (file in extras folder rejected)" >&2
        return 1  # Reject files in extras folders regardless of HARDLINK_EXTRAS setting
    fi
    
    # If extras linking is disabled, also check if filename itself contains extras-related keywords
    if [[ "$HARDLINK_EXTRAS" == "false" ]]; then
        # Check if filename itself contains extras-related keywords
        # Use specific patterns to avoid false positives (e.g., "Extra C" in episode titles)
        local basename=$(basename "$filename")
        if [[ "$basename" =~ [[:space:]][Ee]xtra[[:space:]]*$ ]] || \
           [[ "$basename" =~ [[:space:]][Ee]xtra[[:space:]]*- ]] || \
           [[ "$basename" =~ -[[:space:]]*[Ee]xtra[[:space:]]*- ]] || \
           [[ "$basename" =~ ^[Ee]xtra[[:space:]]- ]] || \
           [[ "$basename" =~ [Dd]eleted[[:space:]][Ss]cene ]] || \
           [[ "$basename" =~ [Bb]ehind[[:space:]][Tt]he[[:space:]][Ss]cene ]] || \
           [[ "$basename" =~ [Ff]eaturette ]] || \
           [[ "$basename" =~ [Ii]nterview ]] || \
           [[ "$basename" =~ [[:space:]][Bb]onus([[:space:]]|$) ]] || \
           [[ "$basename" =~ -[Bb]onus([[:space:]]|-|$) ]] || \
           [[ "$basename" =~ [Tt]railer ]] || \
           [[ "$basename" =~ [Ss]ample ]] || \
           [[ "$basename" =~ [[:space:]][Cc]lip([[:space:]]|$) ]]; then
            should_debug high && print_info "[DEBUG] is_tv_episode: RETURN 1 (extras file rejected)" >&2
            return 1  # Reject extras files
        fi
    fi
    
    # Match patterns: S01E01, S01 E01, S01-E01, s01e01, 1x01, Season 1 Episode 1, S1, Ep1, EP01, Ep. 25, E01
    # Accept ANY file with episode pattern - deduplication will prevent double-processing
    if [[ "$filename" =~ [Ss]([0-9]{1,2})[^0-9]*[Ee]([0-9]{1,3}) ]]; then
        should_debug high && print_info "[DEBUG] is_tv_episode: RETURN 0 (matched SxxExx pattern)" >&2
        return 0
    fi
    if [[ "$filename" =~ [Ss]([0-9]{1,2})[[:space:]]*,[[:space:]]*[Ee][Pp]([0-9]{1,3}) ]]; then
        should_debug high && print_info "[DEBUG] is_tv_episode: RETURN 0 (matched Sxx,Epxx pattern)" >&2
        return 0
    fi
    if [[ "$filename" =~ [Ee][Pp]([0-9]{2,3}) ]]; then
        should_debug high && print_info "[DEBUG] is_tv_episode: RETURN 0 (matched Epxx pattern)" >&2
        return 0
    fi
    if [[ "$filename" =~ [[:space:]][Ee]([0-9]{2,3})[[:space:]] ]]; then
        should_debug high && print_info "[DEBUG] is_tv_episode: RETURN 0 (matched space-Exx-space pattern)" >&2
        return 0
    fi
    if [[ "$filename" =~ ([0-9]{1,2})x([0-9]{1,3}) ]]; then
        should_debug high && print_info "[DEBUG] is_tv_episode: RETURN 0 (matched NxNN pattern)" >&2
        return 0
    fi
    if [[ "$filename" =~ [Ss]eason[[:space:]]([0-9]{1,2})[[:space:]][Ee]pisode[[:space:]]([0-9]{1,3}) ]]; then
        should_debug high && print_info "[DEBUG] is_tv_episode: RETURN 0 (matched 'Season X Episode X' pattern)" >&2
        return 0
    fi
    if [[ "$filename" =~ [[:space:]]([1-9])([0-9]{2})[[:space:]] ]]; then
        should_debug high && print_info "[DEBUG] is_tv_episode: RETURN 0 (matched NNN season+ep pattern)" >&2
        return 0
    fi
    
    # Pattern: Files in "Season ##" folders that start with just a number (e.g., "01 Episode Title.mkv")
    # Check if parent folder is a season folder
    local parent_folder=$(basename "$(dirname "$filename")")
    if [[ "$parent_folder" =~ ^[Ss]eason[[:space:]]?[0-9]{1,2} ]]; then
        local basename=$(basename "$filename")
        # Check if filename starts with 1-3 digit number followed by space or separator
        if [[ "$basename" =~ ^([0-9]{1,3})[[:space:]._-] ]]; then
            should_debug high && print_info "[DEBUG] is_tv_episode: RETURN 0 (file in Season folder with number prefix)" >&2
            return 0  # Episode number at start of filename in season folder
        fi
    fi
    
    # Anime patterns - only when TV_NAMING_EPISODE is set to "2" (Anime mode)
    if [[ "${TV_NAMING_EPISODE:-0}" == "2" ]]; then
        # Anime format: " - 01", " 01 Episode Title", "Title 01.mkv"
        if [[ "$filename" =~ [[:space:]][-—][[:space:]]?([0-9]{1,3})[[:space:]]*(\.|$) ]] || \
           [[ "$filename" =~ [[:space:]]([0-9]{1,3})[[:space:]]*\. ]] || \
           [[ "$filename" =~ [[:space:]]([0-9]{1,3})[[:space:]]+[^0-9] ]]; then
            should_debug high && print_info "[DEBUG] is_tv_episode: RETURN 0 (matched anime pattern)" >&2
            return 0  # Has anime episode pattern
        fi
    fi
    
    should_debug high && print_info "[DEBUG] is_tv_episode: RETURN 1 (no pattern matched)" >&2
    return 1  # Not an episode
}

# Parse series title and year from a folder name (called once per batch)
# Simple extraction: Get the series name and year, stop there
# TMDb lookup will handle finding the canonical name
parse_series_folder_name() {
    local folder_name="$1"
    should_debug high && print_info "[DEBUG] parse_series_folder_name: folder_name='$folder_name'" >&2
    
    # ═══════════════════════════════════════════════════════════════════════════════
    # PREPROCESSING: Strip release group tags BEFORE main parsing
    # Common patterns: [GroupName-ID], [M-KV####], {GroupName}, (GroupName), etc.
    # These tags often contain numbers that get misidentified as years
    # ═══════════════════════════════════════════════════════════════════════════════
    
    # Strip leading group tags with hyphens/codes at the START of the string
    # Patterns: [M-KV2501], [Group-ID], [ABC-1234], etc.
    # Match: Start of string + bracket + alphanumeric + hyphen + alphanumeric + bracket
    folder_name=$(echo "$folder_name" | sed -E 's/^\[[-A-Za-z0-9]+\][[:space:]]*//')
    
    # Strip leading numbered tags that look like release IDs: [01], [02], etc.
    # But only at the START after removing group tag (to avoid removing season numbers)
    folder_name=$(echo "$folder_name" | sed -E 's/^\[[0-9]{1,2}\][[:space:]]*//')
    
    # Strip leading curly brace tags: {GroupName}, {M-KV2501}, etc.
    folder_name=$(echo "$folder_name" | sed -E 's/^\{[^}]+\}[[:space:]]*//')
    
    # Strip trailing group/quality tags in brackets: [DVDRemux], [BluRay], [WEB-DL], etc.
    # But preserve year tags like [2020] - only remove if it contains letters or hyphens
    folder_name=$(echo "$folder_name" | sed -E 's/[[:space:]]*\[[A-Za-z][A-Za-z0-9-]*\][[:space:]]*$//')
    
    should_debug high && print_info "[DEBUG] parse_series_folder_name: after tag stripping='$folder_name'" >&2
    
    # Reset output variables
    FOLDER_SERIES_TITLE=""
    FOLDER_SERIES_YEAR=""
    FOLDER_TMDB_HINT=""
    FOLDER_IMDB_HINT=""
    FOLDER_TVDB_HINT=""
    FOLDER_IMDB_HINT=""
    FOLDER_TVDB_HINT=""
    
    # Preserve initials like "R.L." "S.W.A.T." by temporarily replacing them
    # Only match TRUE initials: single letters at word boundaries followed by dots
    # Pattern must match things like "R.L." or "S.W.A.T." but NOT "with.a.Plan"
    # Key: initials have a dot AFTER each letter AND the previous char is space/start/dot
    local temp_title="$folder_name"
    
    # First pass: Preserve known initials patterns at START or after space
    # Match: start-of-string or space, then 2+ single-letter-dot sequences
    temp_title=$(echo "$temp_title" | sed -E 's/(^|[[:space:]])([A-Za-z])\.([A-Za-z])\./\1\2@@\3@@/g')
    temp_title=$(echo "$temp_title" | sed -E 's/(^|[[:space:]])([A-Za-z])\.([A-Za-z])\./\1\2@@\3@@/g')  # Run twice for 3+ letter initials
    temp_title=$(echo "$temp_title" | sed -E 's/(^|[[:space:]])([A-Za-z])\.([A-Za-z])\./\1\2@@\3@@/g')  # Run third time for 4+ letter initials
    
    # CRITICAL: Preserve year ranges with dashes BEFORE dash->space conversion
    # Convert dashes in year ranges to placeholder ~~ so they survive the sed 's/[._-]/ /g' below
    # This prevents "(1996-2017)" from becoming "(1996 2017)" which wouldn't match year range patterns
    temp_title=$(echo "$temp_title" | sed -E 's/\(([0-9]{4})-([0-9]{2,4})\)/(\1~~\2)/g')
    temp_title=$(echo "$temp_title" | sed -E 's/\[([0-9]{4})-([0-9]{2,4})\]/[\1~~\2]/g')
    temp_title=$(echo "$temp_title" | sed -E 's/([[:space:]])([0-9]{4})-([0-9]{2,4})([[:space:]]|$)/\1\2~~\3\4/g')
    
    # CRITICAL: Extract ID hints BEFORE dash-to-space conversion
    # Otherwise {tmdb-82782} becomes {tmdb 82782} and doesn't match the extraction pattern
    
    # Extract {tmdb-XXXXX} hint if present
    if [[ "$temp_title" =~ \{tmdb-([0-9]+)\} ]]; then
        FOLDER_TMDB_HINT="${BASH_REMATCH[1]}"
        temp_title=$(echo "$temp_title" | sed -E 's/[[:space:]]*\{tmdb-[^}]+\}[[:space:]]*//')
    fi
    
    # Extract {imdb-ttXXXXXXX} or [imdb-ttXXXXXXX] hint if present
    if [[ "$temp_title" =~ \{imdb-(tt[0-9]+)\} ]]; then
        FOLDER_IMDB_HINT="${BASH_REMATCH[1]}"
        temp_title=$(echo "$temp_title" | sed -E 's/[[:space:]]*\{imdb-[^}]+\}[[:space:]]*//')
    elif [[ "$temp_title" =~ \[imdb-(tt[0-9]+)\] ]]; then
        FOLDER_IMDB_HINT="${BASH_REMATCH[1]}"
        temp_title=$(echo "$temp_title" | sed -E 's/[[:space:]]*\[imdb-[^]]+\][[:space:]]*//')
    fi
    
    # Extract {tvdb-XXXXX} or [tvdb-XXXXX] hint if present
    if [[ "$temp_title" =~ \{tvdb-([0-9]+)\} ]]; then
        FOLDER_TVDB_HINT="${BASH_REMATCH[1]}"
        temp_title=$(echo "$temp_title" | sed -E 's/[[:space:]]*\{tvdb-[^}]+\}[[:space:]]*//')
    elif [[ "$temp_title" =~ \[tvdb-([0-9]+)\] ]]; then
        FOLDER_TVDB_HINT="${BASH_REMATCH[1]}"
        temp_title=$(echo "$temp_title" | sed -E 's/[[:space:]]*\[tvdb-[^]]+\][[:space:]]*//')
    fi
    
    # Convert remaining dots/underscores/dashes to spaces
    temp_title=$(echo "$temp_title" | sed 's/[._-]/ /g')
    
    # Restore year range dashes (convert ~~ back to -)
    temp_title=$(echo "$temp_title" | sed 's/~~/\-/g')
    
    # Add space before parentheses/brackets containing years (handles "Plan(2016)" -> "Plan (2016)")
    temp_title=$(echo "$temp_title" | sed -E 's/([A-Za-z])\(([0-9]{4})/\1 (\2/g')
    temp_title=$(echo "$temp_title" | sed -E 's/([A-Za-z])\[([0-9]{4})/\1 [\2/g')
    
    # Restore initials (convert @@ back to .)
    temp_title=$(echo "$temp_title" | sed 's/@@/./g')
    
    # Clean up multiple spaces
    temp_title=$(echo "$temp_title" | sed 's/  */ /g' | sed 's/^ //;s/ $//')
    
    # Pre-clean: Remove season/quality info BEFORE year extraction
    # Strip everything from "season"/"seasons" onwards (handles all season patterns)
    temp_title=$(echo "$temp_title" | sed -E 's/[[:space:]]+(S|s)easons?([[:space:]]|$).*//I')
    # Strip "-episodes" or " episodes" suffix (common in folder names)
    temp_title=$(echo "$temp_title" | sed -E 's/[[:space:]]*-?[[:space:]]*(episodes?|series|shows?)$//I')
    # Strip everything from S01/S1/S 01/S 1 onwards (catches REPACK, quality tags, etc.)
    temp_title=$(echo "$temp_title" | sed -E 's/[[:space:]]+[Ss][[:space:]]*[0-9]{1,2}[[:space:]].*//')
    temp_title=$(echo "$temp_title" | sed -E 's/[[:space:]]+[Ss][[:space:]]*[0-9]{1,2}$//')
    # Strip anime/media type suffixes: (TV), (OVA), (ONA), (Movie), (Special)
    temp_title=$(echo "$temp_title" | sed -E 's/[[:space:]]*\((TV|OVA|ONA|Movie|Special|Specials)\)[[:space:]]*$//i')
    temp_title=$(echo "$temp_title" | sed 's/  */ /g' | sed 's/^ //;s/ $//')
    
    # Strategy: Find the FIRST year (1900-2099) and extract title before it
    # Year can be: (2020), [2020], 2020, or year range like 1992-1997, (2018-2021)
    
    # Try full date range in parentheses: "Show (2005-08-06 to 2006-02-18)" or "Show (2005-08-06 to 2006-02-18) Extra Info"
    if [[ "$temp_title" =~ ^(.+)[[:space:]]+\(([0-9]{4})-[0-9]{2}-[0-9]{2}[[:space:]]+(to|through|-)[[:space:]]+[0-9]{4}-[0-9]{2}-[0-9]{2}\) ]]; then
        FOLDER_SERIES_TITLE="${BASH_REMATCH[1]}"
        local found_year="${BASH_REMATCH[2]}"
        [[ "$found_year" -ge 1900 && "$found_year" -le 2099 ]] && FOLDER_SERIES_YEAR="$found_year"
    # Try year in parentheses first: "Martin (1992)" or "Show (2018-2021)"
    elif [[ "$temp_title" =~ ^(.+)[[:space:]]+\(([0-9]{4})(-[0-9]{2,4})?\) ]]; then
        FOLDER_SERIES_TITLE="${BASH_REMATCH[1]}"
        local found_year="${BASH_REMATCH[2]}"
        [[ "$found_year" -ge 1900 && "$found_year" -le 2099 ]] && FOLDER_SERIES_YEAR="$found_year"
    # Try year range in parentheses: "Show (1990-1998)" or "Show (1990-1998) Complete Series" - extract everything before the opening parenthesis
    elif [[ "$temp_title" =~ ^(.+)[[:space:]]+\(([0-9]{4})-[0-9]{2,4}\) ]]; then
        FOLDER_SERIES_TITLE="${BASH_REMATCH[1]}"
        local found_year="${BASH_REMATCH[2]}"
        [[ "$found_year" -ge 1900 && "$found_year" -le 2099 ]] && FOLDER_SERIES_YEAR="$found_year"
    # Try year in brackets: "Show [2020]"
    elif [[ "$temp_title" =~ ^(.+)[[:space:]]+\[([0-9]{4})(-[0-9]{2,4})?\] ]]; then
        FOLDER_SERIES_TITLE="${BASH_REMATCH[1]}"
        local found_year="${BASH_REMATCH[2]}"
        [[ "$found_year" -ge 1900 && "$found_year" -le 2099 ]] && FOLDER_SERIES_YEAR="$found_year"
    # Try standalone year range: "Martin 1992-1997"
    elif [[ "$temp_title" =~ ^(.+)[[:space:]]+([0-9]{4})-[0-9]{2,4}([[:space:]]|$) ]]; then
        FOLDER_SERIES_TITLE="${BASH_REMATCH[1]}"
        local found_year="${BASH_REMATCH[2]}"
        [[ "$found_year" -ge 1900 && "$found_year" -le 2099 ]] && FOLDER_SERIES_YEAR="$found_year"
    # Try standalone year: "Show 2020" (but not at start - "1923" is a show title)
    elif [[ "$temp_title" =~ ^(.+[^0-9])[[:space:]]+([0-9]{4})([[:space:]]|$) ]]; then
        FOLDER_SERIES_TITLE="${BASH_REMATCH[1]}"
        local found_year="${BASH_REMATCH[2]}"
        [[ "$found_year" -ge 1900 && "$found_year" -le 2099 ]] && FOLDER_SERIES_YEAR="$found_year"
    # Try year-titled show with second year: "1923 2022" -> title="1923", year="2022"
    elif [[ "$temp_title" =~ ^([0-9]{4})[[:space:]]+([0-9]{4})([[:space:]]|$) ]]; then
        FOLDER_SERIES_TITLE="${BASH_REMATCH[1]}"
        local found_year="${BASH_REMATCH[2]}"
        [[ "$found_year" -ge 1900 && "$found_year" -le 2099 ]] && FOLDER_SERIES_YEAR="$found_year"
    # No year found - use everything up to first quality/season indicator
    else
        # Remove common suffixes: S01, Season 1, 1080p, etc.
        FOLDER_SERIES_TITLE=$(echo "$temp_title" | sed -E 's/[[:space:]]+(S[0-9]{1,2}|Season[[:space:]]*[0-9]+|[0-9]{3,4}p|COMPLETE|BluRay|WEB|HDTV|DVDRip).*//I')
    fi
    
    # Clean up title - remove resolution/quality tags and language info
    # Remove patterns like: 1920x1080, 1280x720, 720p, English, Dubbed, Subbed, etc.
    FOLDER_SERIES_TITLE=$(echo "$FOLDER_SERIES_TITLE" | sed -E 's/[[:space:]]+[0-9]{3,4}x[0-9]{3,4}[[:space:]]*.*$//' | sed -E 's/[[:space:]]+(English|Japanese|Dubbed|Subbed|Sub|Dub).*$//')
    
    # Remove common filler phrases that appear after the title
    # Patterns: "Complete Animated TV Series", "Complete Series", "The Complete Series", etc.
    FOLDER_SERIES_TITLE=$(echo "$FOLDER_SERIES_TITLE" | sed -E 's/[[:space:]]+(The[[:space:]]+)?Complete[[:space:]]+(Animated[[:space:]]+)?(TV[[:space:]]+)?Series.*$//' | sed -E 's/[[:space:]]+(The[[:space:]]+)?Series.*$//')
    
    # Remove "and YEAR Movie" type suffixes (e.g., "and 2005 Movie")
    FOLDER_SERIES_TITLE=$(echo "$FOLDER_SERIES_TITLE" | sed -E 's/[[:space:]]+and[[:space:]]+[0-9]{4}[[:space:]]+(Movie|Film|Special).*$//')
    
    # Extract the base title (text before parenthesis) to check if it's too short
    local base_title=$(echo "$FOLDER_SERIES_TITLE" | sed -E 's/[[:space:]]*\([^)]*\)[[:space:]]*$//')
    
    # If base title is very short (<=10 chars) and parenthetical contains "Animated Series", preserve it
    if [[ ${#base_title} -le 10 ]] && [[ "$FOLDER_SERIES_TITLE" =~ \(.*Animated[[:space:]]Series.*\) ]]; then
        # Extract "Animated Series" from parenthetical and append to base title
        FOLDER_SERIES_TITLE="$base_title The Animated Series"
    else
        # Remove descriptive parenthetical content: (Complete...), (cartoon...), (in MP4 format), etc.
        FOLDER_SERIES_TITLE=$(echo "$FOLDER_SERIES_TITLE" | sed -E 's/[[:space:]]*\((Complete|cartoon|TV[[:space:]]series|in[[:space:]][^)]+format|MP4|MKV|AVI)[^)]*\)[[:space:]]*$//')
    fi
    
    # Clean up title - remove trailing punctuation and dashes
    FOLDER_SERIES_TITLE=$(echo "$FOLDER_SERIES_TITLE" | sed 's/  */ /g' | sed 's/^ //;s/ $//' | sed -E 's/[[:space:]]*[-–—,\.:]+[[:space:]]*$//')
    
    # Validate: If result is just a season pattern, return empty
    if [[ "$FOLDER_SERIES_TITLE" =~ ^[Ss]eason[[:space:]]?[0-9]+$ ]] || [[ "$FOLDER_SERIES_TITLE" =~ ^[Ss][0-9]{1,2}$ ]] || [[ -z "$FOLDER_SERIES_TITLE" ]]; then
        FOLDER_SERIES_TITLE=""
        should_debug high && print_info "[DEBUG] parse_series_folder_name: Result is season-only or empty, returning blank" >&2
    fi
    
    should_debug high && print_info "[DEBUG] parse_series_folder_name: result title='$FOLDER_SERIES_TITLE' year='$FOLDER_SERIES_YEAR'" >&2
}

# Parse TV episode information from filename
parse_tv_episode() {
    local filename="$1"
    should_debug high && print_info "[DEBUG] parse_tv_episode: filename='$filename'" >&2
    local basename=$(basename "$filename")
    
    # Reset parsed TV variables
    TV_SERIES_TITLE=""
    TV_YEAR=""
    TV_SEASON=""
    TV_EPISODE=""
    TV_EPISODE_END=""
    TV_EPISODE_TITLE=""
    TV_ABSOLUTE=""
    TV_AIR_DATE=""
    
    # Extract air date for daily shows (YYYY-MM-DD or YYYY.MM.DD)
    if [[ "$basename" =~ ([0-9]{4})[-.]([0-9]{2})[-.]([0-9]{2}) ]]; then
        TV_AIR_DATE="${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}"
    fi
    
    # Extract season and episode - support multiple patterns
    # Pattern 1: S01E01 or S01E01-E03 (multi-episode) - require E before end episode
    if [[ "$basename" =~ [Ss]([0-9]{1,2})[^0-9]*[Ee]([0-9]{1,3})(-[Ee]([0-9]{1,3}))? ]]; then
        TV_SEASON="${BASH_REMATCH[1]}"
        TV_EPISODE="${BASH_REMATCH[2]}"
        [[ -n "${BASH_REMATCH[4]}" ]] && TV_EPISODE_END="${BASH_REMATCH[4]}"
    # Pattern 2: S1, Ep1 format (season with comma, then episode)
    elif [[ "$basename" =~ [Ss]([0-9]{1,2})[[:space:]]*,[[:space:]]*[Ee][Pp]([0-9]{1,3}) ]]; then
        TV_SEASON="${BASH_REMATCH[1]}"
        TV_EPISODE="${BASH_REMATCH[2]}"
    # Pattern 3: EP01, EP001 format (often used for anime/cartoons)
    # Simple pattern matching EP anywhere in filename with 2-3 digits
    elif [[ "$basename" =~ [Ee][Pp]([0-9]{2,3}) ]]; then
        TV_SEASON="1"
        TV_EPISODE="${BASH_REMATCH[1]}"
    # Pattern 3a: "Origins E##" or "Specials E##" format - treat as Season 0 (Specials)
    # Must come before Pattern 3b to catch these special episodes first
    elif [[ "$basename" =~ [Oo]rigins[[:space:]][Ee]([0-9]{2,3}) ]] || \
         [[ "$basename" =~ [Ss]pecials?[[:space:]][Ee]([0-9]{2,3}) ]]; then
        TV_SEASON="0"
        TV_EPISODE="${BASH_REMATCH[1]}"
    # Pattern 3b: " E## " format (space-E-digits-space, e.g., "Friday... E03 (Title).mp4")
    elif [[ "$basename" =~ [[:space:]][Ee]([0-9]{2,3})[[:space:]] ]]; then
        TV_SEASON="1"
        TV_EPISODE="${BASH_REMATCH[1]}"
    # Pattern 4: 1x01 or 1x01-03 format (multi-episode with x format)
    elif [[ "$basename" =~ ([0-9]{1,2})x([0-9]{1,3})(-([0-9]{1,3}))? ]]; then
        TV_SEASON="${BASH_REMATCH[1]}"
        TV_EPISODE="${BASH_REMATCH[2]}"
        [[ -n "${BASH_REMATCH[4]}" ]] && TV_EPISODE_END="${BASH_REMATCH[4]}"
    # Pattern 5: Season 1 Episode 1 format
    elif [[ "$basename" =~ [Ss]eason[[:space:]]([0-9]{1,2})[[:space:]][Ee]pisode[[:space:]]([0-9]{1,3}) ]]; then
        TV_SEASON="${BASH_REMATCH[1]}"
        TV_EPISODE="${BASH_REMATCH[2]}"
    # Pattern 6: Anime format " - 09" or " 09." (match with dot after)
    elif [[ "$basename" =~ [[:space:]][-—][[:space:]]?([0-9]{1,3})[[:space:]]*\. ]] || [[ "$basename" =~ [[:space:]]([0-9]{1,3})[[:space:]]*\. ]]; then
        TV_SEASON="1"
        TV_EPISODE="${BASH_REMATCH[1]}"
    # Pattern 7: 3-digit combined season+episode format like "201" = S02E01 (e.g., "X-Men TAS 201 Title.avi")
    # Match 3 digits where first digit is 1-9 (season) and last 2 digits are episode
    # This must come BEFORE Pattern 8 (anime format) to avoid matching 301 as episode 301
    elif [[ "$basename" =~ [[:space:]]([1-9])([0-9]{2})[[:space:]] ]]; then
        TV_SEASON="${BASH_REMATCH[1]}"
        TV_EPISODE="${BASH_REMATCH[2]}"
    # Pattern 8: Anime format " 09 " with space and non-digit after (e.g., " 05 The Stranger")
    # Now restricted to 1-2 digit numbers to avoid conflicting with 3-digit season+episode format
    elif [[ "$basename" =~ [[:space:]]([0-9]{1,2})[[:space:]]+[^0-9] ]]; then
        TV_SEASON="1"
        TV_EPISODE="${BASH_REMATCH[1]}"
    # Pattern 9: Number at start of filename when in "Season ##" folder (e.g., "01 Episode Title.mkv" in "Season 1/")
    elif [[ "$basename" =~ ^([0-9]{1,3})[[:space:]._-] ]]; then
        # Try to extract season from parent folder
        local parent_folder=$(basename "$(dirname "$filename")")
        if [[ "$parent_folder" =~ [Ss]eason[[:space:]]?([0-9]{1,2}) ]]; then
            TV_SEASON="${BASH_REMATCH[1]}"
            TV_EPISODE="${BASH_REMATCH[1]}"  # Episode number from filename start
        elif [[ "$parent_folder" =~ ^[Ss]([0-9]{1,2})$ ]]; then
            TV_SEASON="${BASH_REMATCH[1]}"
            TV_EPISODE="${BASH_REMATCH[1]}"  # Episode number from filename start
        else
            # No season folder found, assume season 1
            TV_SEASON="1"
            TV_EPISODE="${BASH_REMATCH[1]}"
        fi
        # Re-extract episode number from basename (it got overwritten by season logic above)
        if [[ "$basename" =~ ^([0-9]{1,3})[[:space:]._-] ]]; then
            TV_EPISODE="${BASH_REMATCH[1]}"
        fi
    fi
    
    # Remove leading zeros for processing
    TV_SEASON=$((10#$TV_SEASON))
    TV_EPISODE=$((10#$TV_EPISODE))
    [[ -n "$TV_EPISODE_END" ]] && TV_EPISODE_END=$((10#$TV_EPISODE_END))
    
    # Extract absolute episode number (for anime) - pattern like "- 001 -" or "ep001"
    if [[ "$basename" =~ -[[:space:]]?([0-9]{3})[[:space:]]?- ]] || \
       [[ "$basename" =~ [Ee][Pp]([0-9]{2,3}) ]]; then
        TV_ABSOLUTE="${BASH_REMATCH[1]}"
        TV_ABSOLUTE=$((10#$TV_ABSOLUTE))
    fi
    
    # ═══════════════════════════════════════════════════════════════════════════════
    # SERIES TITLE EXTRACTION
    # Priority: 1) Batch-cached from folder (parsed once), 2) Season folder structure, 3) Filename
    # ═══════════════════════════════════════════════════════════════════════════════
    
    # Check if we have batch-cached series info (from folder name, parsed once)
    if [[ -n "$BATCH_SERIES_TITLE" && ! "$BATCH_SERIES_TITLE" =~ ^[Ss]pecials?$ ]]; then
        TV_SERIES_TITLE="$BATCH_SERIES_TITLE"
        TV_YEAR="$BATCH_SERIES_YEAR"
        should_debug high && print_info "[DEBUG] parse_tv_episode: Using batch-cached series info: '$TV_SERIES_TITLE' ($TV_YEAR)" >&2
    else
        # No batch info (or batch title is just 'Specials') - fall back to folder/filename parsing
        if [[ "$BATCH_SERIES_TITLE" =~ ^[Ss]pecials?$ ]]; then
            should_debug high && print_info "[DEBUG] parse_tv_episode: Rejecting batch title 'Specials', falling back to folder parsing" >&2
        fi
        # Extract series title from folder structure
        # Strategy: Look for "Season X" folder in path, then use its parent as series folder
        #           This is more efficient than parsing filenames or doing complex backtracking
    
        local temp_title="$basename"
    local series_folder_found=false
    
    # Get the full directory path
    local dir_path=$(dirname "$filename")
    
    # Check if we're in a season folder structure
    # Look for "Season X", "Season X (year)", "Season X (year-year)", "S01", etc. in the immediate parent
    local parent_folder=$(basename "$dir_path")
    
    # Check if parent folder is a season-only folder (no series name, just season info)
    # Match patterns like: "Season 1", "Season 3 (2019-20)", "Season 01 (2018)", "S01", "S1"
    # Key: If it STARTS with "Season" or "S" followed by number, it's a season folder
    # First, strip any year suffix like "(2019-20)" or "(2018)" to check the base pattern
    local parent_base=$(echo "$parent_folder" | sed -E 's/[[:space:]]*\([0-9]{4}(-[0-9]{2,4})?\)[[:space:]]*$//')
    if [[ "$parent_base" =~ ^[Ss]eason[[:space:]]?[0-9]+$ ]] || [[ "$parent_base" =~ ^[Ss][0-9]{1,2}$ ]]; then
        # We're in a season-only folder, get the series folder (grandparent)
        local series_folder=$(basename "$(dirname "$dir_path")")
        
        # Check if series_folder matches the container folder we're skipping
        local skip_folder_name=""
        [[ -n "$SKIP_SOURCE_FOLDER" ]] && skip_folder_name=$(basename "$SKIP_SOURCE_FOLDER")
        if [[ -n "$skip_folder_name" && "$series_folder" == "$skip_folder_name" ]]; then
            should_debug high && print_info "[DEBUG] parse_tv_episode: Skipping container folder '$series_folder' as series folder" >&2
            series_folder=""
        fi
        
        if [[ -n "$series_folder" && "$series_folder" != "." && "$series_folder" != "/" ]]; then
            temp_title="$series_folder"
            series_folder_found=true
            should_debug high && print_info "[DEBUG] parse_tv_episode: Found season folder ('$parent_folder'), using series folder: '$temp_title'" >&2
        fi
    fi
    
    # If we didn't find a series folder via season detection, use the filename
    if [[ "$series_folder_found" == "false" ]]; then
        should_debug high && print_info "[DEBUG] parse_tv_episode: No season folder found, extracting from filename" >&2
    fi
    
    # Remove file extension first
    temp_title="${temp_title%.*}"
    
    # If we got the title from a series folder, clean it up immediately
    if [[ "$series_folder_found" == "true" ]]; then
        # Convert dots/underscores to spaces
        temp_title=$(echo "$temp_title" | sed 's/[._]/ /g' | sed 's/  */ /g' | sed 's/^ //;s/ $//')
        
        # Strategy: Look for a 4-digit year (1900-2099) and extract it
        # The year is critical for disambiguating remakes (e.g., "Amazing Stories 1985" vs "Amazing Stories 2020")
        # Common patterns: "Show Name (2020)", "Show Name 2020", "Show.Name.2020", "Show Name (1995-2000)"
        
        # Look for year in parentheses or brackets first: (2020) or [2020]
        if [[ "$temp_title" =~ [[:space:]]*[\(\[]([0-9]{4})(-[0-9]{4})?[\)\]] ]]; then
            local found_year="${BASH_REMATCH[1]}"
            if [[ "$found_year" -ge 1900 && "$found_year" -le 2099 ]]; then
                TV_YEAR="$found_year"
                # Remove everything from the year onwards
                temp_title=$(echo "$temp_title" | sed -E "s/[[:space:]]*[\(\[]${found_year}.*//" | sed 's/  */ /g' | sed 's/^ //;s/ $//')
                should_debug high && print_info "[DEBUG] parse_tv_episode: Found year in parens/brackets '$TV_YEAR', title: '$temp_title'" >&2
            fi
        # Look for standalone year: "Show Name 2020" or "Show Name 2020 stuff"
        elif [[ "$temp_title" =~ [[:space:]]([0-9]{4})([[:space:]]|$) ]]; then
            local found_year="${BASH_REMATCH[1]}"
            if [[ "$found_year" -ge 1900 && "$found_year" -le 2099 ]]; then
                TV_YEAR="$found_year"
                # Remove everything from the year onwards
                temp_title=$(echo "$temp_title" | sed -E "s/[[:space:]]+${found_year}.*//" | sed 's/  */ /g' | sed 's/^ //;s/ $//')
                should_debug high && print_info "[DEBUG] parse_tv_episode: Found standalone year '$TV_YEAR', title: '$temp_title'" >&2
            fi
        fi
        
        # If no year found, still clean up common patterns
        if [[ -z "$TV_YEAR" ]]; then
            # Remove "seasons 01-09", "Complete", "S01-S02", etc. and everything after
            temp_title=$(echo "$temp_title" | sed -E 's/[[:space:]]+(seasons?|complete|tv series|s[0-9]{1,2}).*//I' | sed 's/  */ /g' | sed 's/^ //;s/ $//')
            should_debug high && print_info "[DEBUG] parse_tv_episode: No year found, removed season/quality tags, title: '$temp_title'" >&2
        fi
        
        should_debug high && print_info "[DEBUG] parse_tv_episode: Final - title='$temp_title' year='$TV_YEAR'" >&2
        # Set this as the series title directly and skip the filename parsing below
        TV_SERIES_TITLE="$temp_title"
    fi
    
    # Only do filename-based title extraction if we didn't already get it from series folder
    if [[ "$series_folder_found" == "false" ]]; then
        # Try to extract title by removing S##E## pattern (with flexible separator) and everything after it
        if [[ "$temp_title" =~ [Ss][0-9]{1,2}[^0-9]*[Ee][0-9]{1,3} ]]; then
        TV_SERIES_TITLE=$(echo "$temp_title" | sed -E 's/[[:space:]]*[-._—]*[[:space:]]*[Ss][0-9]{1,2}[^0-9]*[Ee][0-9]{1,3}.*//')
    # Try ##x## pattern (handle em-dash — and regular dash -)
    elif [[ "$temp_title" =~ [0-9]{1,2}x[0-9]{1,3} ]]; then
        TV_SERIES_TITLE=$(echo "$temp_title" | sed -E 's/[[:space:]]*[-._—]*[[:space:]]*[0-9]{1,2}x[0-9]{1,3}.*//')
    # Try EP## or EP### pattern (often used for anime)
    elif [[ "$temp_title" =~ [Ee][Pp][0-9]{2,3} ]]; then
        TV_SERIES_TITLE=$(echo "$temp_title" | sed -E 's/[[:space:]]*[-._—]*[[:space:]]*[Ee][Pp][0-9]{2,3}.*//')
    # Try " E## " pattern (space-E-digits-space, e.g., "Friday... E03 (Title)")
    elif [[ "$temp_title" =~ [[:space:]][Ee][0-9]{2,3}[[:space:]] ]]; then
        TV_SERIES_TITLE=$(echo "$temp_title" | sed -E 's/[[:space:]]+[Ee][0-9]{2,3}[[:space:]].*//')
    # Try "Season #-#" or "Season # to #" pattern (season ranges)
    elif [[ "$temp_title" =~ [Ss]eason[[:space:]]?[0-9]+-[0-9]+ ]] || [[ "$temp_title" =~ [Ss]eason[[:space:]]?[0-9]+[[:space:]]?to[[:space:]]?[0-9]+ ]]; then
        TV_SERIES_TITLE=$(echo "$temp_title" | sed -E 's/[[:space:]]*[-._—]*[[:space:]]*[Ss]eason[[:space:]]*[0-9]+.*//')
    # Try "Season # Episode #" or single "Season #" pattern
    elif [[ "$temp_title" =~ [Ss]eason[[:space:]]?[0-9]+ ]]; then
        TV_SERIES_TITLE=$(echo "$temp_title" | sed -E 's/[[:space:]]*[-._—]*[[:space:]]*[Ss]eason[[:space:]]*[0-9]+.*//')
    # Try S##-S## pattern (like "S01-S11")
    elif [[ "$temp_title" =~ [Ss][0-9]{1,2}-[Ss][0-9]{1,2} ]]; then
        TV_SERIES_TITLE=$(echo "$temp_title" | sed -E 's/[[:space:]]*[-._—]*[[:space:]]*[Ss][0-9]{1,2}-.*//')
    # Try S## without E## (like "Show Name S01" or "Legion.S02.2160p.HULU.WEBRip...")
    # This handles season pack folders with quality tags
    elif [[ "$temp_title" =~ [Ss][0-9]{1,2}[^Ee] ]] || [[ "$temp_title" =~ [Ss][0-9]{1,2}$ ]]; then
        # Extract just the title before S##
        TV_SERIES_TITLE=$(echo "$temp_title" | sed -E 's/[[:space:]]*[-._—]*[[:space:]]*[Ss][0-9]{1,2}.*//')
    # Try anime pattern " - ##" or " ## " at end before extension
    elif [[ "$temp_title" =~ [[:space:]][-—][[:space:]]?[0-9]{1,3}$ ]] || [[ "$temp_title" =~ [[:space:]][0-9]{1,3}$ ]]; then
        TV_SERIES_TITLE=$(echo "$temp_title" | sed -E 's/[[:space:]]*[-—]*[[:space:]]*[0-9]{1,3}$//')
    # Try anime pattern " ## Episode Title" in middle of filename
    elif [[ "$temp_title" =~ [[:space:]][0-9]{1,3}[[:space:]] ]]; then
        TV_SERIES_TITLE=$(echo "$temp_title" | sed -E 's/[[:space:]]+[0-9]{1,3}[[:space:]]+.*//')
        else
            # No episode pattern found, might be just a series folder
            TV_SERIES_TITLE="$temp_title"
        fi
        
        # Clean up trailing separators (em-dash, dash, underscore, dot, spaces)
        TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]—_.-]*$//')
        
        # Remove common TV folder suffixes like (TV), [TV], etc.
        TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]*[\[(][Tt][Vv][\])]$//')
        
        # Additional cleanup for season pack folders: remove quality/resolution tags
        # Patterns like "2160p", "1080p", "WEBRip", "WEBDL", group names, etc.
        if [[ -z "$TV_EPISODE" ]]; then
            # This is likely a season pack folder, clean up quality tags
            TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]*[-._]*(720p|1080p|2160p|4K|UHD|HDTV|WEB-?DL|WEB-?Rip|BluRay|BDRip|DVDRip|x264|x265|HEVC|H\.?264|H\.?265|AAC|AC3|DD5\.1|DTS|10bit|AMZN|NF|HULU|DSNP|HBO|ATVP).*//')
            TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed 's/  */ /g' | sed 's/^ //;s/ $//')
        fi
    fi
    
    # If we still don't have a title, try parent folder
    if [[ -z "$TV_SERIES_TITLE" ]] || [[ "$TV_SERIES_TITLE" =~ ^[[:space:]]*$ ]]; then
        TV_SERIES_TITLE=$(basename "$(dirname "$filename")")
        
        # Skip if this matches the container folder we're skipping
        local skip_folder_name=""
        [[ -n "$SKIP_SOURCE_FOLDER" ]] && skip_folder_name=$(basename "$SKIP_SOURCE_FOLDER")
        if [[ -n "$skip_folder_name" && "$TV_SERIES_TITLE" == "$skip_folder_name" ]]; then
            should_debug high && print_info "[DEBUG] parse_tv_episode: Skipping container folder name '$TV_SERIES_TITLE'" >&2
            TV_SERIES_TITLE=""
        fi
        
        # Special handling: If parent folder is "Specials" and we have Season 0, check grandparent
        if [[ "$TV_SERIES_TITLE" =~ ^[Ss]pecials?$ ]] && [[ "$TV_SEASON" == "0" ]]; then
            local grandparent=$(basename "$(dirname "$(dirname "$filename")")")
            should_debug high && print_info "[DEBUG] parse_tv_episode: Found 'Specials' folder for S00, grandparent='$grandparent'" >&2
            # Skip if grandparent matches the container folder
            if [[ -n "$skip_folder_name" && "$grandparent" == "$skip_folder_name" ]]; then
                should_debug high && print_info "[DEBUG] parse_tv_episode: Skipping container folder as grandparent '$grandparent'" >&2
                grandparent=""
            fi
            # Only use grandparent if it's not empty and not "." or the root
            if [[ -n "$grandparent" && "$grandparent" != "." && "$grandparent" != "/" ]]; then
                should_debug high && print_info "[DEBUG] parse_tv_episode: Using grandparent as series: '$grandparent'" >&2
                TV_SERIES_TITLE="$grandparent"
                # Clean up grandparent: remove quality tags, season ranges, etc.
                TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]*[-._]*[[:space:]]*[Ss]eason[[:space:]]*[0-9]+.*//')
                TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]*[-._]*[[:space:]]*[Ss][0-9]{1,2}-.*//')
                TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]*[-._]*(720p|1080p|2160p|4K|UHD|HDTV|WEB-?DL|WEB-?Rip|BluRay|BDRip|DVDRip|DVD|x264|x265|HEVC|H\.?264|H\.?265|AAC|AC3|DD5\.1|DTS|10bit|8bit|AMZN|NF|HULU|DSNP|HBO|ATVP|REPACK|PROPER).*//')
                should_debug high && print_info "[DEBUG] parse_tv_episode: Cleaned grandparent series title: '$TV_SERIES_TITLE'" >&2
            else
                should_debug high && print_info "[DEBUG] parse_tv_episode: Grandparent unusable, falling back to filename parsing" >&2
                TV_SERIES_TITLE=""  # Force fallback to filename parsing
            fi
        # Special handling: If parent folder is just "Season ##" or "S##", check grandparent
        elif [[ "$TV_SERIES_TITLE" =~ ^[Ss]eason[[:space:]]?[0-9]+$ ]] || [[ "$TV_SERIES_TITLE" =~ ^[Ss][0-9]{1,2}$ ]]; then
            local grandparent=$(basename "$(dirname "$(dirname "$filename")")")
            # Skip if grandparent matches the container folder
            if [[ -n "$skip_folder_name" && "$grandparent" == "$skip_folder_name" ]]; then
                should_debug high && print_info "[DEBUG] parse_tv_episode: Skipping container folder as grandparent '$grandparent'" >&2
                grandparent=""
            fi
            # Only use grandparent if it's not empty and not "." or the root
            if [[ -n "$grandparent" && "$grandparent" != "." && "$grandparent" != "/" ]]; then
                should_debug high && print_info "[DEBUG] parse_tv_episode: Parent folder is season-only ('$TV_SERIES_TITLE'), using grandparent: '$grandparent'" >&2
                TV_SERIES_TITLE="$grandparent"
                # First, convert dots/underscores to spaces for easier pattern matching
                TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed 's/[._]/ /g' | sed 's/  */ /g' | sed 's/^ //;s/ $//')
                # Clean up grandparent: remove season patterns (seasons 01-09, Season 1, S01-S02, etc.)
                TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]+(Seasons?|S)[[:space:]]*[0-9]{1,2}(-[0-9]{1,2})?[[:space:]]*.*//')
                # Remove "Complete Seasons" or "Seasons...Complete" patterns
                TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]+Complete[[:space:]]+Seasons?[[:space:]]+[0-9]+([[:space:]]*(and|to|-)[[:space:]]*[0-9]+)?[[:space:]]*//I')
                TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]+Seasons?[[:space:]]+[0-9]+([[:space:]]*(and|to|-)[[:space:]]*[0-9]+)?[[:space:]]+Complete[[:space:]]*//I')
                # Remove quality/resolution tags
                TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]+(720p|1080p|2160p|4K|UHD|HDTV|WEB DL|WEB Rip|WEBRip|BluRay|BDRip|DVDRip|DVD|x264|x265|HEVC|H 264|H 265|AAC|AC3|DD5 1|DTS|10bit|8bit|AMZN|NF|HULU|DSNP|HBO|ATVP|REPACK|PROPER).*//')
                TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed 's/  */ /g' | sed 's/^ //;s/ $//')
            fi
        fi
    fi
    fi  # End of else block (no BATCH_SERIES_TITLE)
    
    # Only do cleanup if we didn't use batch-cached info (batch info is already clean)
    if [[ -z "$BATCH_SERIES_TITLE" ]]; then
        # Clean up series title - convert dots/underscores to spaces
        TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed 's/[._]/ /g' | sed 's/  */ /g' | sed 's/^ //;s/ $//')
        # Clean up common abbreviation patterns like "V s" or "V.s" to "vs"
        TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/ V[. ]+s / vs /gi')
    
        # Remove release group tags in brackets at the end: [rartv], [TGx], [eztv.re], [i_c], [RiCK], etc.
        TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]*\[[^\]]*\][[:space:]]*$//')
        
        # Remove "Episodes" or "episodes" as it's commonly used as folder name not actual series name
        TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]+[Ee]pisodes[[:space:]]*$//')
        TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]+[Ee]pisodes[[:space:]]+//')
    
        # Strip everything from S01/S 01/S1 pattern onwards (catches all trailing junk like REPACK, quality, etc.)
        TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]+[Ss][[:space:]]*[0-9]{1,2}[[:space:]].*//')
        TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]+[Ss][[:space:]]*[0-9]{1,2}$//')
        
        # Remove season patterns that may have come from folder names (Season 02, S01-S02, seasons 01-09, etc.)
        # Also handles: "Season 1 to 5", "Season 1-5", "S01-S05", "seasons 01-09"
        TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]+(Seasons?)[[:space:]]*[0-9]{1,2}[[:space:]]*(to|and|-)[[:space:]]*[0-9]{1,2}[[:space:]]*.*//')
        TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]+(Seasons?)[[:space:]]*[0-9]{1,2}(-S?[0-9]{1,2})?[[:space:]]*.*//')
        TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed 's/  */ /g' | sed 's/^ //;s/ $//')
    
        # Remove "COMPLETE" and "COMPLETE SERIES" patterns
        TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]+COMPLETE[[:space:]]+SERIES[[:space:]]*//I')
        TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]+Complete[[:space:]]+Series[[:space:]]*//I')
        TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]+COMPLETE[[:space:]]*$//I')
    
        # Remove quality/resolution tags before year extraction (but NOT release groups - parse_filename will extract those)
        # Handles: 720p, 1080p, 2160p, 4K, WEB-DL, BluRay, x264, x265, etc.
        TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]+(Mp4|Mp3|MKV|AVI|ITA-ENG|ENG-HIN-KOREAN|MULTI)?[[:space:]]*(720p|1080p|2160p|480p|4K|UHD|HDTV|HDR|WEB-?DL|WEBRip|WEB|BluRay|BDRip|DVDRip|DVD|TVRip|HDTVRip|UPSCALED)[[:space:]]*.*//')
        TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]+(x264|x265|HEVC|H 264|H 265|H264|H265|AAC|AC3|DD5 1|DD2 0|DDP5 1|DTS|10bit|8bit|AMZN|NF|HULU|DSNP|HBO|ATVP|PCOK|PMTP|STAN|MAX|REPACK|PROPER|Dual|MULTI)[[:space:]]*.*//')
        TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed 's/  */ /g' | sed 's/^ //;s/ $//')
    
        # Remove common TV series indicators before year extraction (case insensitive)
        TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]+TV[[:space:]]+Series[[:space:]]*//I')
        TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]+Complete[[:space:]]+TV[[:space:]]+Series[[:space:]]*//I')
        TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]+TV[[:space:]]+series[[:space:]]*//I')
        # Remove "in MP4 format" or "in MKV format" etc.
        TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]+in[[:space:]]+(MP4|MKV|AVI)[[:space:]]+format[[:space:]]*//I')
        # Remove "Complete Seasons X-Y" or "Seasons X and Y Complete" patterns (both orders)
        TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]+Complete[[:space:]]+Seasons?[[:space:]]+[0-9]+([[:space:]]*(and|to|-)[[:space:]]*[0-9]+)?[[:space:]]*//I')
        TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]+Seasons?[[:space:]]+[0-9]+([[:space:]]*(and|to|-)[[:space:]]*[0-9]+)?[[:space:]]+Complete[[:space:]]*//I')
        # Remove trailing "- Complete" or "- Complete," patterns (from folder names like "SHOW (2018) - Complete TV Series, S01-S04")
        TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]*[-–—][[:space:]]*Complete[[:space:]]*,?[[:space:]]*$//I')
        # Remove "+ Extras" or "+ Specials" patterns
        TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]*\+[[:space:]]*(Extras|Specials)[[:space:]]*//I')
        # Remove trailing commas, dashes, parentheses fragments
        TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]*[-–—,\(]+[[:space:]]*$//')
        TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed 's/  */ /g' | sed 's/^ //;s/ $//')
    
        # Remove country codes like (US), (UK), (GB), etc.
        TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]*\([A-Z]{2,3}\)[[:space:]]*/ /g' | sed 's/  */ /g' | sed 's/^ //;s/ $//')
    
        # Remove (TV) tag often used in anime/TV show folder names
        TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]*\(TV\)[[:space:]]*$//I' | sed 's/  */ /g' | sed 's/^ //;s/ $//')
    
        # Remove {tmdb-XXXXX} or {imdb-ttXXXXXX} hints (we'll use them later but not in title)
        TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]*\{(tmdb|imdb|tvdb)-[^}]+\}[[:space:]]*//g' | sed 's/  */ /g' | sed 's/^ //;s/ $//')
    
        # Final cleanup - remove any trailing punctuation or fragments
        TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]*[-–—,\.:]+[[:space:]]*$//' | sed 's/  */ /g' | sed 's/^ //;s/ $//')
    
        should_debug high && print_info "[DEBUG] parse_tv_episode: After cleanup, title='$TV_SERIES_TITLE' season='$TV_SEASON' episode='$TV_EPISODE'" >&2
        
        # SAFEGUARD: Prevent "Specials" from being used as final series title
        # If we end up with just "Specials" as the title, fall back to filename parsing
        if [[ "$TV_SERIES_TITLE" =~ ^[Ss]pecials?$ ]]; then
            should_debug high && print_info "[DEBUG] parse_tv_episode: Rejecting 'Specials' as series title, falling back to filename" >&2
            TV_SERIES_TITLE=""
        fi
    fi  # End of cleanup block (skipped if BATCH_SERIES_TITLE was set)
    
    # FILENAME FALLBACK: If we don't have a series title, extract it from filename
    if [[ -z "$TV_SERIES_TITLE" ]]; then
        should_debug high && print_info "[DEBUG] parse_tv_episode: No series title from folder, parsing filename: '$basename'" >&2
        
        # Extract everything before the first season/episode pattern
        local temp_title="$basename"
        
        # Remove file extension
        temp_title="${temp_title%.*}"
        
        # Convert dots/underscores to spaces for easier parsing
        temp_title=$(echo "$temp_title" | sed 's/[._]/ /g' | sed 's/  */ /g')
        
        # Extract title by finding everything before the season/episode info
        # Look for patterns like: " - S01E01", " S01E01", " - Season 1", etc.
        if [[ "$temp_title" =~ ^(.+?)[[:space:]]*[-–—]*[[:space:]]*(S[0-9]{1,2}E[0-9]{1,3}|Season[[:space:]]*[0-9]+|[Ss][0-9]{1,2}[[:space:]]) ]]; then
            TV_SERIES_TITLE="${BASH_REMATCH[1]}"
        elif [[ "$temp_title" =~ ^(.+?)[[:space:]]*[-–—][[:space:]]*[0-9]{1,2}x[0-9]{1,3} ]]; then
            # Handle "Show - 1x01" format
            TV_SERIES_TITLE="${BASH_REMATCH[1]}"
        else
            # Fallback: try to extract everything before quality/year tags
            TV_SERIES_TITLE=$(echo "$temp_title" | sed -E 's/[[:space:]]+(720p|1080p|2160p|4K|UHD|HDTV|WEB|BluRay|x264|x265|HEVC|H\.?264|AAC|AC3|DTS|[0-9]{4}).*//')
        fi
        
        # Clean up the extracted title
        TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed 's/  */ /g' | sed 's/^ //;s/ $//')
        should_debug high && print_info "[DEBUG] parse_tv_episode: Extracted from filename: '$TV_SERIES_TITLE'" >&2
    fi
    
    # If we don't have a year yet and parent folder is "Season XX", check grandparent for year
    if [[ -z "$TV_YEAR" ]]; then
        local parent_folder=$(basename "$(dirname "$filename")")
        if [[ "$parent_folder" =~ ^[Ss]eason[[:space:]]?[0-9]+$ ]] || [[ "$parent_folder" =~ ^[Ss][0-9]{1,2}$ ]]; then
            local grandparent=$(basename "$(dirname "$(dirname "$filename")")")
            if [[ -n "$grandparent" && "$grandparent" != "." && "$grandparent" != "/" ]]; then
                should_debug high && print_info "[DEBUG] parse_tv_episode: Parent is season folder, checking grandparent for year: '$grandparent'" >&2
                # Try to extract year from grandparent folder name
                if [[ "$grandparent" =~ [[:space:]]([0-9]{4})[[:space:]] ]] || \
                   [[ "$grandparent" =~ ^([0-9]{4})[[:space:]] ]] || \
                   [[ "$grandparent" =~ [[:space:]]([0-9]{4})$ ]]; then
                    TV_YEAR="${BASH_REMATCH[1]}"
                    should_debug high && print_info "[DEBUG] parse_tv_episode: Extracted year '$TV_YEAR' from grandparent folder" >&2
                fi
            fi
        fi
    fi
    
    # Strip trailing year from title if not in brackets (e.g., "Mo 2022" -> "Mo")
    # This must happen BEFORE year extraction so the year can still be parsed
    # Match: title ending with space + 4-digit year (1900-2099)
    if [[ "$TV_SERIES_TITLE" =~ ^(.+)[[:space:]]+(19[0-9]{2}|20[0-9]{2})$ ]]; then
        local title_without_year="${BASH_REMATCH[1]}"
        local trailing_year="${BASH_REMATCH[2]}"
        should_debug high && print_info "[DEBUG] parse_tv_episode: Found trailing year '$trailing_year' in title '$TV_SERIES_TITLE'" >&2
        # Only strip if the title without year is not empty
        if [[ -n "$title_without_year" ]]; then
            TV_SERIES_TITLE="$title_without_year"
            # If we don't already have a year, use this one
            [[ -z "$TV_YEAR" ]] && TV_YEAR="$trailing_year"
            should_debug high && print_info "[DEBUG] parse_tv_episode: Stripped trailing year, new title='$TV_SERIES_TITLE' year='$TV_YEAR'" >&2
        fi
    fi
    
    # Extract year if present - handle year ranges (2018-2021) by taking first year
    # BUT: Don't extract if the entire title IS just a year (e.g., show "1923")
    # Special case: If title starts with a 4-digit number followed by another 4-digit number,
    # the first one is likely the show title (like "1923 2022") - extract the SECOND one as year
    if [[ "$TV_SERIES_TITLE" =~ ^([0-9]{4})[[:space:]]+([0-9]{4}) ]]; then
        # Title starts with year followed by another year (e.g., "1923 2022")
        local first_number="${BASH_REMATCH[1]}"
        local second_number="${BASH_REMATCH[2]}"
        should_debug high && print_info "[DEBUG] parse_tv_episode: Found two years - first='$first_number' second='$second_number'" >&2
        
        # Use the second number as the year, keep the first as part of title
        TV_YEAR="$second_number"
        TV_SERIES_TITLE="$first_number"
        should_debug high && print_info "[DEBUG] parse_tv_episode: Year-named show - title='$TV_SERIES_TITLE' year='$TV_YEAR'" >&2
    elif [[ "$TV_SERIES_TITLE" =~ \(?([0-9]{4})(-[0-9]{4})?\)? ]] || [[ "$TV_SERIES_TITLE" =~ \[?([0-9]{4})(-[0-9]{4})?\]? ]]; then
        local potential_year="${BASH_REMATCH[1]}"
        
        # Check if title is ONLY this year (show named with a year like "1923" or "1883")
        # Don't extract as year if the title is exactly the 4-digit number or if removing it leaves nothing
        if [[ "$TV_SERIES_TITLE" =~ ^[0-9]{4}$ ]] || [[ "$TV_SERIES_TITLE" == "$potential_year" ]]; then
            # Title IS the year - don't extract it, the actual year will come from TMDb
            should_debug high && print_info "[DEBUG] parse_tv_episode: Title is year-named show ('$TV_SERIES_TITLE'), not extracting as year" >&2
            TV_YEAR=""
        else
            # Check what's left after removing the year
            local title_without_year=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]*[\(\[]?[0-9]{4}(-[0-9]{4})?[\)\]]?[[:space:]]*/ /g' | sed 's/  */ /g' | sed 's/^ //;s/ $//')
            
            if [[ -z "$title_without_year" ]] || [[ "$title_without_year" =~ ^[[:space:]]*$ ]]; then
                # Removing year leaves nothing - keep it as the title
                should_debug high && print_info "[DEBUG] parse_tv_episode: Removing year would leave empty title, keeping as title" >&2
                TV_YEAR=""
            else
                # Normal case - extract year and remove it from title
                TV_YEAR="$potential_year"
                should_debug high && print_info "[DEBUG] parse_tv_episode: Extracted year=$TV_YEAR from title='$TV_SERIES_TITLE'" >&2
                
                # Store original title before removing year
                local title_before_year="$TV_SERIES_TITLE"
                
                # Remove year/year range from title - handle both bracketed and unbracketed years
                # First try parentheses: (1959) or (2018-2021)
                TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]*\([0-9]{4}(-[0-9]{4})?\)[[:space:]]*/ /g')
                # Then try square brackets: [1959] or [2018-2021]
                TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]*\[[0-9]{4}(-[0-9]{4})?\][[:space:]]*/ /g')
                # Finally try unbracketed years at end: "Show 2019" or "Show 2018-2021"
                TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]+[0-9]{4}(-[0-9]{4})?[[:space:]]*$//')
                # Final cleanup
                TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed 's/  */ /g' | sed 's/^ //;s/ $//')
                
                should_debug high && print_info "[DEBUG] parse_tv_episode: After removing year, title='$TV_SERIES_TITLE'" >&2
                
                # If title is now empty or just whitespace, restore from original and keep everything before year
                if [[ -z "$TV_SERIES_TITLE" ]] || [[ "$TV_SERIES_TITLE" =~ ^[[:space:]]*$ ]]; then
                    [[ "$DEBUG_MODE_TV" == "true" ]] && print_warning "[DEBUG] parse_tv_episode: Title empty after year removal, attempting recovery..." >&2
                    # Try to extract from the title_before_year by removing everything from year onward
                    TV_SERIES_TITLE=$(echo "$title_before_year" | sed -E 's/[[:space:]]*[\(\[]?[0-9]{4}(-[0-9]{4})?.*$//' | sed 's/  */ /g' | sed 's/^ //;s/ $//')
                    should_debug high && print_info "[DEBUG] parse_tv_episode: Recovered title='$TV_SERIES_TITLE'" >&2
                    # If still empty, try from basename
                    if [[ -z "$TV_SERIES_TITLE" ]] || [[ "$TV_SERIES_TITLE" =~ ^[[:space:]]*$ ]]; then
                        [[ "$DEBUG_MODE_TV" == "true" ]] && print_warning "[DEBUG] parse_tv_episode: Still empty, trying basename..." >&2
                        TV_SERIES_TITLE=$(basename "$filename")
                        TV_SERIES_TITLE=$(echo "$TV_SERIES_TITLE" | sed -E 's/[[:space:]]*[\(\[]?[0-9]{4}(-[0-9]{4})?.*$//' | sed 's/[._]/ /g' | sed 's/  */ /g' | sed 's/^ //;s/ $//')
                        should_debug high && print_info "[DEBUG] parse_tv_episode: Final title='$TV_SERIES_TITLE'" >&2
                    fi
                fi
            fi
        fi
    fi
    
    # Try to extract episode title (text after episode number, before quality tags)
    # Handle various formats: S01E01, 1x01, with separators (-, —, etc.)
    
    # First try: title in parentheses followed by separator and more title
    # Example: "1x00 (Pilot) — The Cemetery; Eyes; Escape Route"
    if [[ "$basename" =~ ([0-9]{1,2}x[0-9]{1,2}|[Ss][0-9]{1,2}[^0-9]*[Ee][0-9]{1,2})[[:space:]._-]*\(([^\)]+)\)[[:space:]._—-]+(.+)\.(mkv|mp4|avi|m4v) ]]; then
        # Combine parenthesized part and text after it
        TV_EPISODE_TITLE="${BASH_REMATCH[2]} — ${BASH_REMATCH[3]}"
        TV_EPISODE_TITLE=$(echo "$TV_EPISODE_TITLE" | sed 's/[._]/ /g' | sed 's/  */ /g' | sed 's/^ //;s/ $//')
        TV_EPISODE_TITLE=$(echo "$TV_EPISODE_TITLE" | sed -E 's/[[:space:]]*(720p|1080p|2160p|4K|HDTV|WEB-?DL|WEB-?Rip|BluRay|x264|x265|HEVC|AAC|AC3|DD5\.1|DTS).*//')
    # Second try: title in parentheses like "S01E04 (Episode Title)" or "1x04 (Title)"
    elif [[ "$basename" =~ ([0-9]{1,2}x[0-9]{1,2}|[Ss][0-9]{1,2}[^0-9]*[Ee][0-9]{1,2})[[:space:]._-]*\(([^\)]+)\) ]]; then
        TV_EPISODE_TITLE="${BASH_REMATCH[2]}"
        TV_EPISODE_TITLE=$(echo "$TV_EPISODE_TITLE" | sed 's/[._]/ /g' | sed 's/  */ /g' | sed 's/^ //;s/ $//')
    # Third try: title after separator with #x## format like "1x01 — Episode Title"
    elif [[ "$basename" =~ [0-9]{1,2}x[0-9]{1,2}[[:space:]._—-]+(.+)\.(mkv|mp4|avi|m4v) ]]; then
        TV_EPISODE_TITLE="${BASH_REMATCH[1]}"
        TV_EPISODE_TITLE=$(echo "$TV_EPISODE_TITLE" | sed 's/[._]/ /g' | sed 's/  */ /g' | sed 's/^ //;s/ $//')
        TV_EPISODE_TITLE=$(echo "$TV_EPISODE_TITLE" | sed -E 's/[[:space:]]*(720p|1080p|2160p|4K|HDTV|WEB-?DL|WEB-?Rip|BluRay|x264|x265|HEVC|AAC|AC3|DD5\.1|DTS).*//')
    # Fourth try: title after separator with S##E## format like "S01E01 - Episode Title"
    elif [[ "$basename" =~ [Ss][0-9]{1,2}[^0-9]*[Ee][0-9]{1,2}[[:space:]._—-]+(.+)\.(mkv|mp4|avi|m4v) ]]; then
        TV_EPISODE_TITLE="${BASH_REMATCH[1]}"
        TV_EPISODE_TITLE=$(echo "$TV_EPISODE_TITLE" | sed 's/[._]/ /g' | sed 's/  */ /g' | sed 's/^ //;s/ $//')
        TV_EPISODE_TITLE=$(echo "$TV_EPISODE_TITLE" | sed -E 's/[[:space:]]*(720p|1080p|2160p|4K|HDTV|WEB-?DL|WEB-?Rip|BluRay|x264|x265|HEVC|AAC|AC3|DD5\.1|DTS).*//')
    # Fifth try: standalone number at start (Pattern 8) like "27 Out Of The Past p1.mkv"
    elif [[ "$basename" =~ ^[0-9]{1,3}[[:space:]._-]+(.+)\.(mkv|mp4|avi|m4v)$ ]]; then
        TV_EPISODE_TITLE="${BASH_REMATCH[1]}"
        TV_EPISODE_TITLE=$(echo "$TV_EPISODE_TITLE" | sed 's/[._]/ /g' | sed 's/  */ /g' | sed 's/^ //;s/ $//')
        TV_EPISODE_TITLE=$(echo "$TV_EPISODE_TITLE" | sed -E 's/[[:space:]]*(720p|1080p|2160p|4K|HDTV|WEB-?DL|WEB-?Rip|BluRay|x264|x265|HEVC|AAC|AC3|DD5\.1|DTS).*//')
    # Sixth try: 3-digit combined format (Pattern 9) like "X-Men TAS 201 'Til Death.avi"
    elif [[ "$basename" =~ [[:space:]][1-9][0-9]{2}[[:space:]]+(.+)\.(mkv|mp4|avi|m4v)$ ]]; then
        TV_EPISODE_TITLE="${BASH_REMATCH[1]}"
        TV_EPISODE_TITLE=$(echo "$TV_EPISODE_TITLE" | sed 's/[._]/ /g' | sed 's/  */ /g' | sed 's/^ //;s/ $//')
        TV_EPISODE_TITLE=$(echo "$TV_EPISODE_TITLE" | sed -E 's/[[:space:]]*(720p|1080p|2160p|4K|HDTV|WEB-?DL|WEB-?Rip|BluRay|x264|x265|HEVC|AAC|AC3|DD5\.1|DTS).*//')
    # Seventh try: S#, Ep## format like "S4, Ep10 Bad Egg.avi"
    elif [[ "$basename" =~ [Ss][0-9]{1,2},[[:space:]]*[Ee][Pp][0-9]{1,3}[[:space:]]+(.+)\.(mkv|mp4|avi|m4v)$ ]]; then
        TV_EPISODE_TITLE="${BASH_REMATCH[1]}"
        TV_EPISODE_TITLE=$(echo "$TV_EPISODE_TITLE" | sed 's/[._]/ /g' | sed 's/  */ /g' | sed 's/^ //;s/ $//')
        TV_EPISODE_TITLE=$(echo "$TV_EPISODE_TITLE" | sed -E 's/[[:space:]]*(720p|1080p|2160p|4K|HDTV|WEB-?DL|WEB-?Rip|BluRay|x264|x265|HEVC|AAC|AC3|DD5\.1|DTS).*//')
    fi
    
    # Clean up: Remove quality information in parentheses from episode title
    # Patterns like "(480p - DVDRip)", "(1080p)", "(720p WEB-DL)", etc.
    if [[ -n "$TV_EPISODE_TITLE" ]]; then
        TV_EPISODE_TITLE=$(echo "$TV_EPISODE_TITLE" | sed -E 's/[[:space:]]*\([^)]*([0-9]{3,4}p|DVDRip|WEB-?DL|WEB-?Rip|BluRay|BRRip|HDTV)[^)]*\)[[:space:]]*$//')
        TV_EPISODE_TITLE=$(echo "$TV_EPISODE_TITLE" | sed 's/  */ /g' | sed 's/^ //;s/ $//')
    fi
    
    should_debug high && print_info "[DEBUG] parse_tv_episode: Extracted episode title='$TV_EPISODE_TITLE'" >&2
}

# Get runtime from video file using ffprobe
get_file_runtime() {
    local file="$1"
    
    # Check if ffprobe is available
    if ! command -v ffprobe &> /dev/null; then
        echo ""
        return 1
    fi
    
    # Get duration in seconds
    local duration=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$file" 2>/dev/null)
    
    if [[ -n "$duration" ]]; then
        # Convert to minutes and round
        local minutes=$(awk "BEGIN {printf \"%.0f\", $duration/60}")
        echo "$minutes"
        return 0
    fi
    
    echo ""
    return 1
}

# Get movie poster URL from TMDb API (much faster than scraping)
get_imdb_poster() {
    local imdb_id="$1"
    local tmdb_id="$2"  # Optional: if we already have TMDb ID
    
    if [[ -z "$imdb_id" && -z "$tmdb_id" ]]; then
        echo ""
        return 1
    fi
    
    # Check if poster already exists in cache (check both original and resized)
    if [[ -n "$imdb_id" ]]; then
        local cached_resized="$POSTER_CACHE_DIR/${imdb_id}_resized.jpg"
        local cached_original="$POSTER_CACHE_DIR/${imdb_id}.jpg"
        
        if [[ -f "$cached_resized" && -s "$cached_resized" ]]; then
            # Return a dummy URL since we already have the cached file
            # The cache_poster function will use the cached version
            echo "cached://${imdb_id}"
            return 0
        elif [[ -f "$cached_original" && -s "$cached_original" ]]; then
            echo "cached://${imdb_id}"
            return 0
        fi
    fi
    
    # Not in cache, fetch from TMDb API
    # If we don't have TMDb ID, find it from IMDb ID
    if [[ -z "$tmdb_id" && -n "$imdb_id" ]]; then
        local find_url="${TMDB_API_BASE}/find/${imdb_id}?api_key=${TMDB_API_KEY}&external_source=imdb_id"
        local result=$(curl -s "$find_url" 2>/dev/null)
        tmdb_id=$(echo "$result" | grep -oE '"id":[0-9]+' | head -1 | grep -oE '[0-9]+')
    fi
    
    if [[ -z "$tmdb_id" ]]; then
        return 1
    fi
    
    # Get movie details including poster path
    local movie_url="${TMDB_API_BASE}/movie/${tmdb_id}?api_key=${TMDB_API_KEY}"
    local result=$(curl -s --connect-timeout 10 --max-time 30 "$movie_url" 2>/dev/null)
    local poster_path=$(echo "$result" | grep -oE '"poster_path":"[^"]+' | sed 's/"poster_path":"//' | head -1)
    
    if [[ -n "$poster_path" ]]; then
        # TMDb image base URL (w500 = 500px width)
        local poster_url="https://image.tmdb.org/t/p/w500${poster_path}"
        echo "$poster_url"
        return 0
    fi
    
    return 1
}

# Cross-platform image resize function
# Usage: resize_image <input_file> <output_file> <max_dimension>
resize_image() {
    local input_file="$1"
    local output_file="$2"
    local max_size="${3:-1000}"  # Default to 1000px
    
    # Load user preference
    local preferred_resizer="auto"
    if [[ -f "${CACHE_DIR}/image_resizer.txt" ]]; then
        preferred_resizer=$(cat "${CACHE_DIR}/image_resizer.txt")
    fi
    
    # If user specified a particular tool, try it first
    if [[ "$preferred_resizer" != "auto" ]]; then
        case "$preferred_resizer" in
            sips)
                if command -v sips &> /dev/null; then
                    sips -Z "$max_size" "$input_file" --out "$output_file" &>/dev/null && return 0
                fi
                ;;
            vips)
                if command -v vipsthumbnail &> /dev/null; then
                    # vipsthumbnail requires special output format: output_dir/filename.jpg
                    local output_dir=$(dirname "$output_file")
                    local output_name=$(basename "$output_file")
                    vipsthumbnail "$input_file" -s "${max_size}x${max_size}" -o "${output_dir}/%s.jpg" &>/dev/null
                    # vipsthumbnail creates basename without extension + .jpg, so rename if needed
                    local input_base=$(basename "$input_file" .jpg)
                    [[ -f "${output_dir}/${input_base}.jpg" ]] && mv "${output_dir}/${input_base}.jpg" "$output_file" &>/dev/null && return 0
                fi
                ;;
        esac
        # If preferred tool failed, fall through to auto detection
    fi
    
    # Auto mode: try tools in order of preference (speed and availability)
    # 1. sips (macOS built-in, fast)
    if command -v sips &> /dev/null; then
        sips -Z "$max_size" "$input_file" --out "$output_file" &>/dev/null && return 0
    fi
    
    # 2. vipsthumbnail (fastest third-party, memory efficient)
    if command -v vipsthumbnail &> /dev/null; then
        local output_dir=$(dirname "$output_file")
        local input_base=$(basename "$input_file" .jpg)
        vipsthumbnail "$input_file" -s "${max_size}x${max_size}" -o "${output_dir}/%s.jpg" &>/dev/null
        [[ -f "${output_dir}/${input_base}.jpg" ]] && mv "${output_dir}/${input_base}.jpg" "$output_file" &>/dev/null && return 0
    fi
    
    # No resize tool available, copy original
    cp "$input_file" "$output_file" 2>/dev/null
    return $?
}

cache_poster() {
    local poster_url="$1"
    local imdb_id="$2"
    
    should_debug high && echo "[DEBUG] cache_poster called: poster_url='$poster_url' imdb_id='$imdb_id'" >&2
    
    if [[ -z "$poster_url" || -z "$imdb_id" ]]; then
        should_debug high && echo "[DEBUG] cache_poster: Empty poster_url or imdb_id, returning 1" >&2
        return 1
    fi
    
    # Store original IMDb ID with tt prefix for backwards compatibility
    local imdb_id_with_tt="$imdb_id"
    
    # Sanitize IMDb ID (remove 'tt' prefix if present)
    imdb_id="${imdb_id#tt}"
    should_debug high && echo "[DEBUG] cache_poster: Sanitized imdb_id='$imdb_id'" >&2
    
    # Check both with and without 'tt' prefix for backwards compatibility
    local cached_file="${POSTER_CACHE_DIR}/${imdb_id}.jpg"
    local resized_file="${POSTER_CACHE_DIR}/${imdb_id}_resized.jpg"
    local cached_file_with_tt="${POSTER_CACHE_DIR}/${imdb_id_with_tt}.jpg"
    local resized_file_with_tt="${POSTER_CACHE_DIR}/${imdb_id_with_tt}_resized.jpg"
    
    should_debug high && echo "[DEBUG] cache_poster: cached_file='$cached_file'" >&2
    should_debug high && echo "[DEBUG] cache_poster: resized_file='$resized_file'" >&2
    
    # If poster_url starts with "cached://", it means poster is already in cache
    if [[ "$poster_url" == cached://* ]]; then
        should_debug high && echo "[DEBUG] cache_poster: Detected cached:// URL" >&2
        
        # Check for resized version first (try both with and without tt prefix)
        if [[ -f "$resized_file" && -s "$resized_file" ]]; then
            should_debug high && echo "[DEBUG] cache_poster: Found resized file, returning: $resized_file" >&2
            echo "$resized_file"
            return 0
        elif [[ -f "$resized_file_with_tt" && -s "$resized_file_with_tt" ]]; then
            should_debug high && echo "[DEBUG] cache_poster: Found resized file with tt prefix, returning: $resized_file_with_tt" >&2
            echo "$resized_file_with_tt"
            return 0
        elif [[ -f "$cached_file" && -s "$cached_file" ]]; then
            should_debug high && echo "[DEBUG] cache_poster: Found original, attempting resize" >&2
            # Original exists, try to resize it
            if resize_image "$cached_file" "$resized_file" 1000; then
                should_debug high && echo "[DEBUG] cache_poster: Resize succeeded" >&2
                if [[ -f "$resized_file" && -s "$resized_file" ]]; then
                    should_debug high && echo "[DEBUG] cache_poster: Resized file exists, returning: $resized_file" >&2
                    echo "$resized_file"
                    return 0
                fi
            else
                should_debug high && echo "[DEBUG] cache_poster: Resize failed, using original" >&2
            fi
            # Use original if resize failed
            should_debug high && echo "[DEBUG] cache_poster: Returning original: $cached_file" >&2
            echo "$cached_file"
            return 0
        elif [[ -f "$cached_file_with_tt" && -s "$cached_file_with_tt" ]]; then
            should_debug high && echo "[DEBUG] cache_poster: Found original with tt prefix, attempting resize" >&2
            # Original exists with tt prefix, try to resize it
            if resize_image "$cached_file_with_tt" "$resized_file_with_tt" 1000; then
                should_debug high && echo "[DEBUG] cache_poster: Resize succeeded" >&2
                if [[ -f "$resized_file_with_tt" && -s "$resized_file_with_tt" ]]; then
                    should_debug high && echo "[DEBUG] cache_poster: Resized file exists, returning: $resized_file_with_tt" >&2
                    echo "$resized_file_with_tt"
                    return 0
                fi
            else
                should_debug high && echo "[DEBUG] cache_poster: Resize failed, using original" >&2
            fi
            # Use original if resize failed
            should_debug high && echo "[DEBUG] cache_poster: Returning original with tt: $cached_file_with_tt" >&2
            echo "$cached_file_with_tt"
            return 0
        fi
        should_debug high && echo "[DEBUG] cache_poster: No cached files found, returning 1" >&2
        return 1
    fi
    
    # If already cached and resized, return resized path
    if [[ -f "$resized_file" && -s "$resized_file" ]]; then
        echo "$resized_file"
        return 0
    fi
    
    # If original cached but not resized, resize it
    if [[ -f "$cached_file" && -s "$cached_file" ]]; then
        if resize_image "$cached_file" "$resized_file" 1000; then
            if [[ -f "$resized_file" && -s "$resized_file" ]]; then
                # Verify the resized file is valid (not empty or too small)
                local file_size=$(stat -f%z "$resized_file" 2>/dev/null || stat -c%s "$resized_file" 2>/dev/null)
                if [[ -n "$file_size" && "$file_size" -gt 1000 ]]; then
                    echo "$resized_file"
                    return 0
                fi
            fi
        fi
        # If resize failed, use original
        echo "$cached_file"
        return 0
    fi
    
    # Download and cache
    if curl -s --connect-timeout 10 --max-time 30 -o "$cached_file" "$poster_url" 2>/dev/null; then
        if [[ -f "$cached_file" && -s "$cached_file" ]]; then
            # Try to resize on download
            if resize_image "$cached_file" "$resized_file" 1000; then
                if [[ -f "$resized_file" && -s "$resized_file" ]]; then
                    echo "$resized_file"
                    return 0
                fi
            fi
            echo "$cached_file"
            return 0
        fi
    fi
    
    rm -f "$cached_file"
    return 1
}

# Display poster using imgcat (iTerm2), chafa, or kitty
show_poster() {
    local imdb_id="$1"
    local poster_url="$2"
    local width="${3:-30}"  # default width in characters
    local cache_dir="${4:-$POSTER_CACHE_DIR}"  # Use provided cache dir or default to movie cache
    
    should_debug high && echo "[DEBUG] show_poster called: imdb_id=$imdb_id, poster_url=$poster_url, width=$width" >&2
    
    # Skip if images are disabled
    if [[ "$DISABLE_IMAGES" == "true" ]]; then
        should_debug high && echo "[DEBUG] Images disabled (DISABLE_IMAGES=true)" >&2
        return 1
    fi
    
    if [[ -z "$poster_url" ]]; then
        should_debug high && echo "[DEBUG] Empty poster_url, returning" >&2
        return 1
    fi
    
    # Try to use cached poster, or download and cache it
    local poster_file=""
    if [[ -n "$imdb_id" ]]; then
        poster_file=$(cache_poster "$poster_url" "$imdb_id" "$cache_dir")
        should_debug high && echo "[DEBUG] cache_poster returned: '$poster_file'" >&2
    fi
    
    # If no cached file, use temp file
    if [[ -z "$poster_file" || ! -f "$poster_file" ]]; then
        poster_file="/tmp/movie_poster_$$.jpg"
        curl -s --connect-timeout 10 --max-time 30 -o "$poster_file" "$poster_url" 2>/dev/null
    fi
    
    if [[ ! -f "$poster_file" || ! -s "$poster_file" ]]; then
        [[ "$poster_file" == /tmp/* ]] && rm -f "$poster_file"
        return 1
    fi
    
    # Try different terminal image protocols
    local display_success=0
    if command -v imgcat &> /dev/null; then
        # iTerm2 imgcat - with error output for debugging
        local imgcat_output=$(imgcat --width "$width" "$poster_file" 2>&1)
        local imgcat_exit=$?
        if [[ $imgcat_exit -eq 0 ]]; then
            echo "$imgcat_output"
            display_success=1
        else
            # imgcat failed, show debug info
            echo -e "${DIM}(imgcat failed - poster may be too large: $(du -h "$poster_file" 2>/dev/null | cut -f1))${NC}" >&2
        fi
    elif command -v chafa &> /dev/null; then
        # chafa for most terminals
        if chafa -s "${width}x40" "$poster_file" 2>/dev/null; then
            display_success=1
        fi
    elif command -v kitty &> /dev/null && [[ -n "$KITTY_WINDOW_ID" ]]; then
        # Kitty terminal
        if kitty +kitten icat --align left "$poster_file" 2>/dev/null; then
            display_success=1
        fi
    fi
    
    # Clean up temp file if used
    [[ "$poster_file" == /tmp/* ]] && rm -f "$poster_file"
    
    [[ $display_success -eq 1 ]] && return 0 || return 1
}

# Normalize title for fuzzy matching - handles number/word variations
normalize_title_fuzzy() {
    local title="$1"
    
    # Convert to lowercase and remove special chars
    title=$(echo "$title" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9 ]//g')
    
    # Remove all spaces first for easier pattern matching
    local title_nospace=$(echo "$title" | sed 's/ //g')
    
    # Handle specific year-title conversions (normalize both forms to the same string)
    # This ensures "1984" and "Nineteen Eighty-Four" both normalize to "1984"
    if [[ "$title_nospace" == "1984" ]]; then
        echo "1984"
        return 0
    elif [[ "$title_nospace" =~ ^nineteen.*eighty.*four$ ]]; then
        echo "1984"
        return 0
    elif [[ "$title_nospace" == "2001" ]]; then
        echo "2001"
        return 0
    elif [[ "$title_nospace" =~ ^two.*thousand.*one$ ]]; then
        echo "2001"
        return 0
    elif [[ "$title_nospace" == "2010" ]]; then
        echo "2010"
        return 0
    elif [[ "$title_nospace" =~ ^two.*thousand.*ten$ ]]; then
        echo "2010"
        return 0
    fi
    
    # Convert common numbers to words and words to numbers for flexible matching
    title=$(echo "$title" | sed 's/\b1\b/one/g; s/\bone\b/1/g')
    title=$(echo "$title" | sed 's/\b2\b/two/g; s/\btwo\b/2/g')
    title=$(echo "$title" | sed 's/\b3\b/three/g; s/\bthree\b/3/g')
    title=$(echo "$title" | sed 's/\b4\b/four/g; s/\bfour\b/4/g')
    title=$(echo "$title" | sed 's/\b5\b/five/g; s/\bfive\b/5/g')
    title=$(echo "$title" | sed 's/\b6\b/six/g; s/\bsix\b/6/g')
    title=$(echo "$title" | sed 's/\b7\b/seven/g; s/\bseven\b/7/g')
    title=$(echo "$title" | sed 's/\b8\b/eight/g; s/\beight\b/8/g')
    title=$(echo "$title" | sed 's/\b9\b/nine/g; s/\bnine\b/9/g')
    title=$(echo "$title" | sed 's/\b10\b/ten/g; s/\bten\b/10/g')
    title=$(echo "$title" | sed 's/\b11\b/eleven/g; s/\beleven\b/11/g')
    title=$(echo "$title" | sed 's/\b12\b/twelve/g; s/\btwelve\b/12/g')
    title=$(echo "$title" | sed 's/\b13\b/thirteen/g; s/\bthirteen\b/13/g')
    
    # Remove all spaces for final comparison
    title=$(echo "$title" | sed 's/ //g')
    
    echo "$title"
}

# Get movie title from IMDb page
get_imdb_title() {
    local imdb_id="$1"
    
    if [[ -z "$imdb_id" ]]; then
        echo ""
        return 1
    fi
    
    local url="https://www.imdb.com/title/${imdb_id}/"
    local page=$(curl -s -A "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36" "$url" 2>/dev/null)
    
    # Try to extract title from JSON-LD data - get the name field
    local title=$(echo "$page" | grep -oE '"name":"[^"]*"' | head -1 | sed 's/"name":"//;s/"//')
    
    if [[ -n "$title" ]]; then
        echo "$title"
        return 0
    fi
    
    echo ""
    return 1
}

# Get runtime from IMDb page
get_imdb_runtime() {
    local imdb_id="$1"
    
    if [[ -z "$imdb_id" ]]; then
        echo ""
        return 1
    fi
    
    local url="https://www.imdb.com/title/${imdb_id}/"
    local page=$(curl -s -A "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36" "$url" 2>/dev/null)
    
    should_debug high && echo "[DEBUG] [get_imdb_runtime] Fetching runtime for ${imdb_id}" >&2
    
    # Try multiple extraction methods in order of reliability
    local runtime=""
    
    # Method 1: JSON-LD duration format PT1H53M or PT113M
    if [[ -z "$runtime" ]]; then
        local duration=$(echo "$page" | grep -oE '"duration":"PT[0-9HM]+"' | head -1 | grep -oE 'PT[0-9HM]+')
        if [[ -n "$duration" ]]; then
            # Extract hours and minutes from PT1H53M format
            local hours=$(echo "$duration" | grep -oE '[0-9]+H' | grep -oE '[0-9]+')
            local mins=$(echo "$duration" | grep -oE '[0-9]+M' | grep -oE '[0-9]+')
            if [[ -n "$hours" && -n "$mins" ]]; then
                runtime=$((hours * 60 + mins))
            elif [[ -n "$mins" ]]; then
                # Only minutes specified (PT113M)
                runtime=$mins
            fi
        fi
    fi
    
    # Method 2: Look for "1h 53m" or "1 h 53 m" format in page text
    if [[ -z "$runtime" ]]; then
        # More flexible pattern that handles various spacing
        local time_str=$(echo "$page" | grep -oE '[0-9]+\s*(h|hr|hour)\s*[0-9]+\s*(m|min)' | head -1)
        if [[ -n "$time_str" ]]; then
            local hours=$(echo "$time_str" | grep -oE '[0-9]+' | head -1)
            local mins=$(echo "$time_str" | grep -oE '[0-9]+' | tail -1)
            if [[ -n "$hours" && -n "$mins" && "$hours" != "$mins" ]]; then
                runtime=$((hours * 60 + mins))
            fi
        fi
    fi
    
    # Method 3: Try to find in <time> or data-testid tags (modern IMDb)
    if [[ -z "$runtime" ]]; then
        # Look for time duration in various formats
        local time_content=$(echo "$page" | grep -oE 'runtime[^>]*>[^<]*</[^>]*>' | head -1)
        if [[ -n "$time_content" ]]; then
            # Extract "1h 53m" from HTML content
            local hours=$(echo "$time_content" | grep -oE '[0-9]+h' | grep -oE '[0-9]+')
            local mins=$(echo "$time_content" | grep -oE '[0-9]+m' | grep -oE '[0-9]+')
            if [[ -n "$hours" && -n "$mins" ]]; then
                runtime=$((hours * 60 + mins))
            fi
        fi
    fi
    
    # Method 4: Simple "XX min" or "XXX min" format
    if [[ -z "$runtime" ]]; then
        runtime=$(echo "$page" | grep -oE '[0-9]{2,3}\s*min' | grep -oE '[0-9]+' | head -1)
    fi
    
    # Sanity check: feature films should be at least 40 minutes
    # If we got a suspiciously short runtime, it's probably bad data
    if [[ -n "$runtime" && "$runtime" -lt 40 ]]; then
        should_debug high && echo "[DEBUG] [get_imdb_runtime] Ignoring suspicious runtime: ${runtime} min (too short for feature film)" >&2
        runtime=""
    fi
    
    if [[ -n "$runtime" ]]; then
        should_debug high && echo "[DEBUG] [get_imdb_runtime] Extracted runtime: ${runtime} min" >&2
        echo "$runtime"
        return 0
    fi
    
    should_debug high && echo "[DEBUG] [get_imdb_runtime] Failed to extract runtime from page" >&2
    echo ""
    return 1
}

# Get video bitrate in kbps (returns integer)
get_video_bitrate() {
    local file_path="$1"
    
    if [[ ! -f "$file_path" ]]; then
        echo "0"
        return 1
    fi
    
    # Check if disabled
    if [[ "$MEDIAINFO_TOOL" == "off" ]]; then
        echo "0"
        return 1
    fi
    
    local bitrate=""
    
    # Try mediainfo first
    if command -v mediainfo &> /dev/null; then
        bitrate=$(mediainfo --Output='General;%OverallBitRate%' "$file_path" 2>/dev/null | head -1 | tr -d ' ')
    elif command -v ffprobe &> /dev/null; then
        bitrate=$(ffprobe -v error -select_streams v:0 -show_entries format=bit_rate -of default=noprint_wrappers=1:nokey=1 "$file_path" 2>/dev/null | head -1 | tr -d ' ')
    fi
    
    # Convert to kbps and return
    if [[ -n "$bitrate" && "$bitrate" =~ ^[0-9]+$ ]]; then
        echo $((bitrate / 1000))
        return 0
    else
        echo "0"
        return 1
    fi
}

# Format bytes into human-readable size (KB, MB, GB, TB)
format_bytes() {
    local bytes="$1"
    
    if [[ ! "$bytes" =~ ^[0-9]+$ ]] || [[ $bytes -eq 0 ]]; then
        echo "0 B"
        return
    fi
    
    if [[ $bytes -ge 1099511627776 ]]; then
        # TB
        local tb=$((bytes / 1099511627776))
        local gb=$(((bytes % 1099511627776) / 1073741824))
        printf "%d.%03d TB" "$tb" "$gb"
    elif [[ $bytes -ge 1073741824 ]]; then
        # GB
        local gb=$((bytes / 1073741824))
        local mb=$(((bytes % 1073741824) / 10485760))  # Divide by 10MB for 2 decimal places
        printf "%.2f GB" "$(echo "scale=2; $bytes / 1073741824" | bc)"
    elif [[ $bytes -ge 1048576 ]]; then
        # MB
        local mb=$((bytes / 1048576))
        printf "%d MB" "$mb"
    elif [[ $bytes -ge 1024 ]]; then
        # KB
        local kb=$((bytes / 1024))
        printf "%d KB" "$kb"
    else
        # Bytes
        printf "%d B" "$bytes"
    fi
}

# Format bitrate (in kbps) into human-readable rate (KB/s, MB/s, GB/s)
format_bitrate() {
    local kbps="$1"
    
    if [[ ! "$kbps" =~ ^[0-9]+$ ]] || [[ $kbps -eq 0 ]]; then
        echo "0 KB/s"
        return
    fi
    
    # Convert kbps to bytes per second (kbps * 1000 / 8)
    local bytes_per_sec=$((kbps * 125))
    
    if [[ $bytes_per_sec -ge 1073741824 ]]; then
        # GB/s
        printf "%.2f GB/s" "$(echo "scale=2; $bytes_per_sec / 1073741824" | bc)"
    elif [[ $bytes_per_sec -ge 1048576 ]]; then
        # MB/s
        printf "%.2f MB/s" "$(echo "scale=2; $bytes_per_sec / 1048576" | bc)"
    elif [[ $bytes_per_sec -ge 1024 ]]; then
        # KB/s
        local kbs=$((bytes_per_sec / 1024))
        printf "%d KB/s" "$kbs"
    else
        # B/s
        printf "%d B/s" "$bytes_per_sec"
    fi
}

# Get video resolution height in pixels (returns integer like 2160, 1080, 720, etc.)
get_video_resolution_height() {
    local file_path="$1"
    
    if [[ ! -f "$file_path" ]]; then
        echo "0"
        return 1
    fi
    
    # Check if disabled
    if [[ "$MEDIAINFO_TOOL" == "off" ]]; then
        echo "0"
        return 1
    fi
    
    local height=""
    
    # Try mediainfo first
    if command -v mediainfo &> /dev/null; then
        height=$(mediainfo --Output='Video;%Height%' "$file_path" 2>/dev/null | head -1 | tr -d ' ')
    elif command -v ffprobe &> /dev/null; then
        height=$(ffprobe -v error -select_streams v:0 -show_entries stream=height -of default=noprint_wrappers=1:nokey=1 "$file_path" 2>/dev/null | head -1 | tr -d ' ')
    fi
    
    # Return height as integer or 0 if not found
    if [[ -n "$height" && "$height" =~ ^[0-9]+$ ]]; then
        echo "$height"
        return 0
    else
        echo "0"
        return 1
    fi
}

# Get resolution label from video file (e.g., "1080p", "720p", "4K")
get_resolution() {
    local file_path="$1"
    
    # Quick check if file exists
    [[ ! -f "$file_path" ]] && echo "Unknown" && return 1
    
    # Check if mediainfo tools are disabled
    [[ "$MEDIAINFO_TOOL" == "off" ]] && echo "Unknown" && return 1
    
    # Use timeout to prevent hangs (5 seconds max)
    local height=""
    if command -v timeout &> /dev/null; then
        height=$(timeout 5 get_video_resolution_height "$file_path" 2>/dev/null)
    else
        height=$(get_video_resolution_height "$file_path" 2>/dev/null)
    fi
    
    # Convert height to resolution label
    if [[ $height -ge 2160 ]]; then
        echo "4K"
    elif [[ $height -ge 1080 ]]; then
        echo "1080p"
    elif [[ $height -ge 720 ]]; then
        echo "720p"
    elif [[ $height -ge 576 ]]; then
        echo "576p"
    elif [[ $height -ge 480 ]]; then
        echo "480p"
    elif [[ $height -gt 0 ]]; then
        echo "${height}p"
    else
        echo "Unknown"
    fi
}

# Convert resolution label to numeric value for sorting
resolution_to_number() {
    local resolution="$1"
    
    case "$resolution" in
        "8K") echo "7680" ;;
        "4K") echo "2160" ;;
        "1080p") echo "1080" ;;
        "720p") echo "720" ;;
        "576p") echo "576" ;;
        "480p") echo "480" ;;
        *) 
            # Extract number from format like "1440p"
            if [[ "$resolution" =~ ^([0-9]+)p$ ]]; then
                echo "${BASH_REMATCH[1]}"
            else
                echo "0"
            fi
            ;;
    esac
}

# Extract MediaInfo from video file using mediainfo or ffprobe
get_mediainfo_from_file() {
    local file_path="$1"
    
    if [[ ! -f "$file_path" ]]; then
        should_debug high && echo "[DEBUG] get_mediainfo_from_file: File not found" >&2
        return 1
    fi
    
    # Check if disabled
    if [[ "$MEDIAINFO_TOOL" == "off" ]]; then
        should_debug high && echo "[DEBUG] Metadata extraction disabled (tool=off)" >&2
        return 1
    fi
    
    # Reset mediainfo variables
    MEDIAINFO_VIDEO_CODEC=""
    MEDIAINFO_AUDIO_CODEC=""
    MEDIAINFO_AUDIO_CHANNELS=""
    MEDIAINFO_HDR=""
    MEDIAINFO_RESOLUTION=""
    MEDIAINFO_BIT_DEPTH=""
    MEDIAINFO_AUDIO_LANGUAGE=""
    
    # Try preferred tool first, then fallback
    local use_tool="$MEDIAINFO_TOOL"
    
    should_debug high && echo "[DEBUG] [$use_tool] Extracting metadata from: $(basename "$file_path")" >&2
    
    # Check availability and fallback if needed
    if [[ "$use_tool" == "mediainfo" ]] && ! command -v mediainfo &> /dev/null; then
        if command -v ffprobe &> /dev/null; then
            use_tool="ffprobe"
            should_debug high && echo "[DEBUG] mediainfo not available, falling back to ffprobe" >&2
        else
            return 1
        fi
    elif [[ "$use_tool" == "ffprobe" ]] && ! command -v ffprobe &> /dev/null; then
        if command -v mediainfo &> /dev/null; then
            use_tool="mediainfo"
            should_debug high && echo "[DEBUG] ffprobe not available, falling back to mediainfo" >&2
        else
            return 1
        fi
    fi
    
    # Extract using mediainfo
    if [[ "$use_tool" == "mediainfo" ]]; then
        # Call mediainfo twice (once for video, once for audio) to ensure separate lines
        local video_output=$(mediainfo --Output='Video;%Format%|%Height%|%HDR_Format%|%colour_primaries%|%MultiView_Count%|%BitDepth%' "$file_path" 2>/dev/null)
        local audio_output=$(mediainfo --Output='Audio;%Format%|%Format_Profile%|%Channel(s)%|%Language%' "$file_path" 2>/dev/null)
        
        # Parse video data (first video stream only)
        local video_codec=$(echo "$video_output" | cut -d'|' -f1)
        local height=$(echo "$video_output" | cut -d'|' -f2)
        local hdr_format=$(echo "$video_output" | cut -d'|' -f3)
        local color_primaries=$(echo "$video_output" | cut -d'|' -f4)
        local multiview_count=$(echo "$video_output" | cut -d'|' -f5)
        local bit_depth=$(echo "$video_output" | cut -d'|' -f6)
        
        # Parse audio data (first audio stream only)
        # When multiple audio tracks exist, mediainfo concatenates them (e.g., "AAC||2AAC||2" or "AC-3||2AC-3||2")
        # Extract only the first track by taking fields 1-4, and extract leading digits from field 3
        local audio_codec=$(echo "$audio_output" | awk -F'|' '{print $1}')
        local audio_profile=$(echo "$audio_output" | awk -F'|' '{print $2}')
        local channels=$(echo "$audio_output" | awk -F'|' '{print $3}' | grep -oE '^[0-9]+' || echo "")
        local audio_language=$(echo "$audio_output" | awk -F'|' '{print $4}')
        
        # Process video codec
        local video_codec_lower=$(echo "$video_codec" | tr '[:upper:]' '[:lower:]')
        case "$video_codec_lower" in
            avc|*264*) MEDIAINFO_VIDEO_CODEC="H.264" ;;
            hevc|*265*) MEDIAINFO_VIDEO_CODEC="H.265" ;;
            av1) MEDIAINFO_VIDEO_CODEC="AV1" ;;
            *mpeg*4*|xvid) MEDIAINFO_VIDEO_CODEC="XviD" ;;
            *) MEDIAINFO_VIDEO_CODEC="${video_codec}" ;;
        esac
        
        # Process resolution (with optional rounding to standard heights)
        if [[ -n "$height" && "$height" =~ ^[0-9]+$ ]]; then
            if [[ "$ROUND_RESOLUTION" == "yes" ]]; then
                # Round to nearest standard resolution
                if [[ $height -ge 2000 ]]; then
                    MEDIAINFO_RESOLUTION="2160p"  # 4K UHD
                elif [[ $height -ge 1000 ]]; then
                    MEDIAINFO_RESOLUTION="1080p"  # Full HD
                elif [[ $height -ge 700 ]]; then
                    MEDIAINFO_RESOLUTION="720p"   # HD
                elif [[ $height -ge 550 ]]; then
                    MEDIAINFO_RESOLUTION="576p"   # PAL SD
                else
                    MEDIAINFO_RESOLUTION="480p"   # NTSC SD
                fi
            else
                # Use exact resolution
                MEDIAINFO_RESOLUTION="${height}p"
            fi
        fi
        
        # Process audio codec
        local audio_codec_lower=$(echo "$audio_codec" | tr '[:upper:]' '[:lower:]')
        local audio_profile_lower=$(echo "$audio_profile" | tr '[:upper:]' '[:lower:]')
        should_debug high && echo "[DEBUG] [mediainfo] audio - codec: '$audio_codec' channels: '$channels'" >&2
        case "$audio_codec_lower" in
            aac) MEDIAINFO_AUDIO_CODEC="AAC" ;;
            ac-3|ac3) MEDIAINFO_AUDIO_CODEC="AC3" ;;
            e-ac-3|eac3) MEDIAINFO_AUDIO_CODEC="DD+" ;;
            dts) 
                if [[ "$audio_profile_lower" =~ "ma" ]]; then
                    MEDIAINFO_AUDIO_CODEC="DTS-HD MA"
                else
                    MEDIAINFO_AUDIO_CODEC="DTS"
                fi
                ;;
            truehd) MEDIAINFO_AUDIO_CODEC="TrueHD" ;;
            flac) MEDIAINFO_AUDIO_CODEC="FLAC" ;;
            "mpeg audio"|mp3) MEDIAINFO_AUDIO_CODEC="MP3" ;;
            *) MEDIAINFO_AUDIO_CODEC="${audio_codec}" ;;
        esac
        
        # Process audio channels
        case "$channels" in
            1) MEDIAINFO_AUDIO_CHANNELS="1.0" ;;
            2) MEDIAINFO_AUDIO_CHANNELS="2.0" ;;
            6) MEDIAINFO_AUDIO_CHANNELS="5.1" ;;
            8) MEDIAINFO_AUDIO_CHANNELS="7.1" ;;
            *) 
                # Handle other channel counts or set to a formatted value if numeric
                if [[ -n "$channels" && "$channels" =~ ^[0-9]+$ ]]; then
                    MEDIAINFO_AUDIO_CHANNELS="${channels}.0"
                fi
                ;;
        esac
        
        # Detect 3D from multiview count or MVC in codec name
        if [[ -n "$multiview_count" && "$multiview_count" -gt 1 ]] || [[ "$video_codec" =~ "MVC" ]]; then
            MEDIAINFO_3D=true
            should_debug high && echo "[DEBUG] [mediainfo] 3D detected (MultiView_Count=$multiview_count)" >&2
        else
            MEDIAINFO_3D=false
        fi
        
        # Store bit depth
        if [[ -n "$bit_depth" && "$bit_depth" =~ ^[0-9]+$ ]]; then
            MEDIAINFO_BIT_DEPTH="${bit_depth}bit"
        fi
        
        # Store audio language (normalize to 2-letter uppercase codes)
        if [[ -n "$audio_language" ]]; then
            local audio_lang_lower=$(echo "$audio_language" | tr '[:upper:]' '[:lower:]')
            case "$audio_lang_lower" in
                en|eng|english) MEDIAINFO_AUDIO_LANGUAGE="EN" ;;
                ja|jp|jpn|japanese) MEDIAINFO_AUDIO_LANGUAGE="JA" ;;
                de|ger|german) MEDIAINFO_AUDIO_LANGUAGE="DE" ;;
                fr|fre|french) MEDIAINFO_AUDIO_LANGUAGE="FR" ;;
                es|spa|spanish) MEDIAINFO_AUDIO_LANGUAGE="ES" ;;
                it|ita|italian) MEDIAINFO_AUDIO_LANGUAGE="IT" ;;
                pt|por|portuguese) MEDIAINFO_AUDIO_LANGUAGE="PT" ;;
                ru|rus|russian) MEDIAINFO_AUDIO_LANGUAGE="RU" ;;
                ko|kor|korean) MEDIAINFO_AUDIO_LANGUAGE="KO" ;;
                zh|chi|chinese) MEDIAINFO_AUDIO_LANGUAGE="ZH" ;;
                *) MEDIAINFO_AUDIO_LANGUAGE="$(echo ${audio_language:0:2} | tr '[:lower:]' '[:upper:]')" ;;
            esac
        fi
        
        should_debug high && echo "[DEBUG] [mediainfo] results - VIDEO='$MEDIAINFO_VIDEO_CODEC' AUDIO='$MEDIAINFO_AUDIO_CODEC' CHANNELS='$MEDIAINFO_AUDIO_CHANNELS' RESOLUTION='$MEDIAINFO_RESOLUTION' 3D='$MEDIAINFO_3D' BIT_DEPTH='$MEDIAINFO_BIT_DEPTH' LANG='$MEDIAINFO_AUDIO_LANGUAGE'" >&2
        
        # Process HDR info (detect DV and HDR separately, combine if both present)
        local hdr_format_lower=$(echo "$hdr_format" | tr '[:upper:]' '[:lower:]')
        local color_primaries_lower=$(echo "$color_primaries" | tr '[:upper:]' '[:lower:]')
        local has_dv=false
        local has_hdr=""
        
        if [[ "$hdr_format_lower" =~ "dolby vision" ]]; then
            has_dv=true
        fi
        
        if [[ "$hdr_format_lower" =~ "hdr10+" ]] || [[ "$hdr_format_lower" =~ "hdr10 plus" ]]; then
            has_hdr="HDR10+"
        elif [[ "$hdr_format_lower" =~ "hdr10" ]] || [[ "$color_primaries_lower" =~ "bt.2020" ]]; then
            has_hdr="HDR10"
        elif [[ "$hdr_format_lower" =~ "hlg" ]]; then
            has_hdr="HLG"
        fi
        
        # Combine DV + HDR if both present (TrashGuides format: "DV HDR10")
        if [[ "$has_dv" == "true" && -n "$has_hdr" ]]; then
            MEDIAINFO_HDR="DV ${has_hdr}"
        elif [[ "$has_dv" == "true" ]]; then
            MEDIAINFO_HDR="DV"
        elif [[ -n "$has_hdr" ]]; then
            MEDIAINFO_HDR="$has_hdr"
        fi
        
    # Extract using ffprobe
    else
        # Call ffprobe twice (once for video, once for audio) to ensure clean separation
        # -select_streams v:0 = first video stream, a:0 = first audio stream
        local video_output=$(ffprobe -v quiet -select_streams v:0 -show_entries \
            "stream=codec_name,height,color_transfer:stream_side_data=dv_profile:stream_side_data_list:stream=stereo_mode" \
            -of csv=p=0:s=x "$file_path" 2>/dev/null)
        
        local audio_output=$(ffprobe -v quiet -select_streams a:0 -show_entries \
            "stream=codec_name,channels" \
            -of csv=p=0:s=x "$file_path" 2>/dev/null)
        
        # Parse video data (first video stream)
        local video_codec=$(echo "$video_output" | cut -d'x' -f1)
        local height=$(echo "$video_output" | cut -d'x' -f2)
        local color_transfer=$(echo "$video_output" | cut -d'x' -f3)
        local stereo_mode=$(echo "$video_output" | cut -d'x' -f4)
        
        # Parse audio data
        local audio_codec=$(echo "$audio_output" | cut -d'x' -f1)
        local channels=$(echo "$audio_output" | cut -d'x' -f2)
        
        should_debug high && echo "[DEBUG] [ffprobe] audio - codec: '$audio_codec' channels: '$channels'" >&2
        
        # Map video codec
        case "$video_codec" in
            h264) MEDIAINFO_VIDEO_CODEC="H.264" ;;
            hevc|h265) MEDIAINFO_VIDEO_CODEC="H.265" ;;
            av1) MEDIAINFO_VIDEO_CODEC="AV1" ;;
            mpeg4) MEDIAINFO_VIDEO_CODEC="XviD" ;;
            *) MEDIAINFO_VIDEO_CODEC=$(echo "$video_codec" | tr '[:lower:]' '[:upper:]') ;;
        esac
        
        # Map resolution (with optional rounding to standard heights)
        if [[ -n "$height" && "$height" =~ ^[0-9]+$ ]]; then
            if [[ "$ROUND_RESOLUTION" == "yes" ]]; then
                # Round to nearest standard resolution
                if [[ $height -ge 2000 ]]; then
                    MEDIAINFO_RESOLUTION="2160p"  # 4K UHD
                elif [[ $height -ge 1000 ]]; then
                    MEDIAINFO_RESOLUTION="1080p"  # Full HD
                elif [[ $height -ge 700 ]]; then
                    MEDIAINFO_RESOLUTION="720p"   # HD
                elif [[ $height -ge 550 ]]; then
                    MEDIAINFO_RESOLUTION="576p"   # PAL SD
                else
                    MEDIAINFO_RESOLUTION="480p"   # NTSC SD
                fi
            else
                # Use exact resolution
                MEDIAINFO_RESOLUTION="${height}p"
            fi
        fi
        
        # Map audio codec
        case "$audio_codec" in
            aac) MEDIAINFO_AUDIO_CODEC="AAC" ;;
            ac3) MEDIAINFO_AUDIO_CODEC="AC3" ;;
            eac3) MEDIAINFO_AUDIO_CODEC="DD+" ;;
            dts) MEDIAINFO_AUDIO_CODEC="DTS" ;;
            truehd) MEDIAINFO_AUDIO_CODEC="TrueHD" ;;
            flac) MEDIAINFO_AUDIO_CODEC="FLAC" ;;
            *) MEDIAINFO_AUDIO_CODEC=$(echo "$audio_codec" | tr '[:lower:]' '[:upper:]') ;;
        esac
        
        # Map audio channels
        case "$channels" in
            1) MEDIAINFO_AUDIO_CHANNELS="1.0" ;;
            2) MEDIAINFO_AUDIO_CHANNELS="2.0" ;;
            6) MEDIAINFO_AUDIO_CHANNELS="5.1" ;;
            8) MEDIAINFO_AUDIO_CHANNELS="7.1" ;;
            *) 
                # Handle other channel counts or set to a formatted value if numeric
                if [[ -n "$channels" && "$channels" =~ ^[0-9]+$ ]]; then
                    MEDIAINFO_AUDIO_CHANNELS="${channels}.0"
                fi
                ;;
        esac
        
        # Detect 3D from stereo_mode or MVC codec
        if [[ -n "$stereo_mode" && "$stereo_mode" != "mono" ]] || [[ "$video_codec" =~ "mvc" ]]; then
            MEDIAINFO_3D=true
            should_debug high && echo "[DEBUG] [ffprobe] 3D detected (stereo_mode=$stereo_mode)" >&2
        else
            MEDIAINFO_3D=false
        fi
        
        should_debug high && echo "[DEBUG] [ffprobe] results - VIDEO='$MEDIAINFO_VIDEO_CODEC' AUDIO='$MEDIAINFO_AUDIO_CODEC' CHANNELS='$MEDIAINFO_AUDIO_CHANNELS' RESOLUTION='$MEDIAINFO_RESOLUTION' 3D='$MEDIAINFO_3D'" >&2
        
        # Detect HDR
        if [[ "$color_transfer" == "smpte2084" ]]; then
            MEDIAINFO_HDR="HDR10"
        elif [[ "$color_transfer" =~ "hlg" ]]; then
            MEDIAINFO_HDR="HLG"
        fi
        
        # Check for Dolby Vision (requires separate query for side data)
        if [[ "$ffprobe_output" =~ "dv_profile" ]]; then
            MEDIAINFO_HDR="DV"
        fi
    fi
    
    return 0
}

# Strip edition/cut keywords from title for ID lookups
# These should be removed when searching APIs but kept in the full title for display
strip_editions_for_lookup() {
    local title="$1"
    
    # Remove edition/cut keywords ONLY when followed by Cut/Edition/Version
    # This prevents removing words like "Final" when they're part of the actual title
    title=$(echo "$title" | sed -E 's/[[:space:]]+(Extended|Unrated|Remastered|Restored|Ultimate|Final|Alternate|Special|Collectors?|Limited|Anniversary|Definitive)[[:space:]]+(Cut|Edition|Version)[[:space:]]*//gi')
    title=$(echo "$title" | sed -E 's/[[:space:]]+(Directors?|Producers?|Editors?|Theatrical|International|European|Japanese|Korean|Chinese|Criterion)[[:space:]]+(Cut|Edition|Version)[[:space:]]*//gi')
    
    # Remove standalone Cut/Edition/Version at the end
    title=$(echo "$title" | sed -E 's/[[:space:]]+(Cut|Edition|Version)[[:space:]]*$//gi')
    
    # Remove standalone version markers (THEATRICAL, UNRATED, etc.) at the end or as standalone words
    title=$(echo "$title" | sed -E 's/[[:space:]]+(THEATRICAL|UNRATED|EXTENDED|REMASTERED|RESTORED|IMAX|REDUX)[[:space:]]*$//gi')
    title=$(echo "$title" | sed -E 's/[[:space:]]+(THEATRICAL|UNRATED|EXTENDED|REMASTERED|RESTORED|IMAX|REDUX)[[:space:]]+/ /gi')
    
    # Fix sequel titles: "Movie 2 Subtitle" -> "Movie: Subtitle" 
    # But preserve titles like "Scary Movie 2" where number IS the title
    if [[ "$title" =~ ^(.+)[[:space:]]2[[:space:]]([A-Z][a-z].*)$ ]]; then
        local main="${BASH_REMATCH[1]}"
        local sub="${BASH_REMATCH[2]}"
        # Only apply if subtitle is substantial (not just a short word)
        if [[ ${#sub} -ge 5 ]]; then
            title="$main: $sub"
        fi
    fi
    
    # Collapse multiple spaces and trim
    title=$(echo "$title" | sed 's/  */ /g')
    title="${title#"${title%%[![:space:]]*}"}"
    title="${title%"${title##*[![:space:]]}"}"
    
    echo "$title"
}

# Convert title to proper title case
# Capitalizes first letter of each word except articles/prepositions
to_title_case() {
    local title="$1"
    local result=""
    local word
    local first_word=true
    
    # Split by spaces and capitalize each word
    for word in $title; do
        local lower_word=$(echo "$word" | tr '[:upper:]' '[:lower:]')
        
        # Always capitalize first word, or if not an article/preposition
        if [ "$first_word" = true ] || \
           ! [[ "$lower_word" =~ ^(a|an|and|as|at|but|by|for|from|in|into|of|on|or|the|to|with|vs|versus)$ ]]; then
            # Capitalize first letter, keep rest as-is
            word=$(echo "${word:0:1}" | tr '[:lower:]' '[:upper:]')$(echo "${word:1}" | tr '[:upper:]' '[:lower:]')
        else
            # Keep articles/prepositions lowercase
            word="$lower_word"
        fi
        
        if [ -z "$result" ]; then
            result="$word"
        else
            result="$result $word"
        fi
        first_word=false
    done
    
    echo "$result"
}

# Search IMDb with runtime disambiguation for same-name movies
search_imdb_with_runtime() {
    local title="$1"
    local year="$2"
    local file_path="$3"
    local file_runtime=""
    
    # Get runtime from video file if possible
    if [[ -n "$file_path" && -f "$file_path" ]]; then
        file_runtime=$(get_file_runtime "$file_path")
    fi
    
    print_info "Searching IMDb for: $title ($year)..." >&2
    if [[ -n "$file_runtime" ]]; then
        print_info "File runtime: ${file_runtime} minutes" >&2
    fi
    api_delay
    
    # Try IMDb suggestion API first
    local encoded_title=$(url_encode "$title")
    local search_url="https://v3.sg.media-imdb.com/suggestion/x/${encoded_title}.json"
    local result=$(curl -s -A "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36" "$search_url" 2>/dev/null)
    
    # Get all IMDb IDs that match the year from suggestion API
    # Extract entries with matching year, handling nested JSON
    local -a candidate_ids=()
    while IFS= read -r line; do
        if [[ -n "$line" ]]; then
            candidate_ids+=("$line")
        fi
    done < <(echo "$result" | grep -oE '"id":"tt[0-9]{7,8}"[^{]*"y":'$year | grep -oE 'tt[0-9]{7,8}')
    
    # If no exact year match, try ±1 year
    if [[ ${#candidate_ids[@]} -eq 0 ]]; then
        local year_minus=$((year - 1))
        local year_plus=$((year + 1))
        while IFS= read -r line; do
            if [[ -n "$line" ]]; then
                candidate_ids+=("$line")
            fi
        done < <(echo "$result" | grep -oE '"id":"tt[0-9]{7,8}"[^{]*"y":('$year_minus'|'$year_plus')' | grep -oE 'tt[0-9]{7,8}')
    fi
    
    # Also try direct IMDb search page to catch movies the suggestion API misses
    print_info "Searching IMDb search page for additional matches..." >&2
    local encoded_search=$(echo "$title" | sed 's/ /+/g')
    local search_page_url="https://www.imdb.com/find/?q=${encoded_search}+${year}&s=tt&ttype=ft"
    local search_page=$(curl -s -A "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36" "$search_page_url" 2>/dev/null)
    
    # Extract all IMDb IDs from search results
    while IFS= read -r line; do
        if [[ -n "$line" ]]; then
            # Check if already in candidate_ids
            local already_added=0
            for cid in "${candidate_ids[@]}"; do
                if [[ "$cid" == "$line" ]]; then
                    already_added=1
                    break
                fi
            done
            [[ $already_added -eq 0 ]] && candidate_ids+=("$line")
        fi
    done < <(echo "$search_page" | grep -oE 'href="/title/(tt[0-9]{7,8})' | grep -oE 'tt[0-9]{7,8}' | head -10)
    
    # Remove duplicates
    local -a unique_candidates=()
    for cid in "${candidate_ids[@]}"; do
        local is_dup=0
        for ucid in "${unique_candidates[@]}"; do
            if [[ "$ucid" == "$cid" ]]; then
                is_dup=1
                break
            fi
        done
        [[ $is_dup -eq 0 ]] && unique_candidates+=("$cid")
    done
    candidate_ids=("${unique_candidates[@]}")
    
    # If no candidates found, check if it might be a TV show before giving up
    if [[ ${#candidate_ids[@]} -eq 0 ]]; then
        print_warning "No movie candidates found for: $title ($year)" >&2
        
        # Try to find if this title exists as a TV show instead
        if [[ -n "$TMDB_API_KEY" ]]; then
            print_info "Checking if this is a TV show instead..." >&2
            api_delay
            
            # Try TMDb TV search
            local tv_search_url="${TMDB_API_BASE}/search/tv?api_key=${TMDB_API_KEY}&query=$(url_encode "$title")&first_air_date_year=${year}"
            local tv_result=$(curl -s --connect-timeout 10 --max-time 30 "$tv_search_url" 2>/dev/null)
            local tv_count=$(echo "$tv_result" | grep -o '"id":' | wc -l | tr -d ' ')
            
            if [[ "$tv_count" -gt 0 ]]; then
                # Get the first TV show's TMDb ID and find its IMDb ID
                local tv_tmdb_id=$(echo "$tv_result" | grep -oE '"id":[0-9]+' | head -1 | grep -oE '[0-9]+')
                if [[ -n "$tv_tmdb_id" ]]; then
                    api_delay
                    local tv_details_url="${TMDB_API_BASE}/tv/${tv_tmdb_id}?api_key=${TMDB_API_KEY}&append_to_response=external_ids"
                    local tv_details=$(curl -s --connect-timeout 10 --max-time 30 "$tv_details_url" 2>/dev/null)
                    local tv_imdb=$(echo "$tv_details" | grep -oE '"imdb_id":"tt[0-9]+"' | grep -oE 'tt[0-9]+' | head -1)
                    
                    if [[ -n "$tv_imdb" ]]; then
                        print_info "Note: This appears to be a TV show/miniseries (IMDb: $tv_imdb)" >&2
                        print_info "Processing as movie - miniseries are often cataloged as TV shows" >&2
                        # Don't reject - many miniseries should be processed as movies
                        # Return the TV IMDb as a valid result
                        echo "$tv_imdb"
                        return 0
                    fi
                fi
            fi
        fi
        
        print_warning "No candidates found - cannot proceed" >&2
        echo ""
        return 1
    fi
    
    # If only 1 candidate, return immediately
    if [[ ${#candidate_ids[@]} -eq 1 ]]; then
        print_success "Found IMDb ID: ${candidate_ids[0]}" >&2
        echo "${candidate_ids[0]}"
        return 0
    fi
    
    print_info "Found ${#candidate_ids[@]} potential match(es)" >&2
    sleep 0.5
    
    # If we have multiple candidates, auto-select best match by runtime or use first
    if [[ ${#candidate_ids[@]} -gt 1 ]]; then
        echo "" >&2
        echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}" >&2
        echo -e "${CYAN}Multiple matches found for: ${title} (${year})${NC}" >&2
        if [[ -n "$file_runtime" ]]; then
            echo -e "${CYAN}Your file runtime: ${GREEN}${file_runtime} minutes${NC}" >&2
        fi
        echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}" >&2
        echo "" >&2
        
        # Check each candidate for title match (exact, then fuzzy with number/word conversion)
        local selected_id=""
        local -a candidate_titles=()
        local -a candidate_norm_titles=()
        local -a exact_match_ids=()
        
        # First pass: collect all titles and find exact matches
        for candidate in "${candidate_ids[@]}"; do
            local imdb_title=$(get_imdb_title "$candidate")
            candidate_titles+=("$imdb_title")
            
            if [[ -n "$imdb_title" ]]; then
                # Normalize for exact comparison
                local norm_file_title=$(echo "$title" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9 ]//g')
                local norm_imdb_title=$(echo "$imdb_title" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9 ]//g')
                candidate_norm_titles+=("$norm_imdb_title")
                
                echo -e "${DIM}  ${candidate}: \"${imdb_title}\"${NC}" >&2
                
                # Track all exact matches (don't auto-select yet if multiple exist)
                if [[ "$norm_file_title" == "$norm_imdb_title" ]]; then
                    exact_match_ids+=("$candidate")
                fi
            fi
            
            sleep 0.3
        done
        
        # If there's only 1 exact match, auto-select it
        if [[ ${#exact_match_ids[@]} -eq 1 ]]; then
            selected_id="${exact_match_ids[0]}"
            local matched_title=""
            for ((i=0; i<${#candidate_ids[@]}; i++)); do
                if [[ "${candidate_ids[$i]}" == "$selected_id" ]]; then
                    matched_title="${candidate_titles[$i]}"
                    break
                fi
            done
            print_success "Auto-selected: \"${matched_title}\" (exact title match)" >&2
        elif [[ ${#exact_match_ids[@]} -gt 1 ]]; then
            # Multiple exact matches found - will need runtime matching
            echo "" >&2
            print_info "Multiple exact title matches found (${#exact_match_ids[@]} movies with same name)" >&2
        fi
        
        # Second pass: if no exact match, try fuzzy matching (number/word conversion)
        if [[ -z "$selected_id" ]]; then
            local fuzzy_file_title=$(normalize_title_fuzzy "$title")
            
            for ((i=0; i<${#candidate_ids[@]}; i++)); do
                local candidate="${candidate_ids[$i]}"
                local imdb_title="${candidate_titles[$i]}"
                
                if [[ -n "$imdb_title" ]]; then
                    local fuzzy_imdb_title=$(normalize_title_fuzzy "$imdb_title")
                    
                    # Check if fuzzy normalized titles match
                    if [[ "$fuzzy_file_title" == "$fuzzy_imdb_title" ]]; then
                        selected_id="$candidate"
                        print_success "Auto-selected: \"${imdb_title}\" (fuzzy match: number/word conversion)" >&2
                        break
                    fi
                fi
            done
        fi
        
        # Third pass: if we have multiple exact matches or all titles are identical, use runtime matching
        if [[ -z "$selected_id" && -n "$file_runtime" ]]; then
            # Determine if we should use runtime matching:
            # 1. Multiple exact matches found, OR
            # 2. Multiple candidates with identical normalized titles
            local should_use_runtime=0
            
            if [[ ${#exact_match_ids[@]} -gt 1 ]]; then
                # Multiple exact matches - use runtime to disambiguate
                should_use_runtime=1
                echo "" >&2
                print_info "Using runtime matching to disambiguate between ${#exact_match_ids[@]} exact title matches..." >&2
            elif [[ ${#candidate_ids[@]} -gt 1 ]]; then
                # Check if all normalized titles are identical
                local first_norm_title="${candidate_norm_titles[0]}"
                local all_titles_same=1
                for norm_title in "${candidate_norm_titles[@]}"; do
                    if [[ "$norm_title" != "$first_norm_title" ]]; then
                        all_titles_same=0
                        break
                    fi
                done
                
                if [[ $all_titles_same -eq 1 ]]; then
                    should_use_runtime=1
                    echo "" >&2
                    print_info "Multiple movies with identical title found - using runtime to disambiguate..." >&2
                fi
            fi
            
            if [[ $should_use_runtime -eq 1 ]]; then
                echo -e "${CYAN}File runtime: ${GREEN}${file_runtime} minutes${NC}" >&2
                echo "" >&2
                
                local best_match_id=""
                local best_runtime_diff=999999
                local -a candidates_to_check=()
                
                # If we have exact matches, only check those; otherwise check all candidates
                if [[ ${#exact_match_ids[@]} -gt 0 ]]; then
                    candidates_to_check=("${exact_match_ids[@]}")
                else
                    candidates_to_check=("${candidate_ids[@]}")
                fi
                
                for candidate in "${candidates_to_check[@]}"; do
                    # Find the title for this candidate
                    local imdb_title=""
                    for ((i=0; i<${#candidate_ids[@]}; i++)); do
                        if [[ "${candidate_ids[$i]}" == "$candidate" ]]; then
                            imdb_title="${candidate_titles[$i]}"
                            break
                        fi
                    done
                    
                    # Get runtime for this candidate
                    echo -e "${CYAN}[RUNTIME] Fetching runtime for ${candidate}...${NC}" >&2
                    api_delay
                    local candidate_runtime=$(get_imdb_runtime "$candidate")
                    
                    if [[ -n "$candidate_runtime" ]]; then
                        local runtime_diff=$((file_runtime > candidate_runtime ? file_runtime - candidate_runtime : candidate_runtime - file_runtime))
                        echo -e "${CYAN}[RUNTIME]${NC}   ${candidate}: \"${imdb_title}\" - ${GREEN}${candidate_runtime} min${NC} (diff: ${YELLOW}${runtime_diff} min${NC})" >&2
                        
                        # Track best match by smallest runtime difference
                        if [[ $runtime_diff -lt $best_runtime_diff ]]; then
                            best_runtime_diff=$runtime_diff
                            best_match_id=$candidate
                        fi
                    else
                        echo -e "${CYAN}[RUNTIME]${NC}   ${candidate}: \"${imdb_title}\" - ${RED}runtime unavailable${NC}" >&2
                    fi
                done
                
                # If we found a match with runtime within 4 minutes (strict), use it
                if [[ -n "$best_match_id" && $best_runtime_diff -le 4 ]]; then
                    selected_id="$best_match_id"
                    echo "" >&2
                    print_success "Auto-selected: ${best_match_id} (runtime match: ${best_runtime_diff} min difference)" >&2
                else
                    # No match within 4 minutes - reject to prevent wrong match
                    echo "" >&2
                    print_warning "No candidate within 4 minute runtime threshold (best was ${best_runtime_diff} min)" >&2
                fi
            fi
        fi
        
        # Fourth pass: if still no match but we have candidates and runtime, try runtime matching without title restriction
        if [[ -z "$selected_id" && -n "$file_runtime" && ${#candidate_ids[@]} -gt 0 ]]; then
            echo "" >&2
            print_info "No exact title match found - attempting runtime-based matching with all ${#candidate_ids[@]} candidate(s)..." >&2
            echo -e "${CYAN}File runtime: ${GREEN}${file_runtime} minutes${NC}" >&2
            echo "" >&2
            
            local best_match_id=""
            local best_runtime_diff=999999
            
            for ((i=0; i<${#candidate_ids[@]}; i++)); do
                local candidate="${candidate_ids[$i]}"
                local imdb_title="${candidate_titles[$i]}"
                
                # Get runtime for this candidate
                echo -e "${CYAN}[RUNTIME] Fetching runtime for ${candidate}...${NC}" >&2
                api_delay
                local candidate_runtime=$(get_imdb_runtime "$candidate")
                
                if [[ -n "$candidate_runtime" ]]; then
                    local runtime_diff=$((file_runtime > candidate_runtime ? file_runtime - candidate_runtime : candidate_runtime - file_runtime))
                    echo -e "${CYAN}[RUNTIME]${NC}   ${candidate}: \"${imdb_title}\" - ${GREEN}${candidate_runtime} min${NC} (diff: ${YELLOW}${runtime_diff} min${NC})" >&2
                    
                    # Track best match by smallest runtime difference
                    if [[ $runtime_diff -lt $best_runtime_diff ]]; then
                        best_runtime_diff=$runtime_diff
                        best_match_id=$candidate
                    fi
                else
                    echo -e "${CYAN}[RUNTIME]${NC}   ${candidate}: \"${imdb_title}\" - ${RED}runtime unavailable${NC}" >&2
                fi
            done
            
            # Accept runtime match only if within 4 minutes (strict)
            if [[ -n "$best_match_id" && $best_runtime_diff -le 4 ]]; then
                selected_id="$best_match_id"
                echo "" >&2
                print_success "Auto-selected: ${best_match_id} (runtime match: ${best_runtime_diff} min difference)" >&2
            else
                # No match within 4 minutes - reject to prevent wrong match
                echo "" >&2
                print_warning "No candidate within 4 minute runtime threshold (best was ${best_runtime_diff} min)" >&2
            fi
        fi
        
        # Use selected match or reject if no match
        if [[ -n "$selected_id" ]]; then
            echo "$selected_id"
            return 0
        else
            # DON'T check if candidates are TV shows here - they didn't match the title anyway
            # Only reject as "no match" rather than incorrectly flagging as TV show
            print_info "No title match found among ${#candidate_ids[@]} candidate(s)" >&2
            
            # Special case: for very short titles (1-2 chars), IMDb search often returns wrong results
            # Check TMDb TV database directly as the actual title might be a TV show that IMDb didn't return
            local title_length=${#title}
            if [[ $title_length -le 2 && -n "$TMDB_API_KEY" ]]; then
                print_info "Very short title detected - checking TMDb TV database directly..." >&2
                api_delay
                
                local tv_search_url="${TMDB_API_BASE}/search/tv?api_key=${TMDB_API_KEY}&query=$(url_encode "$title")&first_air_date_year=${year}"
                local tv_result=$(curl -s --connect-timeout 10 --max-time 30 "$tv_search_url" 2>/dev/null)
                local tv_count=$(echo "$tv_result" | grep -o '"id":' | wc -l | tr -d ' ')
                
                if [[ "$tv_count" -gt 0 ]]; then
                    # Check if any TV show matches the exact title and year
                    local tv_title=$(echo "$tv_result" | grep -oE '"name":"[^"]+' | head -1 | cut -d'"' -f4)
                    if [[ -n "$tv_title" ]]; then
                        local tv_tmdb_id=$(echo "$tv_result" | grep -oE '"id":[0-9]+' | head -1 | grep -oE '[0-9]+')
                        print_info "Found TV show on TMDb: \"$tv_title\" (TMDb TV ID: $tv_tmdb_id)" >&2
                        
                        # Get the IMDb ID for this TV show
                        api_delay
                        local tv_details_url="${TMDB_API_BASE}/tv/${tv_tmdb_id}?api_key=${TMDB_API_KEY}&append_to_response=external_ids"
                        local tv_details=$(curl -s --connect-timeout 10 --max-time 30 "$tv_details_url" 2>/dev/null)
                        local tv_imdb=$(echo "$tv_details" | grep -oE '"imdb_id":"tt[0-9]+"' | grep -oE 'tt[0-9]+' | head -1)
                        
                        if [[ -n "$tv_imdb" ]]; then
                            print_info "Note: This appears to be a TV show/miniseries (IMDb: $tv_imdb)" >&2
                            print_info "Processing as movie - miniseries are often cataloged as TV shows" >&2
                            # Don't reject - return the TV IMDb as valid
                            echo "$tv_imdb"
                            return 0
                        fi
                    fi
                fi
            fi
            
            print_warning "No title match found in IMDb results - rejecting to prevent wrong match" >&2
            echo ""
            return 1
        fi
    fi
    
    # If runtime matching didn't work or not available, use first candidate
    if [[ ${#candidate_ids[@]} -gt 0 ]]; then
        print_success "Found IMDb ID: ${candidate_ids[0]}" >&2
        echo "${candidate_ids[0]}"
        return 0
    fi
    
    # Fall back to original search method without runtime
    echo ""
    return 1
}

# URL encode function for API queries
url_encode() {
    local string="$1"
    # Use Python for proper URL encoding if available, otherwise fall back to basic encoding
    if command -v python3 &>/dev/null; then
        python3 -c "import sys, urllib.parse; print(urllib.parse.quote(sys.argv[1]))" "$string"
    else
        # Fallback: basic encoding for common special characters
        echo "$string" | sed -e 's/ /%20/g' -e 's/&/%26/g' -e 's/#/%23/g' -e 's/+/%2B/g' -e 's/=/%3D/g' -e 's/?/%3F/g' -e 's/@/%40/g' -e "s/'/%27/g"
    fi
}

# TMDb API + Web scraping functions (API first, web scraping as fallback)
search_imdb() {
    local title="$1"
    local year="$2"
    print_info "Searching for: $title ($year)..." >&2
    api_delay
    
    # First check if there are multiple results with similar/same name using IMDb autocomplete
    local encoded_title=$(url_encode "$title")
    local first_char=$(echo "${title:0:1}" | tr '[:upper:]' '[:lower:]')
    local autocomplete_url="https://v3.sg.media-imdb.com/suggestion/${first_char}/${encoded_title}.json"
    local autocomplete_result=$(curl -s -A "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36" "$autocomplete_url" 2>/dev/null)
    
    # Count how many movies with similar names exist
    local movie_count=$(echo "$autocomplete_result" | grep -oE '"q":"(feature|TV movie|video)"' | wc -l | tr -d ' ')
    
    # If no results or results don't seem relevant, try with year appended
    if [[ "$movie_count" -eq 0 ]] || ! echo "$autocomplete_result" | grep -qi "\"$title\""; then
        print_info "Basic search returned $movie_count results - trying with year appended: '$title $year'..." >&2
        local search_with_year="${title} ${year}"
        local encoded_with_year=$(url_encode "$search_with_year")
        local first_char_year=$(echo "${search_with_year:0:1}" | tr '[:upper:]' '[:lower:]')
        autocomplete_url="https://v3.sg.media-imdb.com/suggestion/${first_char_year}/${encoded_with_year}.json"
        autocomplete_result=$(curl -s -A "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36" "$autocomplete_url" 2>/dev/null)
        movie_count=$(echo "$autocomplete_result" | grep -oE '"q":"(feature|TV movie|video)"' | wc -l | tr -d ' ')
        print_info "Search with year returned $movie_count results" >&2
    fi
    
    # If multiple movies with similar names found, try title matching first before rejecting
    if [[ "$movie_count" -ge 2 ]]; then
        # Check if we're in auto mode (INTERACTIVE_MODE is false)
        if [[ "${INTERACTIVE_MODE:-true}" == "false" ]]; then
            # Before rejecting, try to find exact title match with correct year
            print_info "Found $movie_count results - attempting exact title match..." >&2
            local normalized_title=$(normalize_title_for_comparison "$title")
            
            # Parse IMDb autocomplete JSON for exact title matching
            local exact_match=""
            
            # Try using jq if available (more reliable), otherwise use manual parsing
            if command -v jq &> /dev/null; then
                should_debug high && echo "[DEBUG] Using jq for JSON parsing (normalized title: '$normalized_title', year: '$year')" >&2
                
                # Pre-process JSON to transliterate accented characters before jq processing
                # This ensures "Così" becomes "Cosi" not "Cos"
                local processed_json=$(echo "$autocomplete_result" | sed 'y/àáâãäåèéêëìíîïòóôõöùúûüýÿñçÀÁÂÃÄÅÈÉÊËÌÍÎÏÒÓÔÕÖÙÚÛÜÝŸÑÇ/aaaaaaeeeeiiiiooooouuuuyyncAAAAAAEEEEIIIIOOOOOUUUUYYNC/')
                
                # Debug: Show what jq will search through
                local candidate_count=$(echo "$processed_json" | jq -r --arg year "$year" '[.d[]? | select(.y == ($year | tonumber) and (.q == "feature" or .q == "TV movie" or .q == "video"))] | length' 2>/dev/null)
                should_debug high && echo "[DEBUG] jq found $candidate_count candidates with matching year and type" >&2
                
                # Debug: Show normalized titles
                should_debug high && echo "$processed_json" | jq -r --arg year "$year" '.d[]? | select(.y == ($year | tonumber) and (.q == "feature" or .q == "TV movie" or .q == "video")) | "  \(.id): \(.l) -> \(.l | ascii_downcase | gsub("[^a-z0-9]"; ""))"' 2>/dev/null >&2
                
                # Try exact match first
                exact_match=$(echo "$processed_json" | jq -r --arg title "$normalized_title" --arg year "$year" '
                    .d[]? | 
                    select(.y == ($year | tonumber) and (.q == "feature" or .q == "TV movie" or .q == "video")) |
                    select((.l | ascii_downcase | gsub("[^a-z0-9]"; "")) == $title) |
                    .id' | head -1)
                
                # If no match and title starts with "the", try without it
                if [[ -z "$exact_match" && "$normalized_title" =~ ^the ]]; then
                    local title_without_the="${normalized_title#the}"
                    should_debug high && echo "[DEBUG] Trying without 'the' prefix: '$title_without_the'" >&2
                    exact_match=$(echo "$processed_json" | jq -r --arg title "$title_without_the" --arg year "$year" '
                        .d[]? | 
                        select(.y == ($year | tonumber) and (.q == "feature" or .q == "TV movie" or .q == "video")) |
                        select((.l | ascii_downcase | gsub("[^a-z0-9]"; "")) == $title) |
                        .id' | head -1)
                fi
                
                if [[ -n "$exact_match" ]]; then
                    print_success "Found exact title match via jq: $exact_match" >&2
                else
                    should_debug high && echo "[DEBUG] jq did not find exact match for '$normalized_title'" >&2
                fi
            else
                should_debug high && echo "[DEBUG] Using manual JSON parsing (jq not available)" >&2
                # Extract each entry from the 'd' array
                while IFS= read -r entry; do
                    if [[ -z "$entry" ]]; then continue; fi
                    
                    # Extract components using sed (BSD-compatible)
                    local candidate_id=$(echo "$entry" | sed -n 's/.*"id":"\(tt[0-9]*\)".*/\1/p')
                    local candidate_title=$(echo "$entry" | sed -n 's/.*"l":"\([^"]*\)".*/\1/p')
                    local candidate_year=$(echo "$entry" | sed -n 's/.*"y":\([0-9]*\).*/\1/p')
                    local candidate_type=$(echo "$entry" | sed -n 's/.*"q":"\([^"]*\)".*/\1/p')
                    
                    if [[ -z "$candidate_id" || -z "$candidate_title" ]]; then continue; fi
                    
                    should_debug high && echo "[DEBUG] Extracted: title='$candidate_title', year='$candidate_year', type='$candidate_type', id='$candidate_id'" >&2
                    
                    # Check if it's a feature film or TV movie with matching year
                    if [[ "$candidate_type" =~ ^(feature|TV movie|video)$ ]] && [[ "$candidate_year" == "$year" ]]; then
                        # Normalize and compare titles
                        local normalized_candidate=$(echo "$candidate_title" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]//g')
                        
                        should_debug high && echo "[DEBUG] Comparing: '$normalized_title' vs '$normalized_candidate' (IMDb: $candidate_id, Year: $candidate_year)" >&2
                        
                        if [[ "$normalized_title" == "$normalized_candidate" ]]; then
                            exact_match="$candidate_id"
                            print_success "Found exact title match: $candidate_title ($candidate_year) - $candidate_id" >&2
                            break
                        fi
                    fi
                done < <(echo "$autocomplete_result" | sed -n 's/.*"d":\[//p' | sed 's/},{/}\n{/g' | sed 's/^\[{/{/' | sed 's/}\]$/}/')
            fi
            
            if [[ -n "$exact_match" ]]; then
                echo "$exact_match"
                return 0
            else
                print_warning "Found $movie_count movies with similar name - rejecting in auto mode to prevent wrong match" >&2
                echo ""
                return 1
            fi
        else
            print_warning "Found $movie_count movies with similar name. Use IMDb autocomplete to select? (y/n):" >&2
            read -r use_interactive </dev/tty
            
            if [[ "$use_interactive" == "y" ]]; then
                local selected_imdb=$(imdb_autocomplete_search "$title" "$year" || true)
                if [[ -n "$selected_imdb" ]]; then
                    echo "$selected_imdb"
                    return 0
                fi
                # If user skipped autocomplete, continue with normal API search below
            fi
        fi
    fi
    
    # Try TMDb API first (fastest and most reliable)
    local search_url="${TMDB_API_BASE}/search/movie?api_key=${TMDB_API_KEY}&query=${encoded_title}&year=${year}"
    local result=$(curl -s "$search_url" 2>/dev/null)
    
    # Parse JSON response and get IMDb ID from first result
    local movie_id=$(echo "$result" | grep -oE '"id":[0-9]+' | head -1 | grep -oE '[0-9]+')
    
    if [[ -n "$movie_id" ]]; then
        # Get external IDs (including IMDb ID)
        local ids_url="${TMDB_API_BASE}/movie/${movie_id}/external_ids?api_key=${TMDB_API_KEY}"
        local ids_result=$(curl -s --connect-timeout 10 --max-time 30 "$ids_url" 2>/dev/null)
        local imdb_id=$(echo "$ids_result" | grep -oE '"imdb_id":"tt[0-9]+' | grep -oE 'tt[0-9]+')
        
        if [[ -n "$imdb_id" ]]; then
            print_success "Found IMDb ID via TMDb API: $imdb_id" >&2
            echo "$imdb_id"
            return 0
        fi
    fi
    
    # If no results, try without "The" prefix (common issue)
    if [[ -z "$movie_id" && "$title" =~ ^[Tt]he[[:space:]] ]]; then
        local title_no_the="${title#[Tt]he }"
        local encoded_no_the=$(url_encode "$title_no_the")
        print_info "Retrying without 'The' prefix: $title_no_the..." >&2
        local search_url_no_the="${TMDB_API_BASE}/search/movie?api_key=${TMDB_API_KEY}&query=${encoded_no_the}&year=${year}"
        result=$(curl -s "$search_url_no_the" 2>/dev/null)
        movie_id=$(echo "$result" | grep -oE '"id":[0-9]+' | head -1 | grep -oE '[0-9]+')
        
        if [[ -n "$movie_id" ]]; then
            local ids_url="${TMDB_API_BASE}/movie/${movie_id}/external_ids?api_key=${TMDB_API_KEY}"
            local ids_result=$(curl -s --connect-timeout 10 --max-time 30 "$ids_url" 2>/dev/null)
            local imdb_id=$(echo "$ids_result" | grep -oE '"imdb_id":"tt[0-9]+' | grep -oE 'tt[0-9]+')
            
            if [[ -n "$imdb_id" ]]; then
                print_success "Found IMDb ID via TMDb API (without 'The'): $imdb_id" >&2
                echo "$imdb_id"
                return 0
            fi
        fi
    fi
    
    # Fallback to web scraping if API fails
    print_info "TMDb API lookup failed, falling back to IMDb suggestion API..." >&2
    
    # Parse JSON response - look for entries with matching year
    # Format: {"id":"tt0172348",...,"y":1999}
    local imdb_id=$(echo "$autocomplete_result" | grep -oE '\{"[^}]*"id":"(tt[0-9]{7,8})"[^}]*"y":'"$year"'\}' | grep -oE 'tt[0-9]{7,8}' | head -1)
    
    # If no exact year match, try without year requirement (first result)
    if [[ -z "$imdb_id" ]]; then
        imdb_id=$(echo "$autocomplete_result" | grep -oE '"id":"(tt[0-9]{7,8})"' | grep -oE 'tt[0-9]{7,8}' | head -1)
        
        # Verify the year is close (within 1 year for potential release date differences)
        if [[ -n "$imdb_id" ]]; then
            local result_year=$(echo "$autocomplete_result" | grep -oE '"y":[0-9]{4}' | head -1 | grep -oE '[0-9]{4}')
            if [[ -n "$result_year" ]]; then
                local year_diff=$((year - result_year))
                year_diff=${year_diff#-}  # absolute value
                if [[ $year_diff -le 1 ]]; then
                    print_success "Found IMDb ID via suggestion API: $imdb_id (year $result_year)" >&2
                    echo "$imdb_id"
                    return 0
                else
                    # Year too different, don't use
                    imdb_id=""
                fi
            fi
        fi
    else
        print_success "Found IMDb ID via suggestion API: $imdb_id" >&2
        echo "$imdb_id"
        return 0
    fi
    

    
    if [[ -n "$imdb_id" ]]; then
        print_success "Found IMDb ID: $imdb_id" >&2
        echo "$imdb_id"
    else
        print_warning "Could not find IMDb ID" >&2
    fi
}

search_tmdb() {
    local title="$1"
    local year="$2"
    local imdb_id="$3"  # Optional: if we have IMDb ID, try that first
    
    should_debug high && echo "[DEBUG] search_tmdb called: title='$title' year='$year' imdb_id='$imdb_id' mode='$JSON_DB_MODE'" >&2
    
    # Handle JSON Database Mode
    # Mode 1: json_only - Only check JSON database, never call API
    # Mode 2: api_only - Skip JSON database, always call API
    # Mode 3: hybrid - Check JSON database first, fallback to API if not found
    
    if [[ "$JSON_DB_MODE" == "json_only" ]]; then
        # JSON Database Only mode - check DB and return, no API fallback
        if [[ -n "$imdb_id" ]]; then
            should_debug high && echo "[DEBUG] JSON_ONLY mode: Checking JSON database for IMDb ID: $imdb_id" >&2
            local cached_json=$(get_json_from_db_by_imdb "$imdb_id")
            if [[ -n "$cached_json" ]]; then
                print_success "Found movie in JSON database (IMDb: $imdb_id)" >&2
                echo "$cached_json"
                return 0
            fi
        fi
        print_warning "JSON_ONLY mode: Movie not found in JSON database, API calls disabled" >&2
        return 1
    fi
    
    # For hybrid mode, check JSON DB first before calling API
    if [[ "$JSON_DB_MODE" == "hybrid" ]]; then
        # Check by IMDb ID if we have it
        if [[ -n "$imdb_id" ]]; then
            should_debug high && echo "[DEBUG] HYBRID mode: Checking JSON database for IMDb ID: $imdb_id" >&2
            local cached_json=$(get_json_from_db_by_imdb "$imdb_id")
            if [[ -n "$cached_json" ]]; then
                print_success "Found movie in JSON database (IMDb: $imdb_id) - skipping API call" >&2
                echo "$cached_json"
                return 0
            fi
            should_debug high && echo "[DEBUG] IMDb ID not found in JSON database" >&2
        fi
        
        # Also check by title/year if we don't have IMDb ID
        if [[ -z "$imdb_id" && -n "$title" && -n "$year" ]]; then
            should_debug high && echo "[DEBUG] HYBRID mode: Checking JSON database for title/year: '$title' ($year)" >&2
            local json_tmdb_id=$(get_tmdb_id_from_json_by_title_year "$title" "$year" "$SOURCE_FILE_FOR_RUNTIME")
            if [[ -n "$json_tmdb_id" ]]; then
                should_debug high && echo "[DEBUG] Found TMDb ID in JSON database: $json_tmdb_id" >&2
                local cached_json=$(get_json_from_db_by_tmdb "$json_tmdb_id")
                if [[ -n "$cached_json" ]]; then
                    print_success "Found movie in JSON database (title/year match) - skipping API call" >&2
                    echo "$cached_json"
                    return 0
                fi
            fi
            should_debug high && echo "[DEBUG] Title/year not found in JSON database, proceeding with API" >&2
        fi
    fi
    
    # API_ONLY mode or HYBRID mode with no JSON DB match - proceed with API
    if [[ "$JSON_DB_MODE" == "api_only" ]]; then
        should_debug high && echo "[DEBUG] API_ONLY mode: Skipping JSON database, calling TMDb API" >&2
    fi
    
    # If we have an IMDb ID, use TMDb API to find movie by IMDb ID (fastest)
    if [[ -n "$imdb_id" ]]; then
        print_info "Finding TMDb ID using IMDb ID: $imdb_id..." >&2
        api_delay
        
        local find_url="${TMDB_API_BASE}/find/${imdb_id}?api_key=${TMDB_API_KEY}&external_source=imdb_id"
        should_debug high && echo "[DEBUG] TMDb /find URL: $find_url" >&2
        local result=$(curl -s --connect-timeout 10 --max-time 30 "$find_url" 2>/dev/null)
        should_debug high && echo "[DEBUG] TMDb /find response: $result" >&2
        # Extract ID only from movie_results, not tv_results or person_results
        local tmdb_id=$(echo "$result" | python3 -c '
import sys, json
try:
    data = json.load(sys.stdin)
    results = data.get("movie_results", [])
    if results:
        print(results[0].get("id", ""))
except:
    pass
' 2>/dev/null)
        
        if [[ -z "$tmdb_id" ]]; then
            # If not in movie_results, check if it's a TV show
            local tv_check=$(echo "$result" | grep -oE '"tv_results":\[')
            if [[ -n "$tv_check" ]]; then
                should_debug high && echo "[DEBUG] IMDb ID $imdb_id is cataloged as a TV show/miniseries" >&2
                # Don't reject - many miniseries should be processed as movies
                # Continue with normal processing
            fi
        fi
        
        if [[ -n "$tmdb_id" ]]; then
            print_success "Found TMDb ID via /find endpoint: $tmdb_id" >&2
            # Get full details in one call
            should_debug high && echo "[DEBUG] Fetching full movie details for TMDb ID: $tmdb_id" >&2
            api_delay
            local details_url="${TMDB_API_BASE}/movie/${tmdb_id}?api_key=${TMDB_API_KEY}&append_to_response=external_ids"
            local details=$(curl -s --connect-timeout 10 --max-time 30 "$details_url" 2>/dev/null)
            
            # Save JSON to database (only in hybrid mode - api_only skips DB for performance)
            if [[ -n "$details" && "$JSON_DB_MODE" == "hybrid" ]]; then
                save_json_to_db "$tmdb_id" "$imdb_id" "$details"
                should_debug high && echo "[DEBUG] Saved TMDb JSON to database: TMDb ID $tmdb_id, IMDb ID $imdb_id" >&2
            fi
            
            echo "$details"
            return 0
        else
            should_debug high && echo "[DEBUG] TMDb /find endpoint returned no results" >&2
        fi
    fi
    
    # Fallback to title search using API
    if [[ -n "$year" ]]; then
        print_info "Searching TMDb API for: $title ($year)..." >&2
    else
        print_info "Searching TMDb API for: $title (no year filter)..." >&2
    fi
    api_delay
    
    # Transliterate title for better international character support
    local search_title="$title"
    search_title=$(echo "$search_title" | sed 'y/àáâãäåèéêëìíîïòóôõöùúûüýÿñçÀÁÂÃÄÅÈÉÊËÌÍÎÏÒÓÔÕÖÙÚÛÜÝŸÑÇ/aaaaaaeeeeiiiiooooouuuuyyncAAAAAAEEEEIIIIOOOOOUUUUYYNC/')
    
    local encoded_title=$(url_encode "$search_title")
    # Only include year parameter if year is provided
    if [[ -n "$year" ]]; then
        local search_url="${TMDB_API_BASE}/search/movie?api_key=${TMDB_API_KEY}&query=${encoded_title}&year=${year}"
    else
        local search_url="${TMDB_API_BASE}/search/movie?api_key=${TMDB_API_KEY}&query=${encoded_title}"
    fi
    local masked_key="${TMDB_API_KEY:0:8}...${TMDB_API_KEY: -4}"
    local masked_url="${search_url//$TMDB_API_KEY/$masked_key}"
    should_debug high && echo "[DEBUG] TMDb search URL: $masked_url" >&2
    local result=$(curl -s --connect-timeout 10 --max-time 30 "$search_url" 2>/dev/null)
    should_debug high && echo "[DEBUG] TMDb search response: $result" >&2
    
    # Check if there are multiple results
    local result_count=$(echo "$result" | grep -o '"id":' | wc -l | tr -d ' ')
    should_debug high && echo "[DEBUG] TMDb returned $result_count result(s)" >&2
    
    # Validate single result - even with 1 result, verify year matches
    if [[ "$result_count" -eq 1 ]]; then
        local candidate_year=$(echo "$result" | grep -oE '"release_date":"[0-9]{4}' | head -1 | grep -oE '[0-9]{4}')
        should_debug high && echo "[DEBUG] Single result validation: candidate year=$candidate_year, expected=$year" >&2
        
        # Reject if year is off by more than 2 years (allows for re-releases and date variations)
        if [[ -n "$candidate_year" ]]; then
            local year_diff=$((year > candidate_year ? year - candidate_year : candidate_year - year))
            if [[ $year_diff -gt 2 ]]; then
                echo "[WARNING] Single result has wrong year (got $candidate_year, expected $year) - treating as no match" >&2
                result_count=0  # Force fallback to alternate searches
            fi
        fi
    fi
    
    # Use runtime matching for disambiguation when needed
    # - 1 result with correct year: Accept it
    # - 2+ results: Use runtime matching if available, but ONLY if at least one result has matching title
    if [[ "$result_count" -ge 2 ]]; then
        print_warning "Found $result_count movies with similar name" >&2
        
        # Check if ANY result has a title that reasonably matches the search query
        # Extract titles from results and check for at least partial match
        local has_reasonable_match=false
        local title_lower=$(echo "$title" | tr '[:upper:]' '[:lower:]')
        while IFS= read -r result_title; do
            local result_title_lower=$(echo "$result_title" | tr '[:upper:]' '[:lower:]')
            # Check if search title is substantially contained in result title or vice versa
            if [[ "$result_title_lower" == *"$title_lower"* ]] || [[ "$title_lower" == *"$result_title_lower"* ]]; then
                has_reasonable_match=true
                break
            fi
        done < <(echo "$result" | grep -oE '"title":"[^"]+' | sed 's/"title":"//' | head -10)
        
        if [[ "$has_reasonable_match" == "false" ]]; then
            should_debug high && echo "[DEBUG] No reasonable title matches in results - rejecting all candidates to prevent false matches" >&2
            result_count=0  # Force fallback to alternate searches
        fi
        
        # Try runtime matching for disambiguation (only if we have reasonable candidates)
        local runtime_matched_id=""
        if [[ "$result_count" -ge 2 && -n "$SOURCE_FILE_FOR_RUNTIME" ]]; then
            runtime_matched_id=$(search_tmdb_with_runtime "$title" "$year" "$SOURCE_FILE_FOR_RUNTIME" "$result")
            
            if [[ -n "$runtime_matched_id" ]]; then
                # Use the runtime-matched TMDb ID instead of first search result
                local tmdb_id="$runtime_matched_id"
                print_success "Using runtime-matched TMDb ID: $tmdb_id" >&2
                
                # Get full details for the runtime-matched movie
                should_debug high && echo "[DEBUG] Fetching full movie details for runtime-matched TMDb ID: $tmdb_id" >&2
                api_delay
                local details_url="${TMDB_API_BASE}/movie/${tmdb_id}?api_key=${TMDB_API_KEY}&append_to_response=external_ids"
                local details=$(curl -s --connect-timeout 10 --max-time 30 "$details_url" 2>/dev/null)
                
                # Save JSON to database if we got valid data (only in hybrid mode)
                if [[ -n "$details" && "$JSON_DB_MODE" == "hybrid" ]]; then
                    local imdb_from_details=$(extract_imdb_from_details "$details")
                    save_json_to_db "$tmdb_id" "$imdb_from_details" "$details"
                    should_debug high && echo "[DEBUG] Saved TMDb JSON to database: TMDb ID $tmdb_id, IMDb ID $imdb_from_details" >&2
                fi
                
                echo "$details"
                return 0
            fi
        fi
        
        # No runtime match found - skip to post-processing
        print_warning "Runtime matching failed - skipping for post-processing" >&2
        echo ""
        return 1
    fi
    
    # Only extract tmdb_id if validation passed (result_count > 0)
    local tmdb_id=""
    if [[ "$result_count" -ge 1 ]]; then
        tmdb_id=$(echo "$result" | grep -oE '"id":[0-9]+' | head -1 | grep -oE '[0-9]+')
    fi
    
    # If not found or validation failed, try various fallback searches
    if [[ -z "$tmdb_id" && -n "$year" ]]; then
        # Try 1: Title with year appended (e.g., "Wonder Woman 1984") - only if year is available
        local title_with_year="${title} ${year}"
        should_debug high && echo "[DEBUG] Trying alternate search with year in title: $title_with_year" >&2
        api_delay
        
        encoded_title=$(url_encode "$title_with_year")
        search_url="${TMDB_API_BASE}/search/movie?api_key=${TMDB_API_KEY}&query=${encoded_title}&year=${year}"
        masked_url="${search_url//$TMDB_API_KEY/$masked_key}"
        should_debug high && echo "[DEBUG] TMDb alternate search URL: $masked_url" >&2
        result=$(curl -s --connect-timeout 10 --max-time 30 "$search_url" 2>/dev/null)
        should_debug high && echo "[DEBUG] TMDb alternate search response: $result" >&2
        tmdb_id=$(echo "$result" | grep -oE '"id":[0-9]+' | head -1 | grep -oE '[0-9]+')
    fi
    
    # Try 2: Remove colon and subtitle (e.g., "Mechanic: Resurrection" → "Mechanic Resurrection")
    if [[ -z "$tmdb_id" && "$title" =~ : ]]; then
        local title_no_colon="${title//:/ }"
        # Remove multiple spaces
        title_no_colon=$(echo "$title_no_colon" | sed 's/  */ /g' | sed 's/^ *//' | sed 's/ *$//')
        should_debug high && echo "[DEBUG] Trying search without colon: $title_no_colon" >&2
        api_delay
        
        encoded_title=$(url_encode "$title_no_colon")
        search_url="${TMDB_API_BASE}/search/movie?api_key=${TMDB_API_KEY}&query=${encoded_title}&year=${year}"
        result=$(curl -s --connect-timeout 10 --max-time 30 "$search_url" 2>/dev/null)
        should_debug high && echo "[DEBUG] TMDb search without colon response: $result" >&2
        tmdb_id=$(echo "$result" | grep -oE '"id":[0-9]+' | head -1 | grep -oE '[0-9]+')
        
        # If still no result and title starts with "The ", try without it
        if [[ -z "$tmdb_id" && "$title_no_colon" =~ ^The[[:space:]] ]]; then
            local title_no_the="${title_no_colon#The }"
            title_no_the="${title_no_the#the }"
            should_debug high && echo "[DEBUG] Trying without 'The' prefix: $title_no_the" >&2
            api_delay
            
            encoded_title=$(url_encode "$title_no_the")
            search_url="${TMDB_API_BASE}/search/movie?api_key=${TMDB_API_KEY}&query=${encoded_title}&year=${year}"
            result=$(curl -s --connect-timeout 10 --max-time 30 "$search_url" 2>/dev/null)
            should_debug high && echo "[DEBUG] TMDb search without 'The' response: $result" >&2
            tmdb_id=$(echo "$result" | grep -oE '"id":[0-9]+' | head -1 | grep -oE '[0-9]+')
        fi
        
        if [[ -n "$tmdb_id" ]]; then
            should_debug high && echo "[DEBUG] Found TMDb ID: $tmdb_id" >&2
        fi
    fi
    
    # Try 3: Just the main title before colon - BUT verify year matches
    if [[ -z "$tmdb_id" && "$title" =~ : ]]; then
        local main_title="${title%%:*}"
        main_title="${main_title#"${main_title%%[![:space:]]*}"}"
        main_title="${main_title%"${main_title##*[![:space:]]}"}"
        should_debug high && echo "[DEBUG] Trying search with main title only: $main_title" >&2
        api_delay
        
        encoded_title=$(url_encode "$main_title")
        search_url="${TMDB_API_BASE}/search/movie?api_key=${TMDB_API_KEY}&query=${encoded_title}&year=${year}"
        result=$(curl -s --connect-timeout 10 --max-time 30 "$search_url" 2>/dev/null)
        
        # Extract ID and verify the year matches (don't accept wrong year)
        local candidate_id=$(echo "$result" | grep -oE '"id":[0-9]+' | head -1 | grep -oE '[0-9]+')
        if [[ -n "$candidate_id" ]]; then
            local candidate_year=$(echo "$result" | grep -oE '"release_date":"[0-9]{4}' | head -1 | grep -oE '[0-9]{4}')
            should_debug high && echo "[DEBUG] Main title search found TMDb ID $candidate_id with year $candidate_year (expected $year)" >&2
            if [[ "$candidate_year" == "$year" ]]; then
                # Don't accept this - it's likely a wrong match since main title is too generic
                # Let IMDb search handle it instead
                should_debug high && echo "[DEBUG] Skipping main title match - too generic, will try IMDb instead" >&2
            else
                should_debug high && echo "[DEBUG] Wrong year - skipping" >&2
            fi
        fi
    fi
    
    if [[ -n "$tmdb_id" ]]; then
        print_success "Found TMDb ID via search: $tmdb_id" >&2
        # Get full details in one call (includes IMDb ID, title, runtime, year)
        should_debug high && echo "[DEBUG] Fetching full movie details for TMDb ID: $tmdb_id" >&2
        api_delay
        local details_url="${TMDB_API_BASE}/movie/${tmdb_id}?api_key=${TMDB_API_KEY}&append_to_response=external_ids"
        local details=$(curl -s --connect-timeout 10 --max-time 30 "$details_url" 2>/dev/null)
        
        # Save JSON to database if we got valid data (only in hybrid mode - api_only skips DB for performance)
        if [[ -n "$details" && "$JSON_DB_MODE" == "hybrid" ]]; then
            local extracted_imdb=$(extract_imdb_from_details "$details")
            save_json_to_db "$tmdb_id" "$extracted_imdb" "$details"
            should_debug high && echo "[DEBUG] Saved TMDb JSON to database: TMDb ID $tmdb_id, IMDb ID $extracted_imdb" >&2
        fi
        
        echo "$details"
    else
        should_debug high && echo "[DEBUG] TMDb search returned no results" >&2
    fi
}

# Auto-select TMDb ID from multiple results using runtime matching
# Reliability: High (80-90%) when file runtime is available
# - Compares video file runtime against TMDb movie runtimes
# - Uses ±10 minute tolerance for different cuts (theatrical/extended/director's)
# - Selects best match within tolerance
# - Falls back to post-processing if no match found
search_tmdb_with_runtime() {
    local title="$1"
    local year="$2"
    local file_path="$3"
    local result="$4"  # JSON response from TMDb search
    
    # Get runtime from video file
    local file_runtime=""
    if [[ -n "$file_path" && -f "$file_path" ]]; then
        file_runtime=$(get_file_runtime "$file_path")
    fi
    
    if [[ -z "$file_runtime" ]]; then
        should_debug high && echo "[DEBUG] No file runtime available for matching" >&2
        return 1
    fi
    
    print_info "File runtime: ${file_runtime} minutes - attempting auto-match..." >&2
    
    # Extract all TMDb IDs from the results
    local -a tmdb_ids=()
    while IFS= read -r id; do
        [[ -n "$id" ]] && tmdb_ids+=("$id")
    done < <(echo "$result" | grep -oE '"id":[0-9]+' | grep -oE '[0-9]+')
    
    if [[ ${#tmdb_ids[@]} -eq 0 ]]; then
        return 1
    fi
    
    # Limit API calls to prevent rate limiting and reduce processing time
    local max_checks=8  # Maximum number of candidates to check
    local checked_count=0
    
    # Prioritize candidates by year match and popularity (TMDb returns results by popularity)
    # Check first few results (most popular) and any that match the target year
    local -a priority_ids=()
    local -a other_ids=()
    
    # Parse results more carefully to avoid multi-line year extraction
    local -a all_ids=()
    while IFS= read -r id; do
        [[ -n "$id" ]] && all_ids+=("$id")
    done < <(echo "$result" | grep -oE '"id":[0-9]+' | grep -oE '[0-9]+')
    
    # For each TMDb ID, extract its year individually
    for tmdb_id in "${all_ids[@]}"; do
        [[ ${#priority_ids[@]} -ge 10 && ${#other_ids[@]} -ge 10 ]] && break  # Limit parsing
        
        # Extract year for this specific movie from the JSON result
        local movie_json=$(echo "$result" | grep -E '"id":$tmdb_id[^0-9]')
        local tmdb_year=$(echo "$movie_json" | grep -oE '"release_date":"[0-9]{4}' | grep -oE '[0-9]{4}' | head -1)
        
        if [[ -n "$tmdb_year" && "$tmdb_year" =~ ^[0-9]{4}$ ]]; then
            # Prioritize movies from target year ±1
            local year_diff=$((year - tmdb_year))
            [[ $year_diff -lt 0 ]] && year_diff=$((-year_diff))
            
            if [[ $year_diff -le 1 ]]; then
                priority_ids+=("$tmdb_id")
            else
                other_ids+=("$tmdb_id")
            fi
        else
            # No year found, treat as other
            other_ids+=("$tmdb_id")
        fi
    done
    
    # Combine arrays: year matches first, then popular ones
    local -a candidates=("${priority_ids[@]}" "${other_ids[@]}")
    local total_candidates=${#candidates[@]}
    
    # Use fallback if parsing failed
    if [[ $total_candidates -eq 0 ]]; then
        while IFS= read -r id && [[ ${#candidates[@]} -lt 10 ]]; do
            [[ -n "$id" ]] && candidates+=("$id")
        done < <(echo "$result" | grep -oE '"id":[0-9]+' | grep -oE '[0-9]+' | head -10)
        total_candidates=${#candidates[@]}
    fi
    
    print_info "Checking ${total_candidates} candidates (max $max_checks) for runtime match..." >&2
    
    # Normalize search title for comparison
    local normalized_search_title=$(echo "$title" | iconv -f UTF-8 -t ASCII//TRANSLIT 2>/dev/null | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]//g')
    
    # Check candidates with API call limit
    local best_match_id=""
    local best_match_diff=999
    local best_match_is_exact=false
    local tolerance=10  # ±10 minutes tolerance
    local exact_matches=0  # Count of title+year matches
    
    for tmdb_id in "${candidates[@]}"; do
        # Check for interrupt during API calls
        check_interrupt
        
        # Stop if we've checked enough candidates
        if [[ $checked_count -ge $max_checks ]]; then
            should_debug high && echo "[DEBUG] Reached API call limit ($max_checks), stopping search" >&2
            break
        fi
        
        ((checked_count++))
        sleep 0.2  # Reduced rate limiting since we're making fewer calls
        
        # Get movie details including runtime
        local details_url="${TMDB_API_BASE}/movie/${tmdb_id}?api_key=${TMDB_API_KEY}"
        local details=$(curl -s --connect-timeout 10 --max-time 30 "$details_url" 2>/dev/null)
        
        local tmdb_runtime=$(echo "$details" | grep -oE '"runtime":[0-9]+' | grep -oE '[0-9]+')
        local tmdb_title=$(echo "$details" | grep -oE '"title":"[^"]*"' | sed 's/"title":"//;s/"//' | head -1)
        local tmdb_year=$(echo "$details" | grep -oE '"release_date":"[0-9]{4}' | grep -oE '[0-9]{4}' | head -1)
        
        # Normalize TMDb title for comparison
        local normalized_tmdb_title=$(echo "$tmdb_title" | iconv -f UTF-8 -t ASCII//TRANSLIT 2>/dev/null | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]//g')
        
        # Check if title AND year match exactly (±1 year tolerance for regional releases)
        local year_diff=$((year - tmdb_year))
        [[ $year_diff -lt 0 ]] && year_diff=$((-year_diff))
        local is_exact_match=false
        local year_note=""
        if [[ "$normalized_search_title" == "$normalized_tmdb_title" ]] && [[ $year_diff -le 1 ]]; then
            is_exact_match=true
            ((exact_matches++))
            # Add note if year differs (international/festival release)
            if [[ $year_diff -eq 1 ]]; then
                year_note=" (±1 year: likely international/festival release)"
            fi
        fi
        
        if [[ -n "$tmdb_runtime" ]]; then
            local diff=$((file_runtime - tmdb_runtime))
            [[ $diff -lt 0 ]] && diff=$((-diff))  # Absolute value
            
            # Show match status in debug
            if [[ "$is_exact_match" == "true" ]]; then
                should_debug high && echo "[DEBUG]   TMDb ID $tmdb_id: \"$tmdb_title\" (${tmdb_year}) ✓ EXACT MATCH${year_note} - Runtime: ${tmdb_runtime}min (diff: ${diff}min)" >&2
            else
                should_debug high && echo "[DEBUG]   TMDb ID $tmdb_id: \"$tmdb_title\" (${tmdb_year}) - Runtime: ${tmdb_runtime}min (diff: ${diff}min)" >&2
            fi
            
            # Improved matching logic for batch processing:
            # 1. ALWAYS prioritize exact title+year matches (regardless of runtime)
            # 2. For exact title+year matches, prefer better runtime
            # 3. Only consider non-exact titles if no exact title matches exist AND runtime is very close
            
            local should_consider=false
            
            if [[ "$is_exact_match" == "true" ]]; then
                # Exact title+year match - ALWAYS consider, even with large runtime diff
                should_consider=true
            elif [[ $exact_matches -eq 0 && $diff -le 5 ]]; then
                # No exact title matches found, but runtime is very close (≤5 min)
                # This helps when title parsing failed but runtime is spot-on
                should_consider=true
            fi
            
            if [[ "$should_consider" == "true" ]]; then
                # Scoring: Exact title match is MOST important, runtime is secondary
                local score=$diff
                
                # Huge penalty for non-exact matches - ensures exact titles always win
                if [[ "$is_exact_match" != "true" ]]; then
                    score=$((diff + 1000))  # Non-exact titles get huge penalty
                fi
                
                if [[ $score -lt $best_match_diff || -z "$best_match_id" ]]; then
                    best_match_diff=$diff
                    best_match_id="$tmdb_id"
                    best_match_is_exact="$is_exact_match"
                fi
                
                # Early exit conditions to save API calls
                if [[ $diff -le 2 ]]; then
                    should_debug high && echo "[DEBUG] Found excellent runtime match (${diff}min diff), stopping search early" >&2
                    break
                elif [[ "$is_exact_match" == "true" && $diff -le 5 ]]; then
                    should_debug high && echo "[DEBUG] Found good exact title+runtime match (${diff}min diff), stopping search early" >&2
                    break
                elif [[ $checked_count -ge 5 && $diff -le 5 ]]; then
                    should_debug high && echo "[DEBUG] Found acceptable match after checking $checked_count candidates (${diff}min diff), stopping search" >&2
                    break
                fi
            fi
        fi
    done
    
    # Prioritize TMDb matches over IMDb fallback - be more generous with runtime tolerance
    # This prevents falling back to IMDb autocomplete which often gives wrong results
    local runtime_tolerance=15  # More generous for TMDb matching
    
    # Auto-select if we found any reasonable match from TMDb
    if [[ $exact_matches -eq 0 && -z "$best_match_id" ]]; then
        # Try again with more generous runtime tolerance to avoid IMDb fallback
        for tmdb_id in "${candidates[@]}"; do
            [[ $checked_count -ge $max_checks ]] && break
            ((checked_count++))
            
            local details_url="${TMDB_API_BASE}/movie/${tmdb_id}?api_key=${TMDB_API_KEY}"
            local details=$(curl -s --connect-timeout 10 --max-time 30 "$details_url" 2>/dev/null)
            local tmdb_runtime=$(echo "$details" | grep -oE '"runtime":[0-9]+' | grep -oE '[0-9]+')
            
            if [[ -n "$tmdb_runtime" ]]; then
                local diff=$((file_runtime - tmdb_runtime))
                [[ $diff -lt 0 ]] && diff=$((-diff))
                
                if [[ $diff -le $runtime_tolerance ]]; then
                    best_match_id="$tmdb_id"
                    best_match_diff=$diff
                    best_match_is_exact=false
                    should_debug high && echo "[DEBUG] Found acceptable TMDb match with generous tolerance: TMDb ID $tmdb_id (${diff}min diff)" >&2
                    break
                fi
            fi
        done
        
        if [[ -z "$best_match_id" ]]; then
            should_debug high && echo "[DEBUG] No TMDb matches found within ${runtime_tolerance}min tolerance - will skip to prevent IMDb mismatches" >&2
            return 1
        fi
    fi
    
    if [[ -n "$best_match_id" ]]; then
        if [[ "$best_match_is_exact" == "true" ]]; then
            print_success "Auto-selected TMDb ID $best_match_id (exact title+year match, runtime diff: ${best_match_diff}min)" >&2
        else
            print_success "Auto-selected TMDb ID $best_match_id (closest runtime match: ${best_match_diff}min difference)" >&2
        fi
        echo "$best_match_id"
        return 0
    fi
    
    print_warning "No runtime match found within ${tolerance}min tolerance" >&2
    return 1
}

# ═══════════════════════════════════════════════════════════════════════════════
# JSON DATABASE FUNCTIONS
# ═══════════════════════════════════════════════════════════════════════════════
# Store full TMDb API JSON responses for recovery if cache is deleted
# Format: tmdb_id|imdb_id|base64_encoded_json
# ═══════════════════════════════════════════════════════════════════════════════

# Save TMDb JSON to database
save_json_to_db() {
    local tmdb_id="$1"
    local imdb_id="$2"
    local json_data="$3"
    
    [[ -z "$tmdb_id" || -z "$JSON_DB_FILE" ]] && return 1
    
    # Encode JSON as base64 to avoid parsing issues
    local encoded_json=$(echo "$json_data" | base64)
    
    # Check if entry already exists
    if [[ -f "$JSON_DB_FILE" ]]; then
        local existing=$(grep -E "^${tmdb_id}\\|" "$JSON_DB_FILE")
        if [[ -n "$existing" ]]; then
            should_debug high && echo "[DEBUG] JSON already in database for TMDb ID: $tmdb_id" >&2
            return 0
        fi
    fi
    
    # Append to database
    echo "${tmdb_id}|${imdb_id}|${encoded_json}" >> "$JSON_DB_FILE"
    should_debug high && echo "[DEBUG] Saved JSON to database for TMDb ID: $tmdb_id" >&2
    return 0
}

# Retrieve TMDb JSON from database by TMDb ID
get_json_from_db_by_tmdb() {
    local tmdb_id="$1"
    
    [[ -z "$tmdb_id" || -z "$JSON_DB_FILE" || ! -f "$JSON_DB_FILE" ]] && return 1
    
    local entry=$(grep -E "^${tmdb_id}\\|" "$JSON_DB_FILE" | head -1)
    [[ -z "$entry" ]] && return 1
    
    # Extract base64 encoded JSON (third field)
    local encoded_json=$(echo "$entry" | cut -d'|' -f3)
    
    # Decode and return
    echo "$encoded_json" | base64 -d
    return 0
}

# Retrieve TMDb JSON from database by IMDb ID
get_json_from_db_by_imdb() {
    local imdb_id="$1"
    
    [[ -z "$imdb_id" || -z "$JSON_DB_FILE" || ! -f "$JSON_DB_FILE" ]] && return 1
    
    local entry=$(grep -E "\\|${imdb_id}\\|" "$JSON_DB_FILE" | head -1)
    [[ -z "$entry" ]] && return 1
    
    # Extract base64 encoded JSON (third field)
    local encoded_json=$(echo "$entry" | cut -d'|' -f3)
    
    # Decode and return
    echo "$encoded_json" | base64 -d
    return 0
}

# Search JSON database by title and year (returns TMDb ID if found)
# OPTIMIZED: Uses grep/sed for maximum compatibility and speed
get_tmdb_id_from_json_by_title_year() {
    local search_title="$1"
    local search_year="$2"
    local source_file="$3"  # Optional: for runtime matching as disambiguation
    
    [[ -z "$search_title" || -z "$search_year" || -z "$JSON_DB_FILE" || ! -f "$JSON_DB_FILE" ]] && return 1
    
    # Normalize search title (lowercase, remove special chars, trim spaces)
    local normalized_search=$(echo "$search_title" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9 ]//g' | sed 's/  */ /g' | sed 's/^ //;s/ $//')
    
    # Get file runtime if source file provided (for disambiguation only)
    local file_runtime=""
    if [[ -n "$source_file" && -f "$source_file" ]]; then
        file_runtime=$(get_video_runtime "$source_file" 2>/dev/null)
    fi
    
    # Store potential matches
    local exact_match=""
    local first_prefix_match=""
    local best_runtime_match=""
    local best_runtime_diff=9999
    
    # Read through database line by line
    while IFS='|' read -r tmdb_id imdb_id encoded_json; do
        [[ -z "$tmdb_id" || -z "$encoded_json" ]] && continue
        
        # Decode JSON
        local json_data=$(echo "$encoded_json" | base64 -d 2>/dev/null)
        [[ -z "$json_data" ]] && continue
        
        # Extract year - check if it matches first (fast filter)
        local json_year=$(echo "$json_data" | grep -oE '"release_date":"[0-9]{4}' | head -1 | grep -oE '[0-9]{4}')
        [[ "$json_year" != "$search_year" ]] && continue
        
        # Year matches - now extract and normalize title
        local json_title=$(echo "$json_data" | grep -oE '"title":"[^"]*"' | head -1 | sed 's/"title":"//;s/"//')
        [[ -z "$json_title" ]] && continue
        
        # Normalize title
        local normalized_json=$(echo "$json_title" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9 ]//g' | sed 's/  */ /g' | sed 's/^ //;s/ $//')
        
        # Check for exact match (highest priority)
        if [[ "$normalized_search" == "$normalized_json" ]]; then
            exact_match="$tmdb_id"
            break
        # Check if search title is at the start of database title (e.g., "13" matches "13 tzameti")
        elif [[ "$normalized_json" == "$normalized_search "* ]]; then
            # Store first prefix match
            [[ -z "$first_prefix_match" ]] && first_prefix_match="$tmdb_id"
            
            # Also track best runtime match if available
            if [[ -n "$file_runtime" ]]; then
                local json_runtime=$(echo "$json_data" | grep -oE '"runtime":[0-9]+' | grep -oE '[0-9]+')
                if [[ -n "$json_runtime" ]]; then
                    local diff=$((file_runtime > json_runtime ? file_runtime - json_runtime : json_runtime - file_runtime))
                    if [[ $diff -lt $best_runtime_diff ]]; then
                        best_runtime_diff=$diff
                        best_runtime_match="$tmdb_id"
                    fi
                fi
            fi
        # Also check if database title contains search title (e.g., "education of sonny" matches "the education of sonny carson")
        # Only for search terms 4+ chars to avoid false matches
        elif [[ "$normalized_json" == *"$normalized_search"* && ${#normalized_search} -ge 4 ]]; then
            # Store first substring match (lower priority than prefix match)
            [[ -z "$first_prefix_match" ]] && first_prefix_match="$tmdb_id"
            
            # Also track best runtime match if available
            if [[ -n "$file_runtime" ]]; then
                local json_runtime=$(echo "$json_data" | grep -oE '"runtime":[0-9]+' | grep -oE '[0-9]+')
                if [[ -n "$json_runtime" ]]; then
                    local diff=$((file_runtime > json_runtime ? file_runtime - json_runtime : json_runtime - file_runtime))
                    if [[ $diff -lt $best_runtime_diff ]]; then
                        best_runtime_diff=$diff
                        best_runtime_match="$tmdb_id"
                    fi
                fi
            fi
        fi
    done < "$JSON_DB_FILE"
    
    # Return exact match if found (highest priority)
    if [[ -n "$exact_match" ]]; then
        echo "$exact_match"
        return 0
    fi
    
    # If we have runtime match and it's close (within 15 min), prefer it
    if [[ -n "$best_runtime_match" && $best_runtime_diff -le 15 ]]; then
        should_debug high && echo "[DEBUG] JSON DB: Using runtime match for '$search_title' ($search_year): TMDb $best_runtime_match (diff: ${best_runtime_diff}min)" >&2
        echo "$best_runtime_match"
        return 0
    fi
    
    # Otherwise return first prefix match (e.g., "13" finds "13 Tzameti")
    if [[ -n "$first_prefix_match" ]]; then
        should_debug high && echo "[DEBUG] JSON DB: Using prefix match for '$search_title' ($search_year): TMDb $first_prefix_match" >&2
        echo "$first_prefix_match"
        return 0
    fi
    
    return 1
}

# TV Show JSON Database Functions
# ═══════════════════════════════════════════════════════════════════════════════

# Save TMDb TV JSON to database
save_tv_json_to_db() {
    local tmdb_id="$1"
    local imdb_id="$2"
    local json_data="$3"
    local tv_cache_mode="$4"  # Pass the cache mode to determine which DB file to use
    
    [[ -z "$tmdb_id" ]] && return 1
    
    # Determine which TV JSON database file to use
    local db_file
    case "$tv_cache_mode" in
        cartoons) db_file="$CARTOON_TV_JSON_DB_FILE" ;;
        anime) db_file="$ANIME_TV_JSON_DB_FILE" ;;
        *) db_file="$TV_JSON_DB_FILE" ;;
    esac
    
    [[ -z "$db_file" ]] && return 1
    
    # Encode JSON as base64 to avoid parsing issues
    local encoded_json=$(echo "$json_data" | base64)
    
    # Check if entry already exists
    if [[ -f "$db_file" ]]; then
        local existing=$(grep -E "^${tmdb_id}\|" "$db_file")
        if [[ -n "$existing" ]]; then
            should_debug high && echo "[DEBUG] TV JSON already in database for TMDb ID: $tmdb_id" >&2
            return 0
        fi
    fi
    
    # Create directory if it doesn't exist
    mkdir -p "$(dirname "$db_file")"
    
    # Append to database
    echo "${tmdb_id}|${imdb_id}|${encoded_json}" >> "$db_file"
    should_debug high && echo "[DEBUG] Saved TV JSON to database for TMDb ID: $tmdb_id" >&2
    return 0
}

# Retrieve TMDb TV JSON from database by TMDb ID
get_tv_json_from_db_by_tmdb() {
    local tmdb_id="$1"
    local tv_cache_mode="$2"
    
    [[ -z "$tmdb_id" ]] && return 1
    
    # Determine which TV JSON database file to use
    local db_file
    case "$tv_cache_mode" in
        cartoons) db_file="$CARTOON_TV_JSON_DB_FILE" ;;
        anime) db_file="$ANIME_TV_JSON_DB_FILE" ;;
        *) db_file="$TV_JSON_DB_FILE" ;;
    esac
    
    [[ -z "$db_file" || ! -f "$db_file" ]] && return 1
    
    local entry=$(grep -E "^${tmdb_id}\|" "$db_file" | head -1)
    [[ -z "$entry" ]] && return 1
    
    # Extract base64 encoded JSON (third field)
    local encoded_json=$(echo "$entry" | cut -d'|' -f3)
    
    # Decode and return
    echo "$encoded_json" | base64 -d
    return 0
}

# Retrieve TMDb TV JSON from database by IMDb ID
get_tv_json_from_db_by_imdb() {
    local imdb_id="$1"
    local tv_cache_mode="$2"
    
    [[ -z "$imdb_id" ]] && return 1
    
    # Determine which TV JSON database file to use
    local db_file
    case "$tv_cache_mode" in
        cartoons) db_file="$CARTOON_TV_JSON_DB_FILE" ;;
        anime) db_file="$ANIME_TV_JSON_DB_FILE" ;;
        *) db_file="$TV_JSON_DB_FILE" ;;
    esac
    
    [[ -z "$db_file" || ! -f "$db_file" ]] && return 1
    
    local entry=$(grep -E "\|${imdb_id}\|" "$db_file" | head -1)
    [[ -z "$entry" ]] && return 1
    
    # Extract base64 encoded JSON (third field)
    local encoded_json=$(echo "$entry" | cut -d'|' -f3)
    
    # Decode and return
    echo "$encoded_json" | base64 -d
    return 0
}

# Extract IMDb ID from movie details JSON
# Takes full movie details JSON as input
extract_imdb_from_details() {
    local details="$1"
    # Try external_ids first (from append_to_response)
    local imdb_id=$(echo "$details" | grep -oE '"imdb_id":"tt[0-9]+"' | head -1 | grep -oE 'tt[0-9]+')
    echo "$imdb_id"
}

# Extract title from movie details JSON
extract_title_from_details() {
    local details="$1"
    local title=$(echo "$details" | grep -oE '"title":"[^"]*"' | head -1 | sed 's/"title":"//;s/"//')
    
    # Decode HTML entities safely - handle empty/problematic input
    if [[ -n "$title" && ! "$title" =~ ^[[:space:]]*$ ]]; then
        # Use printf to avoid sed issues with special characters
        title=$(printf '%s\n' "$title" | sed 's/&quot;/"/g; s/&#39;/'\''/g; s/&amp;/\&/g; s/&lt;/</g; s/&gt;/>/g; s/&apos;/'\''/g' 2>/dev/null || echo "$title")
    fi
    
    echo "$title"
}

# Extract TMDb ID from movie details JSON
extract_tmdb_id_from_details() {
    local details="$1"
    # Extract movie ID by looking for "id" field that appears at top level
    # Pattern: ,"id":6077, or "id":6077," (with quotes/commas as boundaries)
    # This distinguishes it from genre IDs which are inside [{"id":28}]
    local tmdb_id=$(echo "$details" | grep -oE ',"id":[0-9]+,|^"id":[0-9]+,' | head -1 | grep -oE '[0-9]+')
    # Fallback: if that didn't work, try looking for pattern before "imdb_id"
    if [[ -z "$tmdb_id" ]]; then
        tmdb_id=$(echo "$details" | grep -oE '"id":[0-9]+,"imdb_id"' | grep -oE '[0-9]+' | head -1)
    fi
    echo "$tmdb_id"
}

# Extract year from movie details JSON
extract_year_from_details() {
    local details="$1"
    # Extract release_date and get year
    local release_date=$(echo "$details" | grep -oE '"release_date":"[0-9]{4}-[0-9]{2}-[0-9]{2}"' | head -1 | grep -oE '[0-9]{4}')
    echo "$release_date"
}

# Extract title from TV show details JSON (same pattern as movies)
extract_title_from_tv_details() {
    local details="$1"
    # TV shows use "name" instead of "title"
    local title=$(echo "$details" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('name', ''))" 2>/dev/null)
    
    # Fallback to grep if Python fails
    if [[ -z "$title" ]]; then
        title=$(echo "$details" | grep -oE '"name":"[^"]*"' | head -1 | sed 's/"name":"//;s/"$//')
    fi
    
    # Try original_name as fallback
    if [[ -z "$title" ]]; then
        title=$(echo "$details" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('original_name', ''))" 2>/dev/null)
    fi
    
    # Decode HTML entities safely
    if [[ -n "$title" && ! "$title" =~ ^[[:space:]]*$ ]]; then
        title=$(printf '%s\n' "$title" | sed "s/&quot;/\"/g; s/&#39;/'/g; s/&amp;/\&/g; s/&lt;/</g; s/&gt;/>/g; s/&apos;/'/g" 2>/dev/null || echo "$title")
    fi
    
    echo "$title"
}

# Extract year from TV show details JSON (same pattern as movies)
extract_year_from_tv_details() {
    local details="$1"
    # TV shows use "first_air_date" instead of "release_date"
    local first_air_date=$(echo "$details" | grep -oE '"first_air_date":"[0-9]{4}-[0-9]{2}-[0-9]{2}"' | head -1 | grep -oE '[0-9]{4}')
    echo "$first_air_date"
}

# Legacy function - kept for compatibility with other code
get_imdb_from_tmdb() {
    local tmdb_id="$1"
    if [[ -z "$tmdb_id" ]]; then
        should_debug high && echo "[DEBUG] get_imdb_from_tmdb: No TMDb ID provided" >&2
        return 1
    fi
    
    should_debug high && echo "[DEBUG] get_imdb_from_tmdb called: tmdb_id='$tmdb_id'" >&2
    print_info "Getting IMDb ID from TMDb API..." >&2
    api_delay
    
    local ids_url="${TMDB_API_BASE}/movie/${tmdb_id}/external_ids?api_key=${TMDB_API_KEY}"
    should_debug high && echo "[DEBUG] TMDb external_ids URL: $ids_url" >&2
    local result=$(curl -s --connect-timeout 10 --max-time 30 "$ids_url" 2>/dev/null)
    should_debug high && echo "[DEBUG] TMDb external_ids response: $result" >&2
    local imdb_id=$(echo "$result" | grep -oE '"imdb_id":"tt[0-9]+"' | grep -oE 'tt[0-9]+')
    
    if [[ -n "$imdb_id" ]]; then
        print_success "Found IMDb ID via TMDb API: $imdb_id" >&2
        echo "$imdb_id"
        return 0
    fi
    
    return 1
}

# Search IMDb autocomplete API for movie suggestions
imdb_autocomplete_search() {
    local title="$1"
    local year="$2"
    
    if [[ -z "$title" ]]; then
        return 1
    fi
    
    print_info "Searching IMDb autocomplete for: $title${year:+ ($year)}" >&2
    sleep 0.5
    
    local encoded_title=$(url_encode "$title")
    local autocomplete_url="https://v3.sg.media-imdb.com/suggestion/x/${encoded_title}.json"
    local result=$(curl -s --connect-timeout 10 --max-time 30 "$autocomplete_url" 2>/dev/null)
    
    if [[ -z "$result" ]]; then
        print_warning "No IMDb suggestions found" >&2
        return 1
    fi
    
    # Extract the "d" array and split into individual movie entries
    # Format: split on "},{"  to separate objects, then filter for movies
    local raw_entries=$(echo "$result" | sed 's/{"d":\[//; s/\],"q":"[^"]*"}$//' | sed 's/},{/}\n{/g')
    
    # Filter for feature films, TV movies, and videos only
    local suggestions=$(echo "$raw_entries" | grep -E '"q":"(feature|TV movie|video)"' | head -10)
    
    if [[ -z "$suggestions" ]]; then
        print_warning "No IMDb movie suggestions found" >&2
        return 1
    fi
    
    echo "" >&2
    echo -e "${CYAN}━━━ IMDb Autocomplete Results ━━━${NC}" >&2
    
    # Store suggestions in indexed arrays (Bash 3.2 compatible)
    local -a suggestion_ids=()
    local -a suggestion_data=()
    local idx=1
    
    while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        
        local imdb_id=$(echo "$line" | grep -oE '"id":"tt[0-9]+"' | grep -oE 'tt[0-9]+')
        local movie_title=$(echo "$line" | grep -oE '"l":"[^"]+"' | sed -E 's/"l":"([^"]+)"/\1/' | sed 's/\\u0026/\&/g')
        local movie_year=$(echo "$line" | grep -oE '"y":[0-9]+' | grep -oE '[0-9]+')
        local movie_type=$(echo "$line" | grep -oE '"q":"[^"]+"' | sed -E 's/"q":"([^"]+)"/\1/')
        local image_url=$(echo "$line" | grep -oE '"imageUrl":"[^"]+"' | sed -E 's/"imageUrl":"([^"]+)"/\1/')
        
        # Skip if we couldn't extract the ID
        [[ -z "$imdb_id" ]] && continue
        
        # Fetch runtime from IMDb (with small delay to be respectful)
        local runtime=$(get_imdb_runtime "$imdb_id")
        local runtime_display=""
        if [[ -n "$runtime" && "$runtime" != "0" ]]; then
            runtime_display=" ${GREEN}[$runtime min]${NC}"
        else
            runtime_display=" ${DIM}[runtime N/A]${NC}"
        fi
        [[ -n "$API_DELAY" ]] && sleep "$API_DELAY"
        
        # Show year if available, otherwise show "N/A"
        if [[ -n "$movie_year" ]]; then
            echo -e "  ${YELLOW}$idx.${NC} $movie_title ($movie_year) ${DIM}[$movie_type]${NC}${runtime_display} - $imdb_id" >&2
        else
            echo -e "  ${YELLOW}$idx.${NC} $movie_title ${DIM}[year N/A] [$movie_type]${NC}${runtime_display} - $imdb_id" >&2
        fi
        
        suggestion_ids+=("$imdb_id")
        suggestion_data+=("$imdb_id|$movie_title|$movie_year")
        ((idx++))
    done <<< "$suggestions"
    
    local max_idx=$((idx - 1))
    
    echo "" >&2
    echo -e "${YELLOW}Select number (1-$max_idx), enter IMDb ID (tt123456), TMDb ID (123456), or 's' to skip:${NC}" >&2
    stty echo 2>/dev/null
    read -r selection </dev/tty
    stty -echo 2>/dev/null
    
    if [[ "$selection" == "s" ]]; then
        return 1
    elif [[ "$selection" =~ ^tt[0-9]+$ ]]; then
        # User entered IMDb ID directly
        echo "$selection"
        return 0
    elif [[ "$selection" =~ ^[1-9][0-9]*$ ]] && [[ "$selection" -le "$max_idx" ]]; then
        # User selected from list (array is 0-indexed, user input is 1-indexed)
        echo "${suggestion_ids[$((selection - 1))]}"
        return 0
    elif [[ "$selection" =~ ^[0-9]{4,}$ ]]; then
        # User entered TMDb ID (4+ digits, not in range of list selection)
        # Convert TMDb to IMDb
        local imdb_from_tmdb=$(get_imdb_from_tmdb "$selection" 2>/dev/null)
        if [[ -n "$imdb_from_tmdb" ]]; then
            echo "$imdb_from_tmdb"
            return 0
        else
            print_warning "Could not find IMDb ID for TMDb ID: $selection" >&2
            return 1
        fi
    else
        # Invalid selection
        print_warning "Invalid selection" >&2
        return 1
    fi
}

# ═══════════════════════════════════════════════════════════════════════════════
# TV SHOW API SEARCH FUNCTIONS
# ═══════════════════════════════════════════════════════════════════════════════

# Count number of season folders in a directory (for season count matching)
count_season_folders() {
    local source_dir="$1"
    should_debug high && print_info "[DEBUG] count_season_folders: source_dir='$source_dir'" >&2
    
    # If source_dir is a file, get its parent directory
    if [[ -f "$source_dir" ]]; then
        source_dir=$(dirname "$source_dir")
    fi
    
    # Check if parent is a season folder - if so, use grandparent
    local parent_name=$(basename "$source_dir")
    # Match "Season ##", "S##", "Season ## (year)", etc.
    if [[ "$parent_name" =~ ^[Ss](eason[[:space:]])?[[:space:]]?[0-9]{1,2}([[:space:]]?\([0-9]{4}(-[0-9]{2,4})?\))?$ ]]; then
        source_dir=$(dirname "$source_dir")
        should_debug high && print_info "[DEBUG] count_season_folders: Parent '$parent_name' is a season folder, using grandparent: '$source_dir'" >&2
    fi
    
    # Count season folders
    local season_count=0
    if [[ -d "$source_dir" ]]; then
        # Count folders matching "Season ##" or "S##" pattern
        season_count=$(find "$source_dir" -maxdepth 1 -type d \( -iname "season [0-9]*" -o -iname "season[0-9]*" -o -iname "s[0-9]*" \) 2>/dev/null | wc -l | tr -d ' ')
    fi
    
    should_debug high && print_info "[DEBUG] count_season_folders: Found $season_count season folders in '$source_dir'" >&2
    echo "$season_count"
}

# Get number of seasons for a TMDb TV ID
get_tmdb_season_count() {
    local tmdb_id="$1"
    should_debug high && print_info "[DEBUG] get_tmdb_season_count: tmdb_id='$tmdb_id'" >&2
    
    if [[ -z "$tmdb_id" ]]; then
        echo "0"
        return 1
    fi
    
    api_delay
    local tv_url="${TMDB_API_BASE}/tv/${tmdb_id}?api_key=${TMDB_API_KEY}"
    local result=$(curl -s --connect-timeout 10 --max-time 30 "$tv_url" 2>/dev/null)
    
    # Extract number_of_seasons
    local season_count=$(echo "$result" | grep -oE '"number_of_seasons":[0-9]+' | grep -oE '[0-9]+')
    
    should_debug high && print_info "[DEBUG] get_tmdb_season_count: Found $season_count seasons for TMDb ID $tmdb_id" >&2
    echo "${season_count:-0}"
}

# Search for TV show on TMDb using API
# Tries original title first, then with letter-number spacing as fallback
search_tmdb_tv() {
    local series_title="$1"
    local year="$2"
    local source_file="$3"  # Optional: for season count matching
    should_debug high && print_info "[DEBUG] search_tmdb_tv: series_title='$series_title' year='$year' source_file='$source_file'" >&2
    
    if [[ -z "$series_title" ]]; then
        should_debug high && print_info "[DEBUG] search_tmdb_tv: Empty series_title, returning" >&2
        return 1
    fi
    
    # Build list of search variations to try:
    # 1. Original title (preserves intentional names like PEN15, SE7EN)
    # 2. Without common suffixes like "TV Series", "The Series", "The Show"
    # 3. With letter-number spacing (helps find "Inside No 9" from "Inside No9")
    local -a search_variations=("$series_title")
    
    # Add variation without common TV suffixes: "Creepshow TV Series" -> "Creepshow"
    local stripped_title=$(echo "$series_title" | sed -E 's/[[:space:]]+(TV[[:space:]]+Series|The[[:space:]]+Series|TV[[:space:]]+Show|The[[:space:]]+Show|Series|Show)$//i')
    if [[ "$stripped_title" != "$series_title" && -n "$stripped_title" ]]; then
        search_variations+=("$stripped_title")
    fi
    
    # Add spaced variation if title has letters directly followed by numbers
    if [[ "$series_title" =~ [a-zA-Z][0-9] ]]; then
        local spaced_title=$(echo "$series_title" | sed -E 's/([a-zA-Z])([0-9])/\1 \2/g')
        if [[ "$spaced_title" != "$series_title" ]]; then
            search_variations+=("$spaced_title")
        fi
    fi
    
    # Try each variation
    for search_title in "${search_variations[@]}"; do
        should_debug high && print_info "[DEBUG] Trying search variation: '$search_title'" >&2
        print_info "Searching TMDb TV API for: $search_title${year:+ ($year)}" >&2
        api_delay
        
        local encoded_title=$(url_encode "$search_title")
        local search_url="${TMDB_API_BASE}/search/tv?api_key=${TMDB_API_KEY}&query=${encoded_title}"
        
        if [[ "$DEBUG_MODE_TV" == "true" ]]; then
            local masked_key="${TMDB_API_KEY:0:8}...${TMDB_API_KEY: -4}"
            local masked_url="${search_url//$TMDB_API_KEY/$masked_key}"
            print_info "[DEBUG] TMDb TV search URL: $masked_url" >&2
        fi
        
        local result=$(curl -s --connect-timeout 10 --max-time 30 "$search_url" 2>/dev/null)
        should_debug high && print_info "[DEBUG] search_tmdb_tv: API response=$(echo "$result" | head -c 200)..." >&2
        
        # If year provided, validate results against year with ±2 year tolerance
        if [[ -n "$year" ]]; then
            # Extract all IDs and first_air_dates from results
            local -a result_ids=($(echo "$result" | grep -oE '"id":[0-9]+' | grep -oE '[0-9]+'))
            local -a result_dates=($(echo "$result" | grep -oE '"first_air_date":"[0-9]{4}-[0-9]{2}-[0-9]{2}"' | grep -oE '[0-9]{4}' | head -${#result_ids[@]}))
            
            should_debug high && print_info "[DEBUG] Found ${#result_ids[@]} results, checking years..." >&2
            
            # Find first result that matches year within ±2 tolerance
            for ((i=0; i<${#result_ids[@]}; i++)); do
                local result_id="${result_ids[$i]}"
                local result_year="${result_dates[$i]:-}"
                
                if [[ -n "$result_year" ]]; then
                    local year_diff=$((year - result_year))
                    [[ $year_diff -lt 0 ]] && year_diff=$((year_diff * -1))
                    
                    should_debug high && print_info "[DEBUG] Result $((i+1)): ID=$result_id, Year=$result_year (diff=${year_diff}y)" >&2
                    
                    if [[ $year_diff -le 2 ]]; then
                        print_success "Found TMDb TV ID via API: $result_id (year: $result_year, ±${year_diff}y)" >&2
                        echo "$result_id"
                        return 0
                    fi
                fi
            done
            
            [[ "$DEBUG_MODE_TV" == "true" ]] && print_warning "[DEBUG] No results matched year $year (±2y tolerance) for '$search_title'" >&2
        else
            # No year provided - use first result
            local tmdb_id=$(echo "$result" | grep -oE '"id":[0-9]+' | head -1 | grep -oE '[0-9]+')
            if [[ -n "$tmdb_id" ]]; then
                print_success "Found TMDb TV ID via API: $tmdb_id" >&2
                echo "$tmdb_id"
                return 0
            fi
        fi
    done
    
    print_warning "TMDb TV ID not found" >&2
    return 1
}

# Search for TV show on TVDb
search_tvdb() {
    local series_title="$1"
    local year="$2"
    should_debug high && print_info "[DEBUG] search_tvdb: ENTER series_title='$series_title' year='$year'" >&2
    
    if [[ -z "$series_title" ]]; then
        should_debug high && print_info "[DEBUG] search_tvdb: RETURN (empty title)" >&2
        return 1
    fi
    
    print_info "Searching TVDb for: $series_title${year:+ ($year)}" >&2
    api_delay
    
    local search_url="https://www.thetvdb.com/search?query=$(echo "$series_title" | sed 's/ /%20/g')"
    local result=$(curl -s -A "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36" "$search_url" 2>/dev/null)
    
    local tvdb_id=$(echo "$result" | grep -oE "/series/[^/\"]+/[0-9]+" | head -1 | grep -oE "[0-9]+$")
    
    if [[ -n "$tvdb_id" ]]; then
        print_success "Found TVDb ID: $tvdb_id" >&2
        echo "$tvdb_id"
        return 0
    fi
    
    print_warning "TVDb ID not found" >&2
    return 1
}

# Get IMDb ID for TV show from TMDb page
# Search IMDb for TV series and get IMDb ID (uses exact same method as movies with all fallbacks)
search_imdb_tv() {
    local series_title="$1"
    local year="$2"
    should_debug high && print_info "[DEBUG] search_imdb_tv: series_title='$series_title' year='$year'" >&2
    
    if [[ -z "$series_title" ]]; then
        should_debug high && print_info "[DEBUG] search_imdb_tv: Empty series_title, returning" >&2
        return 1
    fi
    
    print_info "Searching IMDb for TV series: $series_title${year:+ ($year)}" >&2
    api_delay
    
    # Try IMDb suggestion API (used by autocomplete - more reliable)
    local encoded_title=$(url_encode "$series_title")
    local search_url="https://v3.sg.media-imdb.com/suggestion/x/${encoded_title}.json"
    local result=$(curl -s -A "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36" "$search_url" 2>/dev/null)
    
    # Parse JSON response - look for entries with matching year (same as movies)
    # Format: {"id":"tt0092400","l":"Married... with Children","q":"TV series","qid":"tvSeries","y":1987}
    should_debug high && print_info "[DEBUG] search_imdb_tv: IMDb API response=$(echo "$result" | head -c 200)..." >&2
    local imdb_id=$(echo "$result" | grep -oE '\{"[^}]*"id":"(tt[0-9]{7,8})"[^}]*"y":'"$year"'\}' | grep -oE 'tt[0-9]{7,8}' | head -1)
    should_debug high && print_info "[DEBUG] search_imdb_tv: Extracted imdb_id with year match='$imdb_id'" >&2
    
    # If no exact year match, try without year requirement (first result)
    if [[ -z "$imdb_id" ]]; then
        imdb_id=$(echo "$result" | grep -oE '"id":"(tt[0-9]{7,8})"' | grep -oE 'tt[0-9]{7,8}' | head -1)
        
        # Verify the year is close (within 1 year for potential release date differences)
        if [[ -n "$imdb_id" && -n "$year" ]]; then
            local result_year=$(echo "$result" | grep -oE '"y":[0-9]{4}' | head -1 | grep -oE '[0-9]{4}')
            if [[ -n "$result_year" ]]; then
                local year_diff=$((year - result_year))
                year_diff=${year_diff#-}  # absolute value
                if [[ $year_diff -le 1 ]]; then
                    print_success "Found IMDb ID via suggestion API: $imdb_id (year $result_year)" >&2
                    echo "$imdb_id"
                    return 0
                else
                    # Year too different, don't use
                    imdb_id=""
                fi
            fi
        else
            print_success "Found IMDb ID via suggestion API: $imdb_id" >&2
            echo "$imdb_id"
            return 0
        fi
    else
        print_success "Found IMDb ID via suggestion API: $imdb_id" >&2
        echo "$imdb_id"
        return 0
    fi
    

    
    if [[ -n "$imdb_id" ]]; then
        print_success "Found IMDb ID: $imdb_id" >&2
        echo "$imdb_id"
    else
        print_warning "Could not find IMDb ID" >&2
    fi
}

get_tv_imdb_from_tmdb() {
    local tmdb_id="$1"
    should_debug high && print_info "[DEBUG] get_tv_imdb_from_tmdb: ENTER tmdb_id='$tmdb_id'" >&2
    if [[ -z "$tmdb_id" ]]; then
        should_debug high && print_info "[DEBUG] get_tv_imdb_from_tmdb: RETURN (empty tmdb_id)" >&2
        return 1
    fi
    
    print_info "Getting IMDb ID from TMDb TV API..." >&2
    api_delay
    
    # Try API first
    local ids_url="${TMDB_API_BASE}/tv/${tmdb_id}/external_ids?api_key=${TMDB_API_KEY}"
    local result=$(curl -s --connect-timeout 10 --max-time 30 "$ids_url" 2>/dev/null)
    local imdb_id=$(echo "$result" | grep -oE '"imdb_id":"tt[0-9]+"' | grep -oE 'tt[0-9]+')
    
    if [[ -n "$imdb_id" ]]; then
        print_success "Found TV IMDb ID via TMDb API: $imdb_id" >&2
        echo "$imdb_id"
        return 0
    fi
    
    # Fallback to web scraping
    print_info "API failed, trying web scraping..." >&2
    local tv_url="https://www.themoviedb.org/tv/${tmdb_id}"
    result=$(curl -s -A "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36" "$tv_url" 2>/dev/null)
    imdb_id=$(echo "$result" | grep -oE 'imdb\.com/title/(tt[0-9]{7,8})' | head -1 | grep -oE 'tt[0-9]{7,8}')
    
    if [[ -n "$imdb_id" ]]; then
        print_success "Extracted TV IMDb ID from TMDb page: $imdb_id" >&2
        echo "$imdb_id"
        return 0
    fi
    
    print_warning "Could not find IMDb ID" >&2
    return 1
}

# Get TMDb ID from IMDb ID for TV shows (reverse lookup)
get_tmdb_from_imdb_tv() {
    local imdb_id="$1"
    should_debug high && print_info "[DEBUG] get_tmdb_from_imdb_tv: ENTER imdb_id='$imdb_id'" >&2
    
    if [[ -z "$imdb_id" ]]; then
        should_debug high && print_info "[DEBUG] get_tmdb_from_imdb_tv: RETURN (empty imdb_id)" >&2
        return 1
    fi
    
    # Check if TMDb API key is available
    if [[ -z "$TMDB_API_KEY" ]]; then
        [[ "$DEBUG_MODE_TV" == "true" ]] && print_warning "[DEBUG] TMDb API key not configured" >&2
        return 1
    fi
    
    should_debug high && print_info "[DEBUG] Looking up TMDb ID from IMDb ID..." >&2
    api_delay
    
    # Use TMDb find endpoint to convert IMDb ID to TMDb ID
    local find_url="${TMDB_API_BASE}/find/${imdb_id}?api_key=${TMDB_API_KEY}&external_source=imdb_id"
    local result=$(curl -s --connect-timeout 10 --max-time 30 "$find_url" 2>/dev/null)
    
    # Extract TMDb ID from tv_results array
    local tmdb_id=$(echo "$result" | python3 -c "
import sys, json
try:
    data = json.load(sys.stdin)
    tv_results = data.get('tv_results', [])
    if tv_results:
        print(tv_results[0].get('id', ''))
except:
    pass
" 2>/dev/null)
    
    # Fallback to grep if Python fails
    if [[ -z "$tmdb_id" ]]; then
        tmdb_id=$(echo "$result" | grep -oE '"tv_results":\[{"[^}]*"id":([0-9]+)' | grep -oE '[0-9]+$' | head -1)
    fi
    
    if [[ -n "$tmdb_id" ]]; then
        should_debug high && print_info "[DEBUG] get_tmdb_from_imdb_tv: RETURN tmdb_id='$tmdb_id'" >&2
        echo "$tmdb_id"
        return 0
    fi
    
    should_debug high && print_info "[DEBUG] get_tmdb_from_imdb_tv: RETURN (not found)" >&2
    return 1
}

# Get TVDb ID from TMDb using API
get_tvdb_from_tmdb() {
    local tmdb_id="$1"
    should_debug high && print_info "[DEBUG] get_tvdb_from_tmdb: ENTER tmdb_id='$tmdb_id'" >&2
    if [[ -z "$tmdb_id" ]]; then
        should_debug high && print_info "[DEBUG] get_tvdb_from_tmdb: RETURN (empty tmdb_id)" >&2
        return 1
    fi
    
    print_info "Getting TVDb ID from TMDb TV API..." >&2
    api_delay
    
    # Try API first
    local ids_url="${TMDB_API_BASE}/tv/${tmdb_id}/external_ids?api_key=${TMDB_API_KEY}"
    local result=$(curl -s "$ids_url" 2>/dev/null)
    local tvdb_id=$(echo "$result" | grep -oE '"tvdb_id":[0-9]+' | grep -oE '[0-9]+')
    
    if [[ -n "$tvdb_id" ]]; then
        print_success "Found TVDb ID via TMDb API: $tvdb_id" >&2
        echo "$tvdb_id"
        return 0
    fi
    
    # Fallback to web scraping
    print_info "API failed, trying web scraping..." >&2
    local tv_url="https://www.themoviedb.org/tv/${tmdb_id}"
    result=$(curl -s -A "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36" "$tv_url" 2>/dev/null)
    tvdb_id=$(echo "$result" | grep -oE 'thetvdb\.com/[^/]+/series/[^/]+/[0-9]+' | head -1 | grep -oE '[0-9]+$')
    
    if [[ -n "$tvdb_id" ]]; then
        print_success "Extracted TVDb ID from TMDb page: $tvdb_id" >&2
        echo "$tvdb_id"
        return 0
    fi
    
    return 1
}

# Search IMDb for TV series and get year (using suggestion API like movies)
search_imdb_tv_for_year() {
    local series_title="$1"
    should_debug high && print_info "[DEBUG] search_imdb_tv_for_year: ENTER series_title='$series_title'" >&2
    
    if [[ -z "$series_title" ]]; then
        should_debug high && print_info "[DEBUG] search_imdb_tv_for_year: RETURN (empty title)" >&2
        return 1
    fi
    
    print_info "Searching IMDb suggestion API for series year: $series_title" >&2
    api_delay
    
    # Use IMDb suggestion API (same as movie search)
    local encoded_title=$(url_encode "$series_title")
    local search_url="https://v3.sg.media-imdb.com/suggestion/x/${encoded_title}.json"
    local result=$(curl -s -A "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36" "$search_url" 2>/dev/null)
    
    # Parse JSON response - look for TV series entries
    # The JSON has structure: {"d":[{...entries...}]}
    # Each entry: {"id":"tt2674806","l":"Inside No. 9","q":"TV series","qid":"tvSeries","y":2014}
    
    # Extract the year field ("y": 2014) - this is the first aired year
    local year=$(echo "$result" | grep -oE '"y":\s*[0-9]{4}' | head -1 | grep -oE '[0-9]{4}')
    
    if [[ -n "$year" ]]; then
        # Also extract IMDb ID if available - return both year and ID
        local imdb_id=$(echo "$result" | grep -oE '"id":"tt[0-9]{7,8}"' | head -1 | grep -oE 'tt[0-9]{7,8}')
        print_success "Found series year from IMDb: $year${imdb_id:+ (ID: $imdb_id)}" >&2
        # Return both year and IMDb ID separated by pipe
        echo "${year}|${imdb_id}"
        return 0
    fi
    
    print_warning "Could not find series year from IMDb" >&2
    return 1
}

# Get series year from TMDb TV ID
get_year_from_tmdb_tv() {
    local tmdb_id="$1"
    should_debug high && print_info "[DEBUG] get_year_from_tmdb_tv: ENTER tmdb_id='$tmdb_id'" >&2
    
    if [[ -z "$tmdb_id" ]]; then
        should_debug high && print_info "[DEBUG] get_year_from_tmdb_tv: RETURN (empty tmdb_id)" >&2
        return 1
    fi
    
    print_info "Fetching year from TMDb TV ID: $tmdb_id" >&2
    api_delay
    
    # Get TV show details from TMDb
    local tv_url="${TMDB_API_BASE}/tv/${tmdb_id}?api_key=${TMDB_API_KEY}"
    local result=$(curl -s --connect-timeout 10 --max-time 30 "$tv_url" 2>/dev/null)
    
    # Extract first_air_date and get year
    local first_air_date=$(echo "$result" | grep -oE '"first_air_date":"[0-9]{4}-[0-9]{2}-[0-9]{2}"' | head -1 | grep -oE '[0-9]{4}')
    
    if [[ -n "$first_air_date" ]]; then
        print_success "Found year from TMDb TV: $first_air_date" >&2
        echo "$first_air_date"
        return 0
    fi
    
    print_warning "Could not extract year from TMDb TV" >&2
    return 1
}

# Get series year from IMDb ID
get_year_from_imdb_id() {
    local imdb_id="$1"
    
    if [[ -z "$imdb_id" ]]; then
        return 1
    fi
    
    # Check session cache first to avoid redundant API calls
    local cache_var="CACHED_YEAR_${imdb_id//-/_}"
    if [[ -n "${!cache_var}" ]]; then
        echo "${!cache_var}"
        return 0
    fi
    
    print_info "Fetching year from IMDb ID: $imdb_id" >&2
    api_delay
    
    # Try suggestion API first (faster and more reliable)
    local search_url="https://v3.sg.media-imdb.com/suggestion/titles/${imdb_id}.json"
    local result=$(curl -s -A "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36" "$search_url" 2>/dev/null)
    
    local year=$(echo "$result" | grep -oE '"y":[0-9]{4}' | head -1 | grep -oE '[0-9]{4}')
    
    if [[ -n "$year" ]]; then
        print_success "Found year from IMDb ID: $year" >&2
        # Cache the year for this session
        eval "${cache_var}='${year}'"
        echo "$year"
        return 0
    fi
    
    # Fallback: scrape the IMDb page
    local imdb_url="https://www.imdb.com/title/${imdb_id}/"
    result=$(curl -s -A "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36" "$imdb_url" 2>/dev/null)
    
    # Look for year in JSON-LD or structured data
    year=$(echo "$result" | grep -oE '"startDate":"[0-9]{4}' | head -1 | grep -oE '[0-9]{4}')
    
    if [[ -z "$year" ]]; then
        # Look for year in page title or meta tags
        year=$(echo "$result" | grep -oE '<title>[^<]*\(.*([0-9]{4})' | head -1 | grep -oE '[0-9]{4}' | head -1)
    fi
    
    if [[ -n "$year" ]]; then
        print_success "Extracted year from IMDb page: $year" >&2
        echo "$year"
        return 0
    fi
    
    print_warning "Could not extract year from IMDb" >&2
    return 1
}

# Fetch title from IMDb ID
get_title_from_imdb_id() {
    local imdb_id="$1"
    
    if [[ -z "$imdb_id" ]]; then
        return 1
    fi
    
    should_debug high && print_info "[DEBUG] Fetching title from IMDb ID: $imdb_id" >&2
    api_delay
    
    # Method 1: Try suggestion API first (faster)
    local search_url="https://v3.sg.media-imdb.com/suggestion/titles/${imdb_id}.json"
    local result=$(curl -s -A "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36" "$search_url" 2>/dev/null)
    
    # Extract title from JSON: "l":"Title Name"
    local title=$(echo "$result" | grep -oE '"l":"[^"]+' | head -1 | cut -d'"' -f4)
    
    if [[ -n "$title" ]]; then
        should_debug high && print_success "[DEBUG] Found title from IMDb suggestion API: $title" >&2
        echo "$title"
        return 0
    fi
    
    # Method 2: Scrape main IMDb page
    should_debug high && print_info "[DEBUG] Suggestion API failed, scraping IMDb page..." >&2
    local page_url="https://www.imdb.com/title/${imdb_id}/"
    local page=$(curl -s -A "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36" "$page_url" 2>/dev/null)
    
    # Try multiple extraction methods for CANONICAL title (not original title)
    # Method 2a: h1 with data-testid="hero__pageTitle" (canonical title, modern IMDb)
    title=$(echo "$page" | grep -oE 'data-testid="hero__pageTitle"[^>]*>[^<]+' | sed 's/.*>//;s/<.*//' | head -1)
    if [[ -n "$title" && ! "$title" =~ ^[0-9]+$ ]]; then
        should_debug high && print_success "[DEBUG] Found canonical title from IMDb h1 hero: $title" >&2
        echo "$title"
        return 0
    fi
    
    # Method 2b: h1 tag (canonical title shown to users)
    title=$(echo "$page" | grep -oE '<h1[^>]*>[^<]+' | sed 's/<h1[^>]*>//;s/<.*//' | head -1)
    if [[ -n "$title" && ! "$title" =~ ^[0-9]+$ ]]; then
        should_debug high && print_success "[DEBUG] Found canonical title from IMDb h1 tag: $title" >&2
        echo "$title"
        return 0
    fi
    
    # Method 2c: JSON-LD structured data (usually canonical)
    title=$(echo "$page" | grep -oE '"name":"[^"]+' | head -1 | cut -d'"' -f4)
    if [[ -n "$title" && ! "$title" =~ ^[0-9]+$ ]]; then
        should_debug high && print_success "[DEBUG] Found title from IMDb JSON-LD: $title" >&2
        echo "$title"
        return 0
    fi
    
    # Method 2d: og:title meta tag (fallback)
    title=$(echo "$page" | grep -oE 'property="og:title" content="[^"]+' | head -1 | sed 's/.*content="//;s/ - IMDb$//')
    if [[ -n "$title" ]]; then
        should_debug high && print_success "[DEBUG] Found title from IMDb og:title: $title" >&2
        echo "$title"
        return 0
    fi
    
    # Method 2e: <title> tag (last resort)
    title=$(echo "$page" | grep -oE '<title>[^<]+' | head -1 | sed 's/<title>//;s/ - IMDb$//')
    if [[ -n "$title" ]]; then
        should_debug high && print_success "[DEBUG] Found title from IMDb title tag: $title" >&2
        echo "$title"
        return 0
    fi
    
    should_debug high && print_warning "[DEBUG] Could not extract title from IMDb using any method" >&2
    return 1
}

# Fetch episode title from TMDb (if not in filename)
get_episode_title_from_tmdb() {
    local tmdb_id="$1"
    local season="$2"
    local episode="$3"
    should_debug high && print_info "[DEBUG] get_episode_title_from_tmdb: tmdb_id='$tmdb_id' season='$season' episode='$episode'" >&2
    
    if [[ -z "$tmdb_id" || -z "$season" || -z "$episode" ]]; then
        should_debug high && print_info "[DEBUG] get_episode_title_from_tmdb: Missing required parameters" >&2
        return 1
    fi
    
    # Check if TMDb API key is available
    if [[ -z "$TMDB_API_KEY" ]]; then
        [[ "$DEBUG_MODE_TV" == "true" ]] && print_warning "[DEBUG] TMDb API key not configured - cannot fetch episode title" >&2
        return 1
    fi
    
    should_debug high && print_info "[DEBUG] Fetching episode title from TMDb API..." >&2
    api_delay
    
    # Use TMDb API v3 to get episode details
    local api_url="${TMDB_API_BASE}/tv/${tmdb_id}/season/${season}/episode/${episode}?api_key=${TMDB_API_KEY}"
    
    if [[ "$DEBUG_MODE_TV" == "true" ]]; then
        local masked_key="${TMDB_API_KEY:0:8}...${TMDB_API_KEY: -4}"
        local masked_url="${api_url//$TMDB_API_KEY/$masked_key}"
        print_info "[DEBUG] Episode API URL: $masked_url" >&2
    fi
    
    local result=$(curl -s "$api_url" 2>/dev/null)
    
    # Extract episode name from JSON response using Python for reliable parsing
    local ep_title=$(echo "$result" | python3 -c "
import sys, json
try:
    data = json.load(sys.stdin)
    name = data.get('name', '')
    if name:
        print(name)
except:
    pass
" 2>/dev/null)
    
    # Fallback to grep if Python fails
    if [[ -z "$ep_title" ]]; then
        # The episode name field comes after guest_stars array: ],"name":"Episode Title"
        # This distinguishes it from crew/guest "name" fields which are inside arrays
        ep_title=$(echo "$result" | grep -oE '\],"name":"[^"]+"' | sed 's/],"name":"//;s/"$//')
    fi
    
    if [[ -n "$ep_title" && "$ep_title" != "null" ]]; then
        should_debug high && print_info "[DEBUG] get_episode_title_from_tmdb: RETURN '$ep_title'" >&2
        echo "$ep_title"
        return 0
    fi
    
    should_debug high && print_info "[DEBUG] get_episode_title_from_tmdb: RETURN (no title found)" >&2
    return 1
}

# Get TV show episode runtime from TMDb
get_tv_episode_runtime_from_tmdb() {
    local tmdb_id="$1"
    local season="$2"
    local episode="$3"
    should_debug high && print_info "[DEBUG] get_tv_episode_runtime_from_tmdb: ENTER tmdb='$tmdb_id' S${season}E${episode}" >&2
    
    if [[ -z "$tmdb_id" || -z "$season" || -z "$episode" ]]; then
        should_debug high && print_info "[DEBUG] get_tv_episode_runtime_from_tmdb: RETURN (missing params)" >&2
        return 1
    fi
    
    # Check if TMDb API key is available
    if [[ -z "$TMDB_API_KEY" ]]; then
        return 1
    fi
    
    api_delay
    
    # Use TMDb API v3 to get episode details
    local api_url="${TMDB_API_BASE}/tv/${tmdb_id}/season/${season}/episode/${episode}?api_key=${TMDB_API_KEY}"
    local result=$(curl -s "$api_url" 2>/dev/null)
    
    # Extract runtime from JSON response
    local runtime=$(echo "$result" | grep -oE '"runtime":[0-9]+' | head -1 | grep -oE '[0-9]+')
    
    if [[ -n "$runtime" && "$runtime" != "null" && "$runtime" != "0" ]]; then
        echo "$runtime"
        return 0
    fi
    
    return 1
}

# Get all episodes for a season with runtimes and titles from TMDb
# Returns format: episode_num|title|runtime (one per line)
get_season_episodes_from_tmdb() {
    local tmdb_id="$1"
    local season="$2"
    should_debug high && print_info "[DEBUG] get_season_episodes_from_tmdb: tmdb_id='$tmdb_id' season='$season'" >&2
    
    if [[ -z "$tmdb_id" || -z "$season" ]]; then
        should_debug high && print_info "[DEBUG] get_season_episodes_from_tmdb: Missing tmdb_id or season" >&2
        return 1
    fi
    
    # Check for TMDb API key
    if [[ -z "$TMDB_API_KEY" ]]; then
        print_error "TMDb API key not configured" >&2
        return 1
    fi
    
    print_info "Fetching all episodes for Season $season from TMDb API..." >&2
    api_delay
    
    # Use TMDb API to get season details (includes all episodes)
    local api_url="${TMDB_API_BASE}/tv/${tmdb_id}/season/${season}?api_key=${TMDB_API_KEY}"
    local result=$(curl -s --connect-timeout 10 --max-time 30 "$api_url" 2>/dev/null)
    
    should_debug high && print_info "[DEBUG] get_season_episodes_from_tmdb: API response (first 300 chars): $(echo "$result" | head -c 300)..." >&2
    
    # Check for error response
    if echo "$result" | grep -q '"success":false'; then
        print_error "TMDb API error for season $season" >&2
        return 1
    fi
    
    # Extract episodes array using Python for reliable JSON parsing
    local episodes_data=$(echo "$result" | python3 -c "
import sys, json
try:
    data = json.load(sys.stdin)
    episodes = data.get('episodes', [])
    for ep in episodes:
        ep_num = ep.get('episode_number', 0)
        ep_title = ep.get('name', '').replace('|', '-')  # Escape pipe chars
        ep_runtime = ep.get('runtime', 0) or 0
        print(f'{ep_num}|{ep_title}|{ep_runtime}')
except:
    pass
" 2>/dev/null)
    
    if [[ -z "$episodes_data" ]]; then
        # Fallback: try grep-based extraction
        should_debug high && print_info "[DEBUG] Python parsing failed, trying grep fallback" >&2
        
        # Try to extract episode count
        local episode_count=$(echo "$result" | grep -oE '"episode_number":[0-9]+' | wc -l | tr -d ' ')
        
        if [[ -z "$episode_count" || "$episode_count" == "0" ]]; then
            print_error "Could not determine episode count for season $season" >&2
            return 1
        fi
        
        print_success "Found $episode_count episodes in Season $season" >&2
        
        # Extract each episode's data using grep patterns
        for ((ep=1; ep<=episode_count; ep++)); do
            # This is a rough extraction - get episode title from the JSON
            local ep_title=$(echo "$result" | grep -oE "\"episode_number\":${ep}[^}]*\"name\":\"[^\"]*\"" | grep -oE '"name":"[^"]*"' | sed 's/"name":"//;s/"$//' | head -1)
            local ep_runtime=$(echo "$result" | grep -oE "\"episode_number\":${ep}[^}]*\"runtime\":[0-9]+" | grep -oE '"runtime":[0-9]+' | grep -oE '[0-9]+' | head -1)
            [[ -z "$ep_runtime" ]] && ep_runtime="0"
            episodes_data="${episodes_data}${ep}|${ep_title}|${ep_runtime}\n"
        done
        episodes_data=$(echo -e "$episodes_data")
    fi
    
    local ep_count=$(echo "$episodes_data" | grep -c '|' || echo 0)
    if [[ "$ep_count" -gt 0 ]]; then
        print_success "Found $ep_count episodes in Season $season" >&2
    fi
    
    echo "$episodes_data"
    return 0
}

# Match files to episodes by runtime comparison
# Takes: tmdb_id, season, array of file paths
# Returns: matched pairs as "file_path|episode_num|episode_title|runtime"
match_files_to_episodes_by_runtime() {
    local tmdb_id="$1"
    local season="$2"
    shift 2
    local -a files=("$@")
    should_debug high && print_info "[DEBUG] match_files_to_episodes_by_runtime: tmdb_id='$tmdb_id' season='$season' file_count='${#files[@]}'" >&2
    
    if [[ -z "$tmdb_id" || -z "$season" || ${#files[@]} -eq 0 ]]; then
        should_debug high && print_info "[DEBUG] match_files_to_episodes_by_runtime: Missing parameters or no files" >&2
        return 1
    fi
    
    # Get all episodes for the season
    should_debug high && print_info "[DEBUG] match_files_to_episodes_by_runtime: Fetching episode data from TMDb" >&2
    local episodes_data=$(get_season_episodes_from_tmdb "$tmdb_id" "$season")
    should_debug high && print_info "[DEBUG] match_files_to_episodes_by_runtime: Got episode data (first 200 chars): $(echo "$episodes_data" | head -c 200)..." >&2
    
    if [[ -z "$episodes_data" ]]; then
        print_error "Failed to fetch episode data from TMDb" >&2
        return 1
    fi
    
    # Parse episodes into arrays
    local -a ep_nums=()
    local -a ep_titles=()
    local -a ep_runtimes=()
    
    while IFS='|' read -r ep_num ep_title ep_runtime; do
        [[ -z "$ep_num" ]] && continue
        ep_nums+=("$ep_num")
        ep_titles+=("$ep_title")
        ep_runtimes+=("$ep_runtime")
    done <<< "$episodes_data"
    
    print_info "Analyzing file runtimes for matching..." >&2
    echo "" >&2
    
    # Get runtime for each file
    local -a file_runtimes=()
    for file in "${files[@]}"; do
        local file_runtime=$(get_file_runtime "$file")
        file_runtimes+=("$file_runtime")
        print_info "$(basename "$file"): ${file_runtime:-unknown} minutes" >&2
    done
    
    echo "" >&2
    print_info "Matching files to episodes..." >&2
    echo "" >&2
    
    # Track which episodes have been matched
    local -a matched_episodes=()
    local -a matches=()
    
    # For each file, find the best episode match
    for file_idx in "${!files[@]}"; do
        local file="${files[$file_idx]}"
        local file_runtime="${file_runtimes[$file_idx]}"
        
        if [[ -z "$file_runtime" ]]; then
            print_warning "Skipping $(basename "$file") - could not determine runtime" >&2
            continue
        fi
        
        local best_ep=""
        local best_diff=999
        
        # Compare against all unmatched episodes
        for ep_idx in "${!ep_nums[@]}"; do
            local ep_num="${ep_nums[$ep_idx]}"
            
            # Skip if already matched
            [[ " ${matched_episodes[@]} " =~ " ${ep_num} " ]] && continue
            
            local ep_runtime="${ep_runtimes[$ep_idx]}"
            [[ -z "$ep_runtime" ]] && continue
            
            # Calculate difference
            local diff=$((file_runtime - ep_runtime))
            [[ $diff -lt 0 ]] && diff=$((diff * -1))
            
            if [[ $diff -lt $best_diff ]]; then
                best_diff=$diff
                best_ep=$ep_idx
            fi
        done
        
        if [[ -n "$best_ep" ]]; then
            local matched_num="${ep_nums[$best_ep]}"
            local matched_title="${ep_titles[$best_ep]}"
            local matched_runtime="${ep_runtimes[$best_ep]}"
            
            matched_episodes+=("$matched_num")
            matches+=("${file}|${matched_num}|${matched_title}|${matched_runtime}")
            
            print_success "✓ $(basename "$file") (${file_runtime}m) → E${matched_num}: $matched_title (${matched_runtime}m) [±${best_diff}m]" >&2
        else
            print_warning "✗ Could not match $(basename "$file")" >&2
        fi
    done
    
    echo "" >&2
    
    # Output matches
    for match in "${matches[@]}"; do
        echo "$match"
    done
    
    return 0
}

# Get average episode runtime for a TV show from TMDb
get_tv_show_avg_runtime() {
    local tmdb_id="$1"
    should_debug high && print_info "[DEBUG] get_tv_show_avg_runtime: ENTER tmdb_id='$tmdb_id'" >&2
    
    if [[ -z "$tmdb_id" ]]; then
        should_debug high && print_info "[DEBUG] get_tv_show_avg_runtime: RETURN (empty tmdb_id)" >&2
        return 1
    fi
    
    local tv_url="https://www.themoviedb.org/tv/${tmdb_id}"
    local result=$(curl -s -A "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36" "$tv_url" 2>/dev/null)
    
    # Try to extract average episode runtime from the show's main page
    # Format is usually like "42m" or "1h 2m" in episode runtime section
    local runtime=$(echo "$result" | grep -oE 'Runtime[^0-9]+([0-9]+)m' | head -1 | grep -oE '[0-9]+')
    
    if [[ -z "$runtime" ]]; then
        # Alternative: look for episode_run_time in JSON data
        runtime=$(echo "$result" | grep -oE '"episode_run_time":\[([0-9]+)\]' | head -1 | grep -oE '[0-9]+')
    fi
    
    if [[ -n "$runtime" ]]; then
        echo "$runtime"
        return 0
    fi
    
    return 1
}

# Get TV show title from TMDb
get_tmdb_tv_title() {
    local tmdb_id="$1"
    should_debug high && print_info "[DEBUG] get_tmdb_tv_title: ENTER tmdb_id='$tmdb_id'" >&2
    
    if [[ -z "$tmdb_id" ]]; then
        should_debug high && print_info "[DEBUG] get_tmdb_tv_title: RETURN (empty tmdb_id)" >&2
        echo ""
        return 1
    fi
    
    # Use TMDb API to get canonical TV show title
    local url="${TMDB_API_BASE}/tv/${tmdb_id}?api_key=${TMDB_API_KEY}"
    local response=$(curl -s "$url" 2>/dev/null)
    
    # TMDb TV API response structure (simplified):
    # {"adult":false,"backdrop_path":"...","created_by":[...],"episode_run_time":[24],"first_air_date":"2014-10-09","genres":[{"id":16,"name":"Animation"}],"homepage":"","id":61643,"in_production":false,"languages":["ja"],"last_air_date":"2015-03-26","last_episode_to_air":{...},"name":"Parasyte: The Maxim","networks":[...],...}
    # The "name" field at root level is what we want, but genres also have "name"
    # Strategy: Use Python/grep to extract just the root-level "name" field
    
    local title=$(echo "$response" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('name', ''))" 2>/dev/null)
    
    # If Python fails, fall back to manual extraction
    # Get everything up to first comma after "name":" to avoid genre names
    if [[ -z "$title" ]]; then
        title=$(echo "$response" | grep -oE '"name":"[^"]*"' | head -1 | sed 's/"name":"//;s/"$//')
    fi
    
    # If still empty, try original_name
    if [[ -z "$title" ]]; then
        title=$(echo "$response" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('original_name', ''))" 2>/dev/null)
    fi
    
    # Decode JSON escape sequences
    title=$(echo "$title" | sed 's/\\u0027/'\''/g; s/\\"/"/g; s/\\\\/\\/g')
    
    if [[ -n "$title" ]]; then
        echo "$title"
        return 0
    fi
    
    echo ""
    return 1
}

get_tv_year_from_tmdb() {
    local tmdb_id="$1"
    
    if [[ -z "$tmdb_id" ]]; then
        echo ""
        return 1
    fi
    
    # Use TMDb API to get first air date
    local tv_url="${TMDB_API_BASE}/tv/${tmdb_id}?api_key=${TMDB_API_KEY}"
    local result=$(curl -s --connect-timeout 10 --max-time 30 "$tv_url" 2>/dev/null)
    
    # Extract first_air_date and get year
    local first_air_date=$(echo "$result" | grep -oE '"first_air_date":"[0-9]{4}-[0-9]{2}-[0-9]{2}"' | grep -oE '[0-9]{4}' | head -1)
    
    if [[ -n "$first_air_date" ]]; then
        echo "$first_air_date"
        return 0
    fi
    
    echo ""
    return 1
}

# Get movie title from TMDb
get_tmdb_movie_title() {
    local tmdb_id="$1"
    
    if [[ -z "$tmdb_id" ]]; then
        echo ""
        return 1
    fi
    
    local url="https://www.themoviedb.org/movie/${tmdb_id}"
    local page=$(curl -s -L -A "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36" "$url" 2>/dev/null)
    
    # Try OpenGraph title tag first (most reliable)
    local title=$(echo "$page" | grep -oE 'property="og:title"[^>]*content="[^"]*"' | sed 's/.*content="//;s/".*//' | head -1)
    
    # Fallback: try to extract title from h2 tag
    if [[ -z "$title" ]]; then
        title=$(echo "$page" | grep -oE '<h2[^>]*>[^<]+</h2>' | sed 's/<[^>]*>//g' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | head -1)
    fi
    
    # Clean up title (remove year if present in format "Title (2024)")
    title=$(echo "$title" | sed 's/ ([0-9]\{4\})$//')
    
    # Decode HTML entities
    # title=$(echo "$title" | sed ...)
    title=$(echo "$title" | sed 's/&quot;/"/g; s/&#39;/'/'/g; s/&amp;/\&/g; s/&lt;/</g; s/&gt;/>/g; s/&apos;/'/'/g')
    
    # Detect rate limit error page - reject if title is error message
    if [[ "$title" =~ ^(Wait and [Tt]ry [Aa]gain|Rate [Ll]imit|Throttled)$ ]]; then
        should_debug high && echo "[DEBUG] Detected rate limit error page, rejecting title: '$title'" >&2
        echo ""
        return 1
    fi
    
    if [[ -n "$title" ]]; then
        echo "$title"
        return 0
    fi
    
    echo ""
    return 1
}

# Get TV show poster URL - uses same method as movies (IMDb JSON-LD)
get_tv_poster() {
    local imdb_id="$1"
    local tmdb_id="$2"  # Optional: if we already have TMDb ID
    should_debug high && print_info "[DEBUG] get_tv_poster: ENTER imdb='$imdb_id' tmdb='$tmdb_id'" >&2
    
    if [[ -z "$imdb_id" && -z "$tmdb_id" ]]; then
        should_debug high && print_info "[DEBUG] get_tv_poster: RETURN (no IDs)" >&2
        echo ""
        return 1
    fi
    
    # If we don't have TMDb ID, find it from IMDb ID using /find endpoint
    if [[ -z "$tmdb_id" && -n "$imdb_id" ]]; then
        local find_url="${TMDB_API_BASE}/find/${imdb_id}?api_key=${TMDB_API_KEY}&external_source=imdb_id"
        local result=$(curl -s "$find_url" 2>/dev/null)
        # For TV shows, extract from tv_results array (not movie_results)
        tmdb_id=$(echo "$result" | grep -oE '"tv_results":\s*\[\s*\{\s*"[^"]*"\s*:\s*"[^"]*"\s*,\s*"[^"]*"\s*:\s*"[^"]*"\s*,\s*"id":\s*[0-9]+' | grep -oE '"id":\s*[0-9]+' | grep -oE '[0-9]+' | head -1)
    fi
    
    if [[ -z "$tmdb_id" ]]; then
        return 1
    fi
    
    # Get TV show details including poster path (use /tv/ endpoint, not /movie/)
    local tv_url="${TMDB_API_BASE}/tv/${tmdb_id}?api_key=${TMDB_API_KEY}"
    local result=$(curl -s "$tv_url" 2>/dev/null)
    local poster_path=$(echo "$result" | grep -oE '"poster_path":"[^"]+' | sed 's/"poster_path":"//' | head -1)
    
    if [[ -n "$poster_path" ]]; then
        # TMDb image base URL (w500 = 500px width)
        local poster_url="https://image.tmdb.org/t/p/w500${poster_path}"
        echo "$poster_url"
        return 0
    fi
    
    echo ""
    return 1
}

# Search TMDb TV with runtime verification
search_tmdb_tv_with_runtime() {
    local series_title="$1"
    local year="$2"
    local source_file="$3"
    local season="$4"
    local episode="$5"
    should_debug high && print_info "[DEBUG] search_tmdb_tv_with_runtime: series_title='$series_title' year='$year' season='$season' episode='$episode'" >&2
    
    if [[ -z "$series_title" ]]; then
        should_debug high && print_info "[DEBUG] search_tmdb_tv_with_runtime: Empty series_title, returning" >&2
        return 1
    fi
    
    # Get runtime from source file
    local file_runtime=$(get_file_runtime "$source_file")
    should_debug high && print_info "[DEBUG] search_tmdb_tv_with_runtime: file_runtime='$file_runtime' minutes" >&2
    
    if [[ -z "$file_runtime" ]]; then
        print_warning "Could not determine file runtime - falling back to name-only search" >&2
        return 1
    fi
    
    print_info "File runtime: ${file_runtime} minutes" >&2
    print_info "Searching TMDb TV with runtime verification..." >&2
    api_delay
    
    local search_url="https://www.themoviedb.org/search/tv?query=$(echo "$series_title" | sed 's/ /+/g')"
    local result=$(curl -s -A "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36" "$search_url" 2>/dev/null)
    
    # Extract multiple potential matches (up to 10 for better fuzzy matching)
    local -a tmdb_ids=($(echo "$result" | grep -oE "href=\"/tv/[0-9]+" | grep -oE "[0-9]+" | head -10))
    
    if [[ ${#tmdb_ids[@]} -eq 0 ]]; then
        print_warning "No TMDb TV results found" >&2
        return 1
    fi
    
    print_info "Found ${#tmdb_ids[@]} potential matches, verifying titles and runtimes..." >&2
    
    # Arrays to store candidate info for fuzzy matching
    local -a candidate_ids=()
    local -a candidate_titles=()
    local -a candidate_runtimes=()
    
    # First pass: collect all titles and runtimes
    for tmdb_id in "${tmdb_ids[@]}"; do
        local show_title=$(get_tmdb_tv_title "$tmdb_id")
        local show_runtime=""
        
        # Get runtime (episode or average)
        if [[ -n "$season" && -n "$episode" ]]; then
            show_runtime=$(get_tv_episode_runtime_from_tmdb "$tmdb_id" "$season" "$episode")
        fi
        if [[ -z "$show_runtime" ]]; then
            show_runtime=$(get_tv_show_avg_runtime "$tmdb_id")
        fi
        
        candidate_ids+=("$tmdb_id")
        candidate_titles+=("$show_title")
        candidate_runtimes+=("$show_runtime")
        
        if [[ -n "$show_title" ]]; then
            echo -e "${DIM}  TMDb $tmdb_id: \"${show_title}\"${NC}" >&2
        fi
        
        sleep 0.3
    done
    
    # Fetch years for all candidates if year matching is needed
    local -a candidate_years=()
    if [[ -n "$year" ]]; then
        for tmdb_id in "${candidate_ids[@]}"; do
            local show_year=$(get_tv_year_from_tmdb "$tmdb_id")
            candidate_years+=("$show_year")
        done
    fi
    
    # Second pass: try exact title match with year validation and runtime
    local selected_id=""
    local norm_file_title=$(echo "$series_title" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9 ]//g')
    
    for ((i=0; i<${#candidate_ids[@]}; i++)); do
        local tmdb_id="${candidate_ids[$i]}"
        local show_title="${candidate_titles[$i]}"
        local show_runtime="${candidate_runtimes[$i]}"
        local show_year="${candidate_years[$i]:-}"
        
        if [[ -n "$show_title" ]]; then
            local norm_show_title=$(echo "$show_title" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9 ]//g')
            
            # Check exact title match
            if [[ "$norm_file_title" == "$norm_show_title" ]]; then
                # Validate year first (±2 year tolerance)
                local year_match=true
                if [[ -n "$year" && -n "$show_year" ]]; then
                    local year_diff=$((year - show_year))
                    [[ $year_diff -lt 0 ]] && year_diff=$((year_diff * -1))
                    if [[ $year_diff -gt 2 ]]; then
                        [[ "$DEBUG_MODE_TV" == "true" ]] && print_warning "[DEBUG] Year mismatch: file=$year, show=$show_year (diff=${year_diff}y) - skipping" >&2
                        year_match=false
                    fi
                fi
                
                if [[ "$year_match" == true ]]; then
                    # Verify runtime if available
                    if [[ -n "$show_runtime" ]]; then
                        local diff=$((file_runtime - show_runtime))
                        [[ $diff -lt 0 ]] && diff=$((diff * -1))
                        
                        local tolerance=10
                        [[ -n "$season" && -n "$episode" ]] && tolerance=5
                        
                        if [[ $diff -le $tolerance ]]; then
                            print_success "✓ Exact title + year + runtime match: \"${show_title}\" ($show_year) (±${diff}m)" >&2
                            selected_id="$tmdb_id"
                            break
                        fi
                    else
                        print_success "✓ Exact title + year match: \"${show_title}\" ($show_year)" >&2
                        selected_id="$tmdb_id"
                        break
                    fi
                fi
            fi
        fi
    done
    
    # Third pass: try fuzzy title match (number/word conversion) with year and runtime
    if [[ -z "$selected_id" ]]; then
        local fuzzy_file_title=$(normalize_title_fuzzy "$series_title")
        
        for ((i=0; i<${#candidate_ids[@]}; i++)); do
            local tmdb_id="${candidate_ids[$i]}"
            local show_title="${candidate_titles[$i]}"
            local show_runtime="${candidate_runtimes[$i]}"
            local show_year="${candidate_years[$i]:-}"
            
            if [[ -n "$show_title" ]]; then
                local fuzzy_show_title=$(normalize_title_fuzzy "$show_title")
                
                # Check fuzzy title match
                if [[ "$fuzzy_file_title" == "$fuzzy_show_title" ]]; then
                    # Validate year first (±2 year tolerance)
                    local year_match=true
                    if [[ -n "$year" && -n "$show_year" ]]; then
                        local year_diff=$((year - show_year))
                        [[ $year_diff -lt 0 ]] && year_diff=$((year_diff * -1))
                        if [[ $year_diff -gt 2 ]]; then
                            [[ "$DEBUG_MODE_TV" == "true" ]] && print_warning "[DEBUG] Fuzzy: Year mismatch: file=$year, show=$show_year (diff=${year_diff}y) - skipping" >&2
                            year_match=false
                        fi
                    fi
                    
                    if [[ "$year_match" == true ]]; then
                        # Verify runtime if available
                        if [[ -n "$show_runtime" ]]; then
                            local diff=$((file_runtime - show_runtime))
                            [[ $diff -lt 0 ]] && diff=$((diff * -1))
                            
                            local tolerance=10
                            [[ -n "$season" && -n "$episode" ]] && tolerance=5
                            
                            if [[ $diff -le $tolerance ]]; then
                                print_success "✓ Fuzzy title + year + runtime match: \"${show_title}\" ($show_year) (±${diff}m)" >&2
                                selected_id="$tmdb_id"
                                break
                            fi
                        else
                            print_success "✓ Fuzzy title + year match: \"${show_title}\" ($show_year)" >&2
                            selected_id="$tmdb_id"
                            break
                        fi
                    fi
                fi
            fi
        done
    fi
    
    # Fourth pass: runtime-only match (original behavior)
    if [[ -z "$selected_id" ]]; then
        for ((i=0; i<${#candidate_ids[@]}; i++)); do
            local tmdb_id="${candidate_ids[$i]}"
            local show_runtime="${candidate_runtimes[$i]}"
            
            if [[ -n "$show_runtime" ]]; then
                local diff=$((file_runtime - show_runtime))
                [[ $diff -lt 0 ]] && diff=$((diff * -1))
                
                local tolerance=10
                [[ -n "$season" && -n "$episode" ]] && tolerance=5
                
                if [[ $diff -le $tolerance ]]; then
                    print_success "✓ Runtime-only match (±${diff}m): TMDb TV ID $tmdb_id" >&2
                    selected_id="$tmdb_id"
                    break
                fi
            fi
        done
    fi
    
    # Use selected match or fall back to first candidate
    if [[ -n "$selected_id" ]]; then
        echo "$selected_id"
        return 0
    else
        print_warning "No good match found, using first candidate: ${candidate_ids[0]}" >&2
        echo "${candidate_ids[0]}"
        return 0
    fi
}

# Filename parser
parse_filename() {
    local filepath="$1"
    local parse_type="${2:-file}"  # 'file' or 'folder', defaults to 'file'
    local basename=$(basename "$filepath")
    
    # Only remove extension if it's a video/subtitle file (not a folder)
    if [[ "$basename" =~ \.(mkv|mp4|avi|m4v|mov|wmv|flv|webm|srt|ass|sub|idx|vtt)$ ]]; then
        basename="${basename%.*}"
    fi
    
    # Reset all parsed variables to prevent reuse from previous file
    PARSED_TITLE=""
    PARSED_YEAR=""
    PARSED_EDITION=""
    PARSED_CUSTOM_FORMAT=""
    PARSED_3D=false
    PARSED_3D_FORMAT=""
    PARSED_FULL_QUALITY=""
    PARSED_AUDIO_CODEC=""
    PARSED_AUDIO_CHANNELS=""
    PARSED_HDR=""
    PARSED_VIDEO_CODEC=""
    PARSED_RELEASE_GROUP=""
    
    # DEBUG: Show what we're parsing with appropriate color (entire line colored)
    if [[ "$parse_type" == "folder" ]]; then
        should_debug medium && echo -e "${NEON_GREEN}[DEBUG] Parsing folder name: '$basename'${NC}" >&2
    else
        should_debug medium && echo -e "${BRIGHT_RED}[DEBUG] Parsing file name: '$basename'${NC}" >&2
    fi
    
    # Remove torrent site/tracker tags before parsing
    # Patterns: [ www.site.com ], [www.site.com], ( www.site.com ), (www.site.com)
    # Also matches: [ site.com ] - The Title, (site.com) - Title, etc.
    # Note: Ensure domain pattern has at least 2 chars before TLD to avoid matching "A.Time.to" as "Time.to"
    basename=$(echo "$basename" | sed -E 's/^[[(][[:space:]]*(www\.)?[a-zA-Z0-9-]+[a-zA-Z0-9]\.(com|org|net|to|cc|tv|me|info)[[:space:]]*[])][[:space:]]*[-[:space:]]*//')
    # Remove trailing tracker tags: - [ www.site.com ]
    basename=$(echo "$basename" | sed -E 's/[[:space:]]*[-[:space:]]*[[(][[:space:]]*(www\.)?[a-zA-Z0-9-]+[a-zA-Z0-9]\.(com|org|net|to|cc|tv|me|info)[[:space:]]*[])][[:space:]]*$//')
    # Remove plain site tags at start: www.site.com - Title (must have www or be followed by dash/space)
    basename=$(echo "$basename" | sed -E 's/^(www\.)[a-zA-Z0-9.-]+\.(com|org|net|to|cc|tv|me|info)[[:space:]]*[-[:space:]]*//')
    basename=$(echo "$basename" | sed -E 's/^[a-zA-Z0-9-]+[a-zA-Z0-9]\.(com|org|net|to|cc|tv|me|info)[[:space:]]+[-[:space:]]+//')
    
    should_debug high && echo "[DEBUG] After removing torrent tags: '$basename'" >&2
    
    # Get current year for validation
    local current_year=$(date +%Y)
    
    # Remove quality/technical indicators in parentheses to avoid confusing them with years
    # This handles cases like "Little Nemo (Stabilized) (1080p)" where (Stabilized) might be parsed as a year
    local clean_basename="$basename"
    clean_basename=$(echo "$clean_basename" | sed -E 's/[[:space:]]*\((Stabilized|Upscaled|Remastered|Restored|Enhanced|Colorized)\)[[:space:]]*/ /gi')
    clean_basename=$(echo "$clean_basename" | sed -E 's/[[:space:]]*\((720p|1080p|2160p|480p|4K|8K|SD|HD|UHD|FHD)\)[[:space:]]*/ /gi')
    clean_basename=$(echo "$clean_basename" | sed -E 's/[[:space:]]*\((x264|x265|H\.?264|H\.?265|HEVC|AVC|VP9|AV1)\)[[:space:]]*/ /gi')
    clean_basename=$(echo "$clean_basename" | sed -E 's/[[:space:]]*\((AAC|AC3|DTS|TrueHD|Atmos|DD|E-AC-?3)\)[[:space:]]*/ /gi')
    clean_basename=$(echo "$clean_basename" | sed -E 's/[[:space:]]*\((HDR|HDR10|Dolby Vision|DV|SDR|HLG)\)[[:space:]]*/ /gi')
    clean_basename=$(echo "$clean_basename" | sed -E 's/[[:space:]]*\((BluRay|BDRip|BRRip|WEBRip|WEB-DL|DVDRip|HDTV)\)[[:space:]]*/ /gi')
    
    # Remove edition keywords before parsing to avoid interference
    clean_basename=$(echo "$clean_basename" | sed -E 's/[[:space:]]*(EXTENDED|UNRATED|DIRECTORS?[[:space:]]CUT|SPECIAL[[:space:]]EDITION|THEATRICAL[[:space:]]CUT|PRODUCERS?[[:space:]]CUT|EDITORS?[[:space:]]CUT)[[:space:]]*/ /gi')
    
    should_debug high && echo "[DEBUG] After removing quality/edition tags: '$clean_basename'" >&2
    
    # Extract year and title - use FIRST occurrence of (year) pattern only
    if [[ $clean_basename =~ ^(.+)[[:space:]]*\(([0-9]{4})\) ]]; then
        # Found pattern: "Title (YYYY)" - validate year range
        local potential_year="${BASH_REMATCH[2]}"
        if [[ $potential_year -ge 1888 && $potential_year -le $current_year ]]; then
            PARSED_TITLE="${BASH_REMATCH[1]}"
            PARSED_YEAR="$potential_year"
            should_debug high && echo "[DEBUG] Pattern 1 matched: Title='${BASH_REMATCH[1]}' Year='$potential_year'" >&2
            # Clean up title: replace dots/underscores with spaces, collapse multiple spaces
            PARSED_TITLE=$(echo "$PARSED_TITLE" | sed 's/[._]/ /g' | sed 's/  */ /g')
            # Clean up common abbreviation patterns like "V s" or "V.s" to "vs"
            PARSED_TITLE=$(echo "$PARSED_TITLE" | sed -E 's/ V[. ]+s / vs /gi')
            # Remove common prefixes that aren't part of the title
            PARSED_TITLE=$(echo "$PARSED_TITLE" | sed -E 's/^(Film|Movie|The Film|The Movie)[[:space:]]+//i')
            # Remove common suffixes in parentheses like "(The Movie)", "(The Film)", etc.
            PARSED_TITLE=$(echo "$PARSED_TITLE" | sed -E 's/[[:space:]]*\((The |A )?(Movie|Film|Documentary|Series)\)[[:space:]]*$//i')
            # Remove common suffixes after dash/hyphen (HBO Documentary, Director's Cut, etc.)
            PARSED_TITLE=$(echo "$PARSED_TITLE" | sed -E 's/[[:space:]]*[-–—][[:space:]]*(HBO|Netflix|Amazon|Apple TV|Disney|Hulu|Showtime|Starz)[[:space:]]*(Original|Documentary|Film|Movie|Series)?[[:space:]]*$//i')
            PARSED_TITLE=$(echo "$PARSED_TITLE" | sed -E 's/[[:space:]]*[-–—][[:space:]]*(Documentary|Director.?s Cut|Extended Edition|Theatrical Cut|Special Edition|Criterion Collection|Remastered)[[:space:]]*$//i')
            # Strip trailing year from title if it matches the parsed year (e.g., "Mo 2022" -> "Mo")
            if [[ -n "$PARSED_YEAR" ]] && [[ "$PARSED_TITLE" =~ [[:space:]]${PARSED_YEAR}$ ]]; then
                PARSED_TITLE="${PARSED_TITLE% $PARSED_YEAR}"
            fi
            # Trim leading/trailing whitespace
            PARSED_TITLE="${PARSED_TITLE#"${PARSED_TITLE%%[![:space:]]*}"}"
            PARSED_TITLE="${PARSED_TITLE%"${PARSED_TITLE##*[![:space:]]}"}"
            should_debug medium && echo "[DEBUG] After cleanup: Title='$PARSED_TITLE' Year='$PARSED_YEAR'" >&2
        fi
    else
        # Fallback: year without parentheses - find ALL valid years and pick the best one
        should_debug high && echo "[DEBUG] Pattern 1 not matched, searching for years without parentheses" >&2
        local years=""
        local temp_basename="$clean_basename"
        
        # Remove resolution patterns first to avoid matching them as years (2160p, 1080p, 720p, 480p)
        temp_basename=$(echo "$temp_basename" | sed -E 's/[[:space:]]*(2160|1080|720|480)p[[:space:]]*/ /gi')
        
        # Extract all 4-digit numbers that look like years (preceded/followed by non-digits or start/end)
        while [[ $temp_basename =~ (^|[^0-9])([0-9]{4})([^0-9]|$) ]]; do
            local potential_year="${BASH_REMATCH[2]}"
            should_debug high && echo "[DEBUG] Found potential year: $potential_year" >&2
            if [[ $potential_year -ge 1888 && $potential_year -le $current_year ]]; then
                # Add to space-separated list
                if [[ -z "$years" ]]; then
                    years="$potential_year"
                else
                    years="$years $potential_year"
                fi
                should_debug high && echo "[DEBUG] Year $potential_year is valid, adding to candidates" >&2
            else
                should_debug high && echo "[DEBUG] Year $potential_year out of valid range (1888-$current_year)" >&2
            fi
            # Remove this match and continue searching
            temp_basename="${temp_basename#*${BASH_REMATCH[2]}}"
        done
        
        # If we found valid years, prefer the LAST one (usually the release year)
        # For "Wonder Woman 1984 2020", we want 2020, not 1984
        if [[ -n "$years" ]]; then
            # Split into array and get last element
            local years_array=($years)
            local last_index=$((${#years_array[@]} - 1))
            PARSED_YEAR="${years_array[$last_index]}"
            should_debug medium && echo "[DEBUG] Selected year: $PARSED_YEAR from candidates: $years" >&2
            # Extract title - check if there's a subtitle/episode name after the year
            # Pattern: "Title YEAR- Subtitle" or "Title YEAR: Subtitle" or "Title YEAR - Subtitle"
            if [[ "$clean_basename" =~ [._[:space:]]${PARSED_YEAR}[._[:space:]]*[-:][._[:space:]]*([A-Za-z0-9]+) ]]; then
                # Has subtitle after year - extract full title including subtitle
                # Use sed to remove everything from year onwards, then add back the portion with subtitle
                local after_year=$(echo "$clean_basename" | sed -E "s/^.*${PARSED_YEAR}[._[:space:]]*[-:][._[:space:]]*//" | sed -E 's/[._[:space:]]*(1080p|720p|480p|2160p|4K|BluRay|WEBRip|x264|x265).*//' | sed -E 's/\.(ia|ai)$//')
                local before_year=$(echo "$clean_basename" | sed -E "s/[._[:space:]]${PARSED_YEAR}.*//" )
                PARSED_TITLE=$(echo "$before_year $after_year" | sed 's/[._]/ /g' | sed 's/  */ /g')
                should_debug medium && echo "[DEBUG] Found subtitle after year: '$after_year'" >&2
            else
                # No subtitle, extract title by removing everything from the year onwards
                PARSED_TITLE=$(echo "$clean_basename" | sed -E "s/[._[:space:]]${PARSED_YEAR}.*//" | sed 's/[._]/ /g' | sed 's/  */ /g')
            fi
            # Clean up common abbreviation patterns like "V s" or "V.s" to "vs"
            PARSED_TITLE=$(echo "$PARSED_TITLE" | sed -E 's/ V[. ]+s / vs /gi')
            # Remove common prefixes that aren't part of the title
            PARSED_TITLE=$(echo "$PARSED_TITLE" | sed -E 's/^(Film|Movie|The Film|The Movie)[[:space:]]+//i')
            # Remove common suffixes in parentheses like "(The Movie)", "(The Film)", etc.
            PARSED_TITLE=$(echo "$PARSED_TITLE" | sed -E 's/[[:space:]]*\((The |A )?(Movie|Film|Documentary|Series)\)[[:space:]]*$//i')
            # Remove common suffixes after dash/hyphen (HBO Documentary, Director's Cut, etc.)
            PARSED_TITLE=$(echo "$PARSED_TITLE" | sed -E 's/[[:space:]]*[-–—][[:space:]]*(HBO|Netflix|Amazon|Apple TV|Disney|Hulu|Showtime|Starz)[[:space:]]*(Original|Documentary|Film|Movie|Series)?[[:space:]]*$//i')
            PARSED_TITLE=$(echo "$PARSED_TITLE" | sed -E 's/[[:space:]]*[-–—][[:space:]]*(Documentary|Director.?s Cut|Extended Edition|Theatrical Cut|Special Edition|Criterion Collection|Remastered)[[:space:]]*$//i')
            # Strip trailing year from title if it matches the parsed year (e.g., "Mo 2022" -> "Mo")
            if [[ -n "$PARSED_YEAR" ]] && [[ "$PARSED_TITLE" =~ [[:space:]]${PARSED_YEAR}$ ]]; then
                PARSED_TITLE="${PARSED_TITLE% $PARSED_YEAR}"
                should_debug high && echo "[DEBUG] Stripped trailing year from title" >&2
            fi
            PARSED_TITLE="${PARSED_TITLE#"${PARSED_TITLE%%[![:space:]]*}"}"
            PARSED_TITLE="${PARSED_TITLE%"${PARSED_TITLE##*[![:space:]]}"}"
            should_debug medium && echo "[DEBUG] After cleanup: Title='$PARSED_TITLE' Year='$PARSED_YEAR'" >&2
        else
            should_debug medium && echo "[DEBUG] No valid years found, extracting title without year" >&2
            # Extract title from basename even without a year
            PARSED_TITLE=$(echo "$clean_basename" | sed 's/[._]/ /g' | sed 's/  */ /g')
            # Clean up common abbreviation patterns like "V s" or "V.s" to "vs"
            PARSED_TITLE=$(echo "$PARSED_TITLE" | sed -E 's/ V[. ]+s / vs /gi')
            # Remove common prefixes that aren't part of the title
            PARSED_TITLE=$(echo "$PARSED_TITLE" | sed -E 's/^(Film|Movie|The Film|The Movie)[[:space:]]+//i')
            # Remove common suffixes in parentheses like "(The Movie)", "(The Film)", etc.
            PARSED_TITLE=$(echo "$PARSED_TITLE" | sed -E 's/[[:space:]]*\((The |A )?(Movie|Film|Documentary|Series)\)[[:space:]]*$//i')
            # Remove common suffixes after dash/hyphen (HBO Documentary, Director's Cut, etc.)
            PARSED_TITLE=$(echo "$PARSED_TITLE" | sed -E 's/[[:space:]]*[-–—][[:space:]]*(HBO|Netflix|Amazon|Apple TV|Disney|Hulu|Showtime|Starz)[[:space:]]*(Original|Documentary|Film|Movie|Series)?[[:space:]]*$//i')
            PARSED_TITLE=$(echo "$PARSED_TITLE" | sed -E 's/[[:space:]]*[-–—][[:space:]]*(Documentary|Director.?s Cut|Extended Edition|Theatrical Cut|Special Edition|Criterion Collection|Remastered)[[:space:]]*$//i')
            # Remove quality indicators from title
            PARSED_TITLE=$(echo "$PARSED_TITLE" | sed -E 's/[[:space:]]+(1080p|720p|480p|2160p|4K|BluRay|BRRip|WEBRip|WEB-DL|HDTV|DVDRip|xvid|x264|x265|h264|h265|AAC|AC3|DTS|5\.1|7\.1).*$//i')
            # Trim whitespace
            PARSED_TITLE="${PARSED_TITLE#"${PARSED_TITLE%%[![:space:]]*}"}"
            PARSED_TITLE="${PARSED_TITLE%"${PARSED_TITLE##*[![:space:]]}"}"
            should_debug medium && echo "[DEBUG] After cleanup (no year): Title='$PARSED_TITLE'" >&2
        fi
    fi
    
    # Extract quality (normalize to Movie format)
    local quality_source=""
    local quality_resolution=""
    
    # Detect source type (normalize to Movie naming - match ALL quality profiles)
    # Order matters: check more specific patterns first
    if [[ $basename =~ Remux ]]; then
        quality_source="Remux"
    elif [[ $basename =~ (WEB-DL|WEBDL|Web-DL) ]]; then
        quality_source="WEBDL"
    elif [[ $basename =~ (WEBRip|WebRip) ]]; then
        quality_source="WEBRip"
    elif [[ $basename =~ \.WEB\.|[[:space:]]WEB[[:space:]]|-WEB- ]]; then
        # Generic WEB (when not WEB-DL or WEBRip) - default to WEBRip
        quality_source="WEBRip"
    elif [[ $basename =~ (Bluray|BluRay|BLURAY|BDRip|BRRip|BrRip|BRRIP|HDLight) ]]; then
        quality_source="Bluray"
    elif [[ $basename =~ \[BD\]|\.BD\.|[[:space:]]BD[[:space:]]|-BD- ]]; then
        # BD in brackets or as standalone (common in anime releases)
        quality_source="Bluray"
    elif [[ $basename =~ HDTV ]]; then
        quality_source="HDTV"
    elif [[ $basename =~ SDTV ]]; then
        quality_source="SDTV"
    elif [[ $basename =~ DVD-R|DVDR ]]; then
        quality_source="DVD-R"
    elif [[ $basename =~ DVDSCR ]]; then
        quality_source="DVDSCR"
    elif [[ $basename =~ \(DVD\)|DVDRip|DVD-Rip|DVD ]]; then
        quality_source="DVD"
    elif [[ $basename =~ BR-DISK|BRDISK ]]; then
        quality_source="BR-DISK"
    elif [[ $basename =~ RAW-HD|RAWHD ]]; then
        quality_source="Raw-HD"
    elif [[ $basename =~ (CAM|CAMRIP) ]]; then
        quality_source="CAM"
    elif [[ $basename =~ TELESYNC ]]; then
        quality_source="TELESYNC"
    elif [[ $basename =~ TELECINE ]]; then
        quality_source="TELECINE"
    elif [[ $basename =~ REGIONAL ]]; then
        quality_source="REGIONAL"
    elif [[ $basename =~ WORKPRINT ]]; then
        quality_source="WORKPRINT"
    fi
    
    # Detect resolution
    if [[ $basename =~ (2160p|4K|UHD) ]]; then
        quality_resolution="2160p"
    elif [[ $basename =~ 1080p ]]; then
        quality_resolution="1080p"
    elif [[ $basename =~ 720p ]]; then
        quality_resolution="720p"
    elif [[ $basename =~ 576p ]]; then
        quality_resolution="576p"
    elif [[ $basename =~ 480p ]]; then
        quality_resolution="480p"
    fi
    
    # Combine to Movie format (e.g., "Bluray-1080p", "WEBDL-720p")
    if [[ -n "$quality_source" && -n "$quality_resolution" ]]; then
        PARSED_FULL_QUALITY="${quality_source}-${quality_resolution}"
    elif [[ -n "$quality_source" ]]; then
        PARSED_FULL_QUALITY="$quality_source"
    elif [[ -n "$quality_resolution" ]]; then
        PARSED_FULL_QUALITY="$quality_resolution"
    fi
    
    should_debug high && echo "[DEBUG] Quality extraction: source='$quality_source' resolution='$quality_resolution' combined='$PARSED_FULL_QUALITY'" >&2
    
    # Extract custom formats (streaming sources + quality modifiers for TrashGuides)
    local custom_formats=""
    
    # Streaming sources (order matters - check most specific first)
    if [[ $basename =~ ATVP|AppleTV|Apple[._]TV ]]; then
        custom_formats="ATVP"
    elif [[ $basename =~ AMZN|Amazon ]]; then
        custom_formats="AMZN"
    elif [[ $basename =~ NF|Netflix ]]; then
        custom_formats="NF"
    elif [[ $basename =~ HULU ]]; then
        custom_formats="HULU"
    elif [[ $basename =~ DSNP|DisneyPlus|Disney[._+]Plus ]]; then
        custom_formats="DSNP"
    elif [[ $basename =~ HBO[._]?MAX|HMAX ]]; then
        custom_formats="HMAX"
    elif [[ $basename =~ HBO ]]; then
        custom_formats="HBO"
    elif [[ $basename =~ PCOK|Peacock ]]; then
        custom_formats="PCOK"
    elif [[ $basename =~ PMTP|Paramount ]]; then
        custom_formats="PMTP"
    elif [[ $basename =~ SHO|Showtime ]]; then
        custom_formats="SHO"
    elif [[ $basename =~ STAN ]]; then
        custom_formats="STAN"
    elif [[ $basename =~ iP|iTunes ]]; then
        custom_formats="iP"
    fi
    
    # If we have a streaming source and quality, combine them
    if [[ -n "$custom_formats" && -n "$PARSED_FULL_QUALITY" ]]; then
        # Check for quality modifiers
        local quality_modifiers=""
        if [[ $basename =~ PROPER ]]; then
            quality_modifiers=" Proper"
        elif [[ $basename =~ REPACK ]]; then
            quality_modifiers=" REPACK"
        elif [[ $basename =~ [._-][vV]([234]) ]]; then
            quality_modifiers=" v${BASH_REMATCH[1]}"
        fi
        
        PARSED_CUSTOM_FORMAT="${custom_formats} ${PARSED_FULL_QUALITY}${quality_modifiers}"
    elif [[ $basename =~ iNTERNAL|INTERNAL ]]; then
        # Internal releases
        if [[ -n "$PARSED_FULL_QUALITY" ]]; then
            local quality_modifiers=""
            if [[ $basename =~ PROPER ]]; then
                quality_modifiers=" Proper"
            elif [[ $basename =~ [._-][vV]([234]) ]]; then
                quality_modifiers=" v${BASH_REMATCH[1]}"
            fi
            PARSED_CUSTOM_FORMAT="iNTERNAL ${PARSED_FULL_QUALITY}${quality_modifiers}"
        fi
    fi
    
    should_debug high && echo "[DEBUG] Custom format extraction: '$PARSED_CUSTOM_FORMAT'" >&2
    
    # Extract video codec (case-insensitive)
    if [[ $basename =~ ([xX]264|[xX]265|[Hh]\.?[[:space:]]?264|[Hh]\.?[[:space:]]?265|[Aa][Vv][Cc]|[Hh][Ee][Vv][Cc]|[Aa][Vv]1|[Xx][Vv][Ii][Dd]) ]]; then
        local codec_match="${BASH_REMATCH[1]}"
        # Normalize H.264/H 264/H264/x264/X264 variants to consistent "H.264"
        if [[ $codec_match =~ ^[HhXx].*264$ ]]; then
            PARSED_VIDEO_CODEC="H.264"
        # Normalize H.265/H 265/H265/x265/X265 variants to consistent "H.265"
        elif [[ $codec_match =~ ^[HhXx].*265$ ]]; then
            PARSED_VIDEO_CODEC="H.265"
        else
            # Uppercase normalize other codecs
            PARSED_VIDEO_CODEC=$(echo "$codec_match" | tr '[:lower:]' '[:upper:]')
        fi
    fi
    
    # Extract audio codec first
    if [[ $basename =~ (DTS-HD[_ ]MA|DTS-HD|DTS|DD|AC3|AAC|TrueHD|FLAC|Atmos) ]]; then
        PARSED_AUDIO_CODEC="${BASH_REMATCH[1]}"
    fi
    
    # Extract audio channels only if codec was found (to avoid matching year like 1986 -> 6.1)
    if [[ -n "$PARSED_AUDIO_CODEC" ]]; then
        # Look for X.X pattern immediately after the codec
        # AAC5.1, AAC.5.1, AAC 5.1, AAC_5.1
        if [[ $basename =~ AAC\.([0-9]\.[0-9]) ]] || [[ $basename =~ AAC\ ([0-9]\.[0-9]) ]] || [[ $basename =~ AAC_([0-9]\.[0-9]) ]] || [[ $basename =~ AAC([0-9]\.[0-9]) ]]; then
            PARSED_AUDIO_CHANNELS="${BASH_REMATCH[1]}"
        elif [[ $basename =~ DTS\.([0-9]\.[0-9]) ]] || [[ $basename =~ DTS\ ([0-9]\.[0-9]) ]] || [[ $basename =~ DTS_([0-9]\.[0-9]) ]] || [[ $basename =~ DTS([0-9]\.[0-9]) ]]; then
            PARSED_AUDIO_CHANNELS="${BASH_REMATCH[1]}"
        elif [[ $basename =~ DD\.([0-9]\.[0-9]) ]] || [[ $basename =~ DD\ ([0-9]\.[0-9]) ]] || [[ $basename =~ DD([0-9]\.[0-9]) ]]; then
            PARSED_AUDIO_CHANNELS="${BASH_REMATCH[1]}"
        elif [[ $basename =~ AC3\.([0-9]\.[0-9]) ]] || [[ $basename =~ AC3\ ([0-9]\.[0-9]) ]] || [[ $basename =~ AC3([0-9]\.[0-9]) ]]; then
            PARSED_AUDIO_CHANNELS="${BASH_REMATCH[1]}"
        elif [[ $basename =~ TrueHD\.([0-9]\.[0-9]) ]] || [[ $basename =~ TrueHD\ ([0-9]\.[0-9]) ]]; then
            PARSED_AUDIO_CHANNELS="${BASH_REMATCH[1]}"
        # Also check for standalone channel pattern in brackets [5.1]
        elif [[ $basename =~ \[([0-9]\.[0-9])\] ]]; then
            PARSED_AUDIO_CHANNELS="${BASH_REMATCH[1]}"
        fi
    fi
    
    # Extract HDR (avoid matching DV in DVD/DVDRip)
    if [[ $basename =~ (DoVi|Dolby[_ ]?Vision|HDR10\+?|HDR) ]]; then
        PARSED_HDR="${BASH_REMATCH[1]}"
    # Match standalone DV only if NOT preceded by D (to avoid DVD/DVDRip)
    elif [[ $basename =~ [^D](DV)([^DR]|$) ]]; then
        PARSED_HDR="${BASH_REMATCH[1]}"
    fi
    
    # Extract edition (case-insensitive)
    if [[ $basename =~ [Ee][Xx][Tt][Ee][Nn][Dd][Ee][Dd] ]]; then
        PARSED_EDITION="EXTENDED"
    elif [[ $basename =~ [Dd][Ii][Rr][Ee][Cc][Tt][Oo][Rr].*[Cc][Uu][Tt] ]]; then
        PARSED_EDITION="DIRECTORS CUT"
    elif [[ $basename =~ [Tt][Hh][Ee][Aa][Tt][Rr][Ii][Cc][Aa][Ll] ]]; then
        PARSED_EDITION="THEATRICAL"
    elif [[ $basename =~ [Ii][Mm][Aa][Xx] ]]; then
        PARSED_EDITION="IMAX"
    elif [[ $basename =~ [Cc][Rr][Ii][Tt][Ee][Rr][Ii][Oo][Nn] ]]; then
        PARSED_EDITION="CRITERION"
    elif [[ $basename =~ [Uu][Nn][Rr][Aa][Tt][Ee][Dd] ]]; then
        PARSED_EDITION="UNRATED"
    elif [[ $basename =~ [Rr][Ee][Mm][Aa][Ss][Tt][Ee][Rr][Ee][Dd] ]]; then
        PARSED_EDITION="REMASTERED"
    elif [[ $basename =~ [Rr][Ee][Ss][Tt][Oo][Rr][Ee][Dd] ]]; then
        PARSED_EDITION="RESTORED"
    elif [[ $basename =~ [Uu][Nn][Cc][Uu][Tt] ]]; then
        PARSED_EDITION="UNCUT"
    elif [[ $basename =~ [Rr][Ee][Dd][Uu][Xx] ]]; then
        PARSED_EDITION="REDUX"
    elif [[ $basename =~ [Uu][Ll][Tt][Ii][Mm][Aa][Tt][Ee] ]]; then
        PARSED_EDITION="ULTIMATE"
    fi
    
    # Extract 3D - detect various 3D formats (case-insensitive)
    # True 3D: 3D, MVC
    # Side-by-Side: SBS, HSBS, H-SBS, Half-SBS, Half.SBS
    # Over-Under: OU, HOU, H-OU, Half-OU
    # Top-and-Bottom: TAB, HTAB, H-TAB
    PARSED_3D_FORMAT=""
    if [[ $basename =~ [Hh][-.]?[Ss][Bb][Ss] ]] || [[ $basename =~ [Hh]alf[-.]?[Ss][Bb][Ss] ]]; then
        PARSED_3D=true
        PARSED_3D_FORMAT="HSBS"
        should_debug high && echo "[DEBUG] 3D detected: HSBS (Half Side-by-Side)" >&2
    elif [[ $basename =~ [^A-Za-z][Ss][Bb][Ss][^A-Za-z] ]]; then
        PARSED_3D=true
        PARSED_3D_FORMAT="SBS"
        should_debug high && echo "[DEBUG] 3D detected: SBS (Side-by-Side)" >&2
    elif [[ $basename =~ [Hh][-.]?[Oo][Uu] ]] || [[ $basename =~ [Hh]alf[-.]?[Oo][Uu] ]]; then
        PARSED_3D=true
        PARSED_3D_FORMAT="HOU"
        should_debug high && echo "[DEBUG] 3D detected: HOU (Half Over-Under)" >&2
    elif [[ $basename =~ [^A-Za-z][Oo][Uu][^A-Za-z] ]]; then
        PARSED_3D=true
        PARSED_3D_FORMAT="OU"
        should_debug high && echo "[DEBUG] 3D detected: OU (Over-Under)" >&2
    elif [[ $basename =~ [Hh][-.]?[Tt][Aa][Bb] ]]; then
        PARSED_3D=true
        PARSED_3D_FORMAT="HTAB"
        should_debug high && echo "[DEBUG] 3D detected: HTAB (Half Top-and-Bottom)" >&2
    elif [[ $basename =~ [^A-Za-z][Tt][Aa][Bb][^A-Za-z] ]]; then
        PARSED_3D=true
        PARSED_3D_FORMAT="TAB"
        should_debug high && echo "[DEBUG] 3D detected: TAB (Top-and-Bottom)" >&2
    elif [[ $basename =~ [Mm][Vv][Cc] ]]; then
        PARSED_3D=true
        PARSED_3D_FORMAT="MVC"
        should_debug high && echo "[DEBUG] 3D detected: MVC (Multi-View Coding)" >&2
    elif [[ $basename =~ 3D ]]; then
        PARSED_3D=true
        should_debug high && echo "[DEBUG] 3D detected from filename pattern" >&2
    fi
    
    # Extract release group (multiple formats)
    # To avoid matching parts of the title, only look at the portion after the title/year
    local metadata_portion="$basename"
    if [[ -n "$PARSED_TITLE" && -n "$PARSED_YEAR" ]]; then
        # Remove title and year from start to get metadata portion
        local title_normalized=$(echo "$PARSED_TITLE" | sed 's/ /[._[:space:]-]*/g')
        metadata_portion=$(echo "$basename" | sed -E "s/^.*${PARSED_YEAR}[._[:space:]-]*//" )
    elif [[ -n "$PARSED_TITLE" ]]; then
        # If only title (no year), try to isolate metadata portion
        local title_normalized=$(echo "$PARSED_TITLE" | sed 's/ /[._[:space:]-]*/g')
        # Look for common quality indicators to find where metadata starts
        if [[ $basename =~ (1080p|720p|480p|2160p|4K|BluRay|BRRip|WEBRip|WEB-DL|HDTV|DVDRip) ]]; then
            metadata_portion=$(echo "$basename" | sed -E 's/^.*([0-9]{3,4}p|4K|BluRay|BRRip|WEBRip|WEB-DL|HDTV|DVDRip)/\1/')
        fi
    fi
    
    # Format 1: -[ReleaseGroup] (e.g., -[YTS.MX])
    # Allow optional tracker tag at end like [PublicHD], [rarbg], etc.
    if [[ $metadata_portion =~ -\[([A-Za-z0-9\.]+)\]([[:space:]]*\[[^]]+\])?$ ]]; then
        PARSED_RELEASE_GROUP="${BASH_REMATCH[1]}"
    # Format 2: -ReleaseGroup (e.g., -RARBG, -Dread-Team, -Japhson [PublicHD])
    # Allow hyphens within release group names and optional tracker tag at end
    elif [[ $metadata_portion =~ (1080p|720p|480p|2160p|BluRay|WEBRip|x264|x265|H\.?264|H\.?265|XviD).*-([A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9]|[A-Za-z0-9])([[:space:]]*\[[^]]+\])?$ ]]; then
        PARSED_RELEASE_GROUP="${BASH_REMATCH[2]}"
    # Format 3: Separator + ReleaseGroup after codec (e.g., .x264.YIFY, .XviD-aAF)
    # Allow dot or hyphen separator and optional tracker tag at end
    elif [[ $metadata_portion =~ \.(x264|x265|H\.?264|H\.?265|AVC|HEVC|XviD)[\.\-]([A-Za-z0-9]+)([[:space:]]*\[[^]]+\])?$ ]]; then
        PARSED_RELEASE_GROUP="${BASH_REMATCH[2]}"
    # Format 4: Space-separated after codec (e.g., "x265 Silence" or "H.264 NTb")
    elif [[ $metadata_portion =~ (x264|x265|H\.?264|H\.?265|AVC|HEVC|XviD)[[:space:]]+([A-Za-z0-9]+)(\)|[[:space:]]*\[[^]]+\])?$ ]]; then
        PARSED_RELEASE_GROUP="${BASH_REMATCH[2]}"
    fi
    
    # Extract IMDb ID
    if [[ $basename =~ (tt[0-9]{7,8}) ]]; then
        PARSED_IMDB="${BASH_REMATCH[1]}"
    fi
}

# Process single file (used by both single and batch mode)
process_file() {
    local source_file="$1"
    local auto_mode="$2"
    local skip_duplicate_check="${3:-false}"  # New parameter to bypass duplicate checking
    
    # FIRST: Check if file still exists (may have been moved/deleted by another instance)
    if [[ ! -f "$source_file" ]]; then
        should_debug low && echo "[DEBUG] Source file no longer exists: $source_file" >&2
        echo "⏭️  File no longer exists (moved/processed by another instance): $(basename "$source_file")"
        return 4  # Exit code 4: already processed
    fi
    
    # Get inode first for lock tracking
    local source_inode=$(stat -f "%i" "$source_file" 2>/dev/null || stat -c "%i" "$source_file" 2>/dev/null)
    
    # Handle case where stat failed (file disappeared between existence check and stat)
    if [[ -z "$source_inode" ]]; then
        should_debug low && echo "[DEBUG] Could not get inode for source file (file may have been deleted): $source_file" >&2
        echo "⏭️  File disappeared during processing (processed by another instance): $(basename "$source_file")"
        return 4  # Exit code 4: already processed
    fi
    
    # EARLY CHECK: Skip if source file is already hardlinked to destination
    # This saves parsing, cache lookups, and API calls for files already processed
    # Skip this check if manually selected (allow reprocessing)
    if [[ "$skip_duplicate_check" != "true" ]]; then
        should_debug low && echo "[DEBUG] Quick check: Is source already hardlinked to destination?" >&2
        
        # Check if any file in destination has the same inode (already hardlinked)
        if [[ -n "$DESTINATION" && -d "$DESTINATION" ]]; then
            local already_linked=$(find "$DESTINATION" -type f -inum "$source_inode" 2>/dev/null | head -n 1)
            if [[ -n "$already_linked" ]]; then
                should_debug low && echo "[DEBUG] Source inode $source_inode already exists at: $already_linked" >&2
                echo -e "${CYAN}${GREEN}✓${CYAN} File already hardlinked to destination, skipping: $(basename "$source_file")${NC}"
                return 2  # Exit code 2: already linked before lock
            fi
        fi
        should_debug low && echo "[DEBUG] Source not yet hardlinked, proceeding with processing" >&2
    else
        should_debug low && echo "[DEBUG] Skipping 'already hardlinked' check (manually selected file)" >&2
    fi
    
    # Load Extension Duplicate Mode setting (ensure it's set correctly for each file)
    if [[ -z "$EXTENSION_DUP_MODE" ]] || [[ "$EXTENSION_DUP_MODE" != "off" && "$EXTENSION_DUP_MODE" != "resolution" && "$EXTENSION_DUP_MODE" != "bitrate" ]]; then
        if [[ -f "${CACHE_DIR}/extension_dup_mode.txt" ]]; then
            EXTENSION_DUP_MODE=$(cat "${CACHE_DIR}/extension_dup_mode.txt")
        else
            EXTENSION_DUP_MODE="off"
        fi
        should_debug low && echo "[DEBUG] Loaded EXTENSION_DUP_MODE: $EXTENSION_DUP_MODE" >&2
    fi
    
    # SKIP: Check for duplicate files with different extensions based on EXTENSION_DUP_MODE
    # E.g., "Movie.mp4" (1080p) and "Movie.mov" (720p) in same folder
    # Skip this check if manually selected during review OR if mode is "off"
    if [[ "$skip_duplicate_check" != "true" && "$EXTENSION_DUP_MODE" != "off" ]]; then
        local base_name="${source_file%.*}"
        local parent_dir=$(dirname "$source_file")
        
        # Find all files with same base name but different extensions
        local best_file=""
        local best_resolution=0
        local best_bitrate=0
        local current_resolution=$(get_video_resolution_height "$source_file")
        local current_bitrate=$(get_video_bitrate "$source_file")
        
        should_debug low && echo "[DEBUG] Checking for duplicates of: $(basename "$source_file") (${current_resolution}p, $(format_bitrate $current_bitrate))" >&2
        
        while IFS= read -r -d '' duplicate_file; do
            # Skip .ia files in this comparison
            [[ "$duplicate_file" =~ \.ia\.[^.]+$ ]] && continue
            
            local file_resolution=$(get_video_resolution_height "$duplicate_file")
            local file_bitrate=$(get_video_bitrate "$duplicate_file")
            
            should_debug low && echo "[DEBUG]   Comparing with: $(basename "$duplicate_file") (${file_resolution}p, $(format_bitrate $file_bitrate))" >&2
        
            # Compare based on mode
            local should_replace=false
            if [[ "$EXTENSION_DUP_MODE" == "bitrate" ]]; then
                # Bitrate mode: bitrate first, resolution as tiebreaker
                if [[ $file_bitrate -gt $best_bitrate ]] || 
                   [[ $file_bitrate -eq $best_bitrate && $file_resolution -gt $best_resolution ]]; then
                    should_replace=true
                fi
            else
                # Resolution mode: resolution first, bitrate as tiebreaker
                if [[ $file_resolution -gt $best_resolution ]] || 
                   [[ $file_resolution -eq $best_resolution && $file_bitrate -gt $best_bitrate ]]; then
                    should_replace=true
                fi
            fi
            
            if [[ "$should_replace" == "true" ]]; then
                best_resolution=$file_resolution
                best_bitrate=$file_bitrate
                best_file="$duplicate_file"
            fi
        done < <(find "$parent_dir" -maxdepth 1 -type f -name "$(basename "$base_name").*" -print0 2>/dev/null)
    
    # If this file is not the best quality, skip it
    if [[ -n "$best_file" && "$best_file" != "$source_file" ]]; then
        if [[ $current_resolution -lt $best_resolution ]]; then
            should_debug low && echo "[DEBUG] Skipping lower resolution duplicate: $(basename "$source_file") (${current_resolution}p) - keeping higher resolution $(basename "$best_file") (${best_resolution}p)" >&2
            echo "  ✗ Skipping lower resolution duplicate: $(basename "$source_file") (${current_resolution}p) - keeping $(basename "$best_file") (${best_resolution}p)"
        else
            local current_bitrate_formatted=$(format_bitrate "$current_bitrate")
            local best_bitrate_formatted=$(format_bitrate "$best_bitrate")
            should_debug low && echo "[DEBUG] Skipping lower bitrate duplicate: $(basename "$source_file") (${current_bitrate_formatted}) - keeping higher bitrate $(basename "$best_file") (${best_bitrate_formatted})" >&2
            echo "  ✗ Skipping lower bitrate duplicate: $(basename "$source_file") (${current_bitrate_formatted}) - keeping $(basename "$best_file") (${best_bitrate_formatted})"
        fi
        return 6  # Exit code 6: skipped (lower quality duplicate)
    fi
    
    should_debug low && echo "[DEBUG] This is the best quality version, proceeding with processing" >&2
    else
        should_debug low && echo "[DEBUG] Skipping duplicate check (manually selected file or EXTENSION_DUP_MODE is off)" >&2
    fi
    
    # SKIP: Check if this is a .ia file with a non-.ia duplicate
    # Internet Archive files often have .ia before extension (e.g., file.ia.mp4)
    if [[ "$source_file" =~ \.ia\.[^.]+$ ]]; then
        # This file has .ia before the extension - check if non-.ia version exists
        local non_ia_file="${source_file/.ia./.}"
        if [[ -f "$non_ia_file" ]]; then
            should_debug low && echo "[DEBUG] Skipping .ia file - non-.ia version exists: $non_ia_file" >&2
            echo "⏭️  Skipping Internet Archive duplicate (non-.ia version exists): $(basename "$source_file")"
            return 5  # Exit code 5: .ia duplicate skipped
        fi
        should_debug low && echo "[DEBUG] .ia file but no non-.ia duplicate found, processing normally" >&2
    fi
    
    # Try to acquire lock for this file (prevents multiple instances from processing same file)
    if ! acquire_file_lock "$source_file"; then
        echo "⏭️  File locked by another instance, skipping: $(basename "$source_file")"
        should_debug low && echo "[DEBUG] File is locked by another instance, skipping: $(basename "$source_file")" >&2
        return 3  # Exit code 3: locked by another instance
    fi
    
    echo "🔒 Lock acquired for: $(basename "$source_file")"
    
    # Double-check after acquiring lock (in case another instance just finished)
    if [[ -n "$DESTINATION" && -d "$DESTINATION" ]]; then
        local already_linked=$(find "$DESTINATION" -type f -inum "$source_inode" 2>/dev/null | head -n 1)
        if [[ -n "$already_linked" ]]; then
            echo "⏭️  Already processed by another instance while waiting: $(basename "$source_file")"
            should_debug low && echo "[DEBUG] File was processed while waiting for lock, skipping: $(basename "$source_file")" >&2
            release_file_lock "$source_file"
            return 4  # Exit code 4: already linked after lock (processed while waiting)
        fi
    fi
    should_debug low && echo "[DEBUG] Source not yet hardlinked, proceeding with processing" >&2
    
    # Reset parsed variables
    PARSED_TITLE=""
    PARSED_YEAR=""
    PARSED_IMDB=""
    PARSED_FULL_QUALITY=""
    PARSED_AUDIO_CODEC=""
    PARSED_AUDIO_CHANNELS=""
    PARSED_HDR=""
    PARSED_VIDEO_CODEC=""
    PARSED_RELEASE_GROUP=""
    PARSED_EDITION=""
    PARSED_3D=false
    
    # Reset main variables to prevent reuse from previous file
    TITLE=""
    YEAR=""
    IMDB=""
    TMDB=""
    CACHED_DATA=""
    
    # Try to use cached parse results first (from duplicate scan - filename already parsed)
    local cached_data=$(lookup_parse_cache "$source_file")
    
    if [[ -n "$cached_data" ]]; then
        # Use cached title/year from duplicate scan (faster than re-parsing)
        local cached_title="${cached_data%%|*}"  # Extract first field
        local cached_year="${cached_data#*|}"    # Extract second field
        should_debug high && echo "[DEBUG] Using cached title/year from duplicate scan: title='$cached_title' year='$cached_year'" >&2
        
        # But still parse for accurate metadata (MediaInfo for codecs, etc.) - silently
        should_debug high && echo -e "${BRIGHT_RED}[DEBUG] Parsing filename for metadata: '$(basename "$source_file")'${NC}" >&2
        
        # Temporarily disable debug output during parse to avoid duplicate messages
        local orig_debug_level="$DEBUG_LEVEL_MOVIES"
        DEBUG_LEVEL_MOVIES="off"
        parse_filename "$source_file"
        DEBUG_LEVEL_MOVIES="$orig_debug_level"
        
        # Override parsed title/year with cached values ONLY if both are present
        # Don't use cached data if year is missing (could match wrong movie in cache)
        # (e.g., "aaf-teosc" from filename vs proper title from folder)
        if [[ -n "$cached_title" && -n "$cached_year" ]]; then
            PARSED_TITLE="$cached_title"
            PARSED_YEAR="$cached_year"
        elif [[ -n "$cached_title" ]]; then
            # Year is missing from cache - use cached title but keep parsed year (if any)
            PARSED_TITLE="$cached_title"
            should_debug high && echo "[DEBUG] Cached year empty, keeping parsed year: '$PARSED_YEAR'" >&2
        fi
        
        # If filename has no quality, release group, or codecs, try extracting from folder
        if [[ -z "$PARSED_FULL_QUALITY" || -z "$PARSED_RELEASE_GROUP" || -z "$PARSED_VIDEO_CODEC" || -z "$PARSED_AUDIO_CODEC" ]]; then
            local parent_folder=$(dirname "$source_file")
            local folder_name=$(basename "$parent_folder")
            should_debug high && echo -e "${NEON_GREEN}[DEBUG] Filename missing metadata, extracting from folder: '$folder_name'${NC}" >&2
            
            # Store what we have from filename
            local file_quality="$PARSED_FULL_QUALITY"
            local file_release_group="$PARSED_RELEASE_GROUP"
            local file_video_codec="$PARSED_VIDEO_CODEC"
            local file_audio_codec="$PARSED_AUDIO_CODEC"
            local file_audio_channels="$PARSED_AUDIO_CHANNELS"
            local file_hdr="$PARSED_HDR"
            
            should_debug high && echo "[DEBUG] Before folder parse - file_quality='$file_quality' file_release_group='$file_release_group' file_video_codec='$file_video_codec' file_audio_codec='$file_audio_codec'" >&2
            
            # Parse folder for metadata (keep debug off to avoid duplicate output)
            local orig_debug_level="$DEBUG_LEVEL_MOVIES"
            DEBUG_LEVEL_MOVIES="off"
            parse_filename "$parent_folder" "folder"
            DEBUG_LEVEL_MOVIES="$orig_debug_level"
            
            should_debug high && echo "[DEBUG] After folder parse - folder PARSED_FULL_QUALITY='$PARSED_FULL_QUALITY' folder PARSED_RELEASE_GROUP='$PARSED_RELEASE_GROUP' folder PARSED_VIDEO_CODEC='$PARSED_VIDEO_CODEC' folder PARSED_AUDIO_CODEC='$PARSED_AUDIO_CODEC'" >&2
            
            # Merge quality: if filename has only resolution and folder has source, combine them
            if [[ -n "$file_quality" && "$file_quality" =~ ^[0-9]+p$ && -n "$PARSED_FULL_QUALITY" && "$PARSED_FULL_QUALITY" =~ - ]]; then
                # Filename has resolution only (720p), folder has full quality (Bluray-720p)
                # Use folder's complete quality
                should_debug high && echo "[DEBUG] ✓ Using complete quality from folder: '$PARSED_FULL_QUALITY' (filename had: '$file_quality')" >&2
            elif [[ -n "$file_quality" ]]; then
                # Filename has quality, keep it
                should_debug high && echo "[DEBUG] ✓ Keeping filename quality: '$file_quality' (ignoring folder: '$PARSED_FULL_QUALITY')" >&2
                PARSED_FULL_QUALITY="$file_quality"
            else
                should_debug high && echo "[DEBUG] ✓ Using folder quality: '$PARSED_FULL_QUALITY' (filename had none)" >&2
            fi
            
            # Use folder release group only if filename didn't have one
            if [[ -n "$file_release_group" ]]; then
                PARSED_RELEASE_GROUP="$file_release_group"
                should_debug high && echo "[DEBUG] ✓ Keeping filename release group: '$file_release_group'" >&2
            else
                should_debug high && echo "[DEBUG] ✓ Using folder release group: '$PARSED_RELEASE_GROUP'" >&2
            fi
            
            # Use folder video codec only if filename didn't have one
            if [[ -n "$file_video_codec" ]]; then
                PARSED_VIDEO_CODEC="$file_video_codec"
                should_debug high && echo "[DEBUG] ✓ Keeping filename video codec: '$file_video_codec'" >&2
            else
                should_debug high && echo "[DEBUG] ✓ Using folder video codec: '$PARSED_VIDEO_CODEC'" >&2
            fi
            
            # Use folder audio codec/channels only if filename didn't have them
            if [[ -n "$file_audio_codec" ]]; then
                PARSED_AUDIO_CODEC="$file_audio_codec"
                PARSED_AUDIO_CHANNELS="$file_audio_channels"
                should_debug high && echo "[DEBUG] ✓ Keeping filename audio: '$file_audio_codec' channels='$file_audio_channels'" >&2
            else
                should_debug high && echo "[DEBUG] ✓ Using folder audio: '$PARSED_AUDIO_CODEC' channels='$PARSED_AUDIO_CHANNELS'" >&2
            fi
            
            # Use folder HDR only if filename didn't have it
            if [[ -n "$file_hdr" ]]; then
                PARSED_HDR="$file_hdr"
                should_debug high && echo "[DEBUG] ✓ Keeping filename HDR: '$file_hdr'" >&2
            else
                should_debug high && echo "[DEBUG] ✓ Using folder HDR: '$PARSED_HDR'" >&2
            fi
            
            should_debug high && echo "[DEBUG] Final after merge - PARSED_FULL_QUALITY='$PARSED_FULL_QUALITY' PARSED_RELEASE_GROUP='$PARSED_RELEASE_GROUP' PARSED_VIDEO_CODEC='$PARSED_VIDEO_CODEC' PARSED_AUDIO_CODEC='$PARSED_AUDIO_CODEC'" >&2
            
            # Restore cached title/year (folder parse may have overwritten them)
            PARSED_TITLE="$cached_title"
            PARSED_YEAR="$cached_year"
        fi
    else
        # No cached results, parse filename first
        should_debug high && echo "[DEBUG] No cached parse found, parsing filename: '$(basename "$source_file")'" >&2
        parse_filename "$source_file"
        
        # If filename parsing failed to get title/year, try folder as fallback
        if [[ -z "$PARSED_TITLE" || -z "$PARSED_YEAR" ]]; then
            local parent_folder=$(dirname "$source_file")
            local folder_name=$(basename "$parent_folder")
            should_debug high && echo -e "${NEON_GREEN}[DEBUG] Filename parse incomplete (title='$PARSED_TITLE' year='$PARSED_YEAR'), parsing folder name: '$folder_name'${NC}" >&2
            
            # Store filename parse results before folder parse
            local file_quality="$PARSED_FULL_QUALITY"
            local file_video_codec="$PARSED_VIDEO_CODEC"
            local file_audio_codec="$PARSED_AUDIO_CODEC"
            local file_audio_channels="$PARSED_AUDIO_CHANNELS"
            local file_hdr="$PARSED_HDR"
            local file_edition="$PARSED_EDITION"
            local file_3d=$PARSED_3D
            local file_release_group="$PARSED_RELEASE_GROUP"
            
            # Parse folder
            parse_filename "$parent_folder" "folder"
            
            # Use folder title/year if filename didn't have them
            [[ -z "$PARSED_TITLE" ]] && echo "[DEBUG] No title from filename or folder" >&2
            [[ -z "$PARSED_YEAR" ]] && echo "[DEBUG] No year from filename or folder" >&2
            
            # Prefer filename metadata if available, otherwise keep folder metadata
            # This way "aaf-teosc.1974.avi" (no quality) gets quality from folder "DVDRip"
            [[ -n "$file_quality" ]] && PARSED_FULL_QUALITY="$file_quality"
            [[ -n "$file_video_codec" ]] && PARSED_VIDEO_CODEC="$file_video_codec"
            [[ -n "$file_audio_codec" ]] && PARSED_AUDIO_CODEC="$file_audio_codec"
            [[ -n "$file_audio_channels" ]] && PARSED_AUDIO_CHANNELS="$file_audio_channels"
            [[ -n "$file_hdr" ]] && PARSED_HDR="$file_hdr"
            [[ -n "$file_edition" ]] && PARSED_EDITION="$file_edition"
            [[ $file_3d == true ]] && PARSED_3D=true
            # Only restore release group if filename actually had one
            [[ -n "$file_release_group" ]] && PARSED_RELEASE_GROUP="$file_release_group"
        else
            # If filename had title/year, we still need to check folder for missing metadata
            # Store current parsed values
            local file_release_group="$PARSED_RELEASE_GROUP"
            local file_quality="$PARSED_FULL_QUALITY"
            local file_hdr="$PARSED_HDR"
            local file_edition="$PARSED_EDITION"
            
            # Parse folder to get metadata
            local parent_folder=$(dirname "$source_file")
            parse_filename "$parent_folder" "folder"
            
            # Use folder metadata only if filename didn't have it
            [[ -z "$file_release_group" && -n "$PARSED_RELEASE_GROUP" ]] && echo "[DEBUG] Using release group from folder: '$PARSED_RELEASE_GROUP'" >&2 || PARSED_RELEASE_GROUP="$file_release_group"
            [[ -z "$file_quality" && -n "$PARSED_FULL_QUALITY" ]] && echo "[DEBUG] Using quality from folder: '$PARSED_FULL_QUALITY'" >&2 || PARSED_FULL_QUALITY="$file_quality"
            [[ -z "$file_hdr" && -n "$PARSED_HDR" ]] && echo "[DEBUG] Using HDR from folder: '$PARSED_HDR'" >&2 || PARSED_HDR="$file_hdr"
            [[ -z "$file_edition" && -n "$PARSED_EDITION" ]] && echo "[DEBUG] Using edition from folder: '$PARSED_EDITION'" >&2 || PARSED_EDITION="$file_edition"
        fi
    fi
    
    # Extract MediaInfo from file (overrides filename parsing for accuracy)
    # Behavior depends on MEDIAINFO_TOOL setting (mediainfo/ffprobe/off)
    MEDIAINFO_VIDEO_CODEC=""
    MEDIAINFO_AUDIO_CODEC=""
    MEDIAINFO_AUDIO_CHANNELS=""
    MEDIAINFO_HDR=""
    MEDIAINFO_RESOLUTION=""
    MEDIAINFO_3D=false
    
    # Call MediaInfo if tool is enabled (not "off"), regardless of auto mode
    should_debug high && echo "[DEBUG] Extraction tool='$MEDIAINFO_TOOL', calling get_mediainfo_from_file" >&2
    if [[ "$MEDIAINFO_TOOL" != "off" ]] && get_mediainfo_from_file "$source_file"; then
        should_debug high && echo "[DEBUG] ✓ $MEDIAINFO_TOOL extraction succeeded" >&2
        should_debug high && echo "[DEBUG] [$MEDIAINFO_TOOL] VIDEO_CODEC='$MEDIAINFO_VIDEO_CODEC' AUDIO_CODEC='$MEDIAINFO_AUDIO_CODEC' AUDIO_CHANNELS='$MEDIAINFO_AUDIO_CHANNELS' RESOLUTION='$MEDIAINFO_RESOLUTION'" >&2
        # Use MediaInfo to override/enhance parsed values
        [[ -n "$MEDIAINFO_VIDEO_CODEC" ]] && PARSED_VIDEO_CODEC="$MEDIAINFO_VIDEO_CODEC"
        [[ -n "$MEDIAINFO_AUDIO_CODEC" ]] && PARSED_AUDIO_CODEC="$MEDIAINFO_AUDIO_CODEC"
        [[ -n "$MEDIAINFO_AUDIO_CHANNELS" ]] && PARSED_AUDIO_CHANNELS="$MEDIAINFO_AUDIO_CHANNELS"
        [[ -n "$MEDIAINFO_HDR" ]] && PARSED_HDR="$MEDIAINFO_HDR"
        [[ "$MEDIAINFO_3D" == true ]] && PARSED_3D=true
        should_debug high && echo "[DEBUG] After assignment - PARSED_VIDEO_CODEC='$PARSED_VIDEO_CODEC' PARSED_AUDIO_CODEC='$PARSED_AUDIO_CODEC' PARSED_AUDIO_CHANNELS='$PARSED_AUDIO_CHANNELS'" >&2
        
        # Override quality resolution with actual mediainfo resolution
        if [[ -n "$MEDIAINFO_RESOLUTION" ]]; then
            if [[ -z "$PARSED_FULL_QUALITY" ]]; then
                # No quality found in filename, use resolution only
                PARSED_FULL_QUALITY="$MEDIAINFO_RESOLUTION"
            elif [[ "$PARSED_FULL_QUALITY" =~ ^([^-]+)-[0-9]+p$ ]]; then
                # Quality has source-resolution format (e.g., "Bluray-1080p"), replace resolution
                PARSED_FULL_QUALITY="${BASH_REMATCH[1]}-${MEDIAINFO_RESOLUTION}"
            elif [[ "$PARSED_FULL_QUALITY" =~ ^[0-9]+p$ ]]; then
                # Quality is just resolution (e.g., "1080p"), replace it
                PARSED_FULL_QUALITY="$MEDIAINFO_RESOLUTION"
            elif [[ ! "$PARSED_FULL_QUALITY" =~ [0-9]+p ]]; then
                # Quality is just source (e.g., "Bluray"), append resolution
                PARSED_FULL_QUALITY="${PARSED_FULL_QUALITY}-${MEDIAINFO_RESOLUTION}"
            fi
        fi
    else
        should_debug high && echo "[DEBUG] MediaInfo extraction skipped or failed. MEDIAINFO_TOOL='$MEDIAINFO_TOOL'" >&2
    fi
    
    # Display parsed info
    if [[ "$auto_mode" != "y" ]]; then
        print_info "========================================="
        print_info "Detected from file:"
        print_info "========================================="
        [[ -n "$PARSED_TITLE" ]] && print_success "Title: $PARSED_TITLE"
        [[ -n "$PARSED_YEAR" ]] && print_success "Year: $PARSED_YEAR"
        [[ -n "$PARSED_IMDB" ]] && print_success "IMDb: $PARSED_IMDB"
        [[ -n "$PARSED_FULL_QUALITY" ]] && print_success "Quality: $PARSED_FULL_QUALITY"
        [[ -n "$PARSED_VIDEO_CODEC" ]] && print_success "Video: $PARSED_VIDEO_CODEC"
        [[ -n "$PARSED_AUDIO_CODEC" ]] && print_success "Audio: $PARSED_AUDIO_CODEC ${PARSED_AUDIO_CHANNELS:+$PARSED_AUDIO_CHANNELS}"
        [[ -n "$PARSED_HDR" ]] && print_success "HDR: $PARSED_HDR"
        [[ -n "$PARSED_EDITION" ]] && print_success "Edition: $PARSED_EDITION"
        $PARSED_3D && print_success "3D: Yes"
        [[ -n "$PARSED_RELEASE_GROUP" ]] && print_success "Group: $PARSED_RELEASE_GROUP"
        echo ""
    fi
    
    # Get title
    if [[ -n "$PARSED_TITLE" ]]; then
        TITLE="$PARSED_TITLE"
        if [[ "$auto_mode" != "y" ]]; then
            print_info "Title [${PARSED_TITLE}]:"
            read -r input
            [[ -n "$input" ]] && TITLE="$input"
        fi
    else
        if [[ "$auto_mode" == "y" ]]; then
            print_error "Cannot auto-process: title not detected"
            release_file_lock "$source_file"
            return 1
        fi
        print_info "Title:"
        read -r TITLE
    fi
    
    # Get year (optional - can be empty)
    if [[ -n "$PARSED_YEAR" ]]; then
        YEAR="$PARSED_YEAR"
        if [[ "$auto_mode" != "y" ]]; then
            print_info "Year [${PARSED_YEAR}]:"
            read -r input
            [[ -n "$input" ]] && YEAR="$input"
        fi
    else
        if [[ "$auto_mode" == "y" ]]; then
            # Year is optional - proceed without it (will search TMDb without year filter)
            YEAR=""
            print_warning "Year not detected - will search TMDb without year filter"
        else
            print_info "Year:"
            read -r YEAR
        fi
    fi
    
    # Set INTERACTIVE_MODE based on auto_mode for functions that need to know
    if [[ "$auto_mode" == "y" ]]; then
        INTERACTIVE_MODE="false"
    else
        INTERACTIVE_MODE="true"
    fi
    
    # In manual mode, show a quick lookup result with poster after title/year entry
    if [[ "$auto_mode" != "y" ]]; then
        echo ""
        echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${CYAN}Looking up: $TITLE ($YEAR)${NC}"
        echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
    fi
    
    # Check cache or search online
    should_debug high && echo "[DEBUG] Looking up metadata for: TITLE='$TITLE' YEAR='$YEAR' PARSED_IMDB='$PARSED_IMDB'" >&2
    
    CACHED_DATA=$(get_cached_movie "$TITLE" "$YEAR")
    if [[ -n "$CACHED_DATA" ]]; then
        IMDB=$(extract_from_cache "$CACHED_DATA" "imdb")
        TMDB=$(extract_from_cache "$CACHED_DATA" "tmdb")
        should_debug high && echo "[DEBUG] Found in cache: IMDb=$IMDB, TMDb=$TMDB" >&2
        print_info "✓ Using cached metadata: IMDb=$IMDB, TMDb=$TMDB"
        
        # Get canonical title and year from TMDb (same as online lookup logic)
        local original_title="$TITLE"
        if [[ -n "$TMDB" && -n "$TMDB_API_KEY" ]]; then
            should_debug high && echo "[DEBUG] Fetching canonical title/year from TMDb for cached movie (TMDb ID: $TMDB)" >&2
            api_delay
            local tmdb_url="${TMDB_API_BASE}/movie/${TMDB}?api_key=${TMDB_API_KEY}"
            local tmdb_details=$(curl -s --connect-timeout 10 --max-time 30 "$tmdb_url" 2>/dev/null)
            
            if [[ -n "$tmdb_details" ]]; then
                local canonical_title=$(extract_title_from_details "$tmdb_details")
                if [[ -n "$canonical_title" && ! "$canonical_title" =~ ^(Wait and [Tt]ry [Aa]gain|Rate [Ll]imit|Throttled)$ ]]; then
                    TITLE="$canonical_title"
                    should_debug high && echo "[DEBUG] Using canonical title from TMDb for cached movie: $TITLE" >&2
                else
                    should_debug high && echo "[DEBUG] Canonical title extraction failed or rate limited, keeping parsed title: $TITLE" >&2
                fi
                
                # Extract canonical year from TMDb details
                local canonical_year=$(extract_year_from_details "$tmdb_details")
                if [[ -n "$canonical_year" ]]; then
                    YEAR="$canonical_year"
                    should_debug high && echo "[DEBUG] Using canonical year from TMDb for cached movie: $YEAR" >&2
                fi
            else
                should_debug high && echo "[DEBUG] Failed to fetch TMDb details for cached movie" >&2
            fi
        fi
    else
        should_debug high && echo "[DEBUG] Not in cache, checking JSON database before online lookup" >&2
        
        # Try to get movie from JSON database by title/year before making API calls (only in hybrid/json_only modes)
        if [[ "$JSON_DB_MODE" != "api_only" ]]; then
            local json_tmdb_id=$(get_tmdb_id_from_json_by_title_year "$TITLE" "$YEAR" "$source_file")
            if [[ -n "$json_tmdb_id" ]]; then
                should_debug high && echo "[DEBUG] Found TMDb ID in JSON database: $json_tmdb_id" >&2
                local json_data=$(get_json_from_db_by_tmdb "$json_tmdb_id")
                if [[ -n "$json_data" ]]; then
                    TMDB="$json_tmdb_id"
                    IMDB=$(echo "$json_data" | grep -oE '"imdb_id":"tt[0-9]+"' | head -1 | sed 's/"imdb_id":"//;s/"//g' | tr -d '\n\r')
                    should_debug high && echo "[DEBUG] Retrieved from JSON database: TMDb=$TMDB, IMDb=$IMDB" >&2
                    print_info "✓ Using JSON database: IMDb=$IMDB, TMDb=$TMDB"
                    
                    # Save to cache for faster lookup next time (only if both IDs exist)
                    if [[ -n "$IMDB" && -n "$TMDB" ]]; then
                        local json_title=$(extract_title_from_details "$json_data")
                        # Remove any newlines from title
                        json_title=$(echo "$json_title" | tr -d '\n\r' | sed 's/  */ /g')
                        save_to_cache "$json_title" "$YEAR" "$IMDB" "$TMDB"
                    else
                        should_debug high && echo "[DEBUG] Not saving to cache - missing IMDb='$IMDB' or TMDb='$TMDB' from JSON DB" >&2
                    fi
                fi
            fi
        fi
        
        # If not found in JSON database, start online lookup
        if [[ -z "$TMDB" ]]; then
            should_debug high && echo "[DEBUG] Not in JSON database, starting online lookup" >&2
        
        # Extract folder name for potential fallback lookup
        local parent_folder=$(dirname "$source_file")
        local folder_name=$(basename "$parent_folder")
        local folder_title=""
        local folder_year=""
        
        # Parse folder name to extract title and year
        # First, clean up common torrent site prefixes
        local clean_folder="$folder_name"
        clean_folder=$(echo "$clean_folder" | sed -E 's/^[[:space:]]*\[[^]]*\][[:space:]]*-?[[:space:]]*//')
        
        # Try pattern with parentheses: "Title (1974)"
        if [[ "$clean_folder" =~ (.*)[[:space:]]*\(([0-9]{4})\) ]]; then
            folder_title="${BASH_REMATCH[1]}"
            folder_year="${BASH_REMATCH[2]}"
            folder_title=$(echo "$folder_title" | tr '.' ' ' | sed 's/  */ /g' | sed 's/^ //;s/ $//')
            should_debug high && echo "[DEBUG] Extracted from folder (parentheses): title='$folder_title' year='$folder_year'" >&2
        # Try pattern without parentheses: "Title.1974.Quality"
        elif [[ "$clean_folder" =~ (.*)[\._]((19|20)[0-9]{2})[\._] ]]; then
            folder_title="${BASH_REMATCH[1]}"
            folder_year="${BASH_REMATCH[2]}"
            folder_title=$(echo "$folder_title" | tr '._' ' ' | sed 's/  */ /g' | sed 's/^ //;s/ $//')
            should_debug high && echo "[DEBUG] Extracted from folder (dot/underscore): title='$folder_title' year='$folder_year'" >&2
        else
            # Regex patterns didn't work, try parse_filename() as fallback
            should_debug high && echo "[DEBUG] Regex patterns failed, using parse_filename() on folder" >&2
            
            # Save PARSED_ variables from mediainfo before calling parse_filename (which resets them)
            local saved_video_codec="$PARSED_VIDEO_CODEC"
            local saved_audio_codec="$PARSED_AUDIO_CODEC"
            local saved_audio_channels="$PARSED_AUDIO_CHANNELS"
            local saved_hdr="$PARSED_HDR"
            local saved_quality="$PARSED_FULL_QUALITY"
            local saved_release_group="$PARSED_RELEASE_GROUP"
            
            parse_filename "$parent_folder" "folder"
            if [[ -n "$PARSED_TITLE" ]]; then
                folder_title="$PARSED_TITLE"
                folder_year="$PARSED_YEAR"
                should_debug high && echo "[DEBUG] Extracted from folder via parse_filename(): title='$folder_title' year='$folder_year'" >&2
            else
                should_debug high && echo "[DEBUG] Could not extract title/year from folder: '$folder_name'" >&2
            fi
            
            # Restore PARSED_ variables from mediainfo (parse_filename reset them)
            PARSED_VIDEO_CODEC="$saved_video_codec"
            PARSED_AUDIO_CODEC="$saved_audio_codec"
            PARSED_AUDIO_CHANNELS="$saved_audio_channels"
            PARSED_HDR="$saved_hdr"
            PARSED_FULL_QUALITY="$saved_quality"
            PARSED_RELEASE_GROUP="$saved_release_group"
        fi
        
        # Set source file for runtime matching (used by search_tmdb when many results)
        export SOURCE_FILE_FOR_RUNTIME="$source_file"
        
        # Check if TMDb API key is available
        if [[ -n "$TMDB_API_KEY" ]]; then
            # Search strategy: TMDb search, then TMDb /find, then other fallbacks
            
            # Store parsed filename title for error messages
            local parsed_filename_title="$TITLE"
            local parsed_filename_year="$YEAR"
            
            # Step 1: Try TMDb search by title/year (primary method)
            should_debug high && echo "[DEBUG] Step 1: TMDb title/year search" >&2
            local lookup_title=$(strip_editions_for_lookup "$TITLE")
            should_debug high && echo "[DEBUG] Stripped title for lookup: '$lookup_title' (original: '$TITLE')" >&2
            local tmdb_details=$(search_tmdb "$lookup_title" "$YEAR" "")
            should_debug high && echo "[DEBUG] Step 1 result: tmdb_details length=$(echo \"$tmdb_details\" | wc -c)" >&2
            
            # Step 1b: If no match and we have a folder title, try with folder title instead
            if [[ -z "$tmdb_details" && -n "$folder_title" && "$folder_title" != "$TITLE" ]]; then
                print_warning "Could not find TMDb ID for filename '$TITLE', trying folder '$folder_title' next..." >&2
                should_debug high && echo "[DEBUG] Step 1b: No match with filename title, trying folder title: '$folder_title'" >&2
                local folder_lookup_title=$(strip_editions_for_lookup "$folder_title")
                tmdb_details=$(search_tmdb "$folder_lookup_title" "$folder_year" "")
                should_debug high && echo "[DEBUG] Step 1b result: tmdb_details length=$(echo \"$tmdb_details\" | wc -c)" >&2
                
                # If folder title worked, use it for subsequent lookups
                if [[ -n "$tmdb_details" ]]; then
                    lookup_title="$folder_lookup_title"
                    TITLE="$folder_title"
                    [[ -n "$folder_year" ]] && YEAR="$folder_year"
                    should_debug high && echo "[DEBUG] Folder title match successful, using: title='$TITLE' year='$YEAR'" >&2
                    print_info "✓ Could not find TMDb match for filename title '$parsed_filename_title', using folder title '$TITLE' instead"
                fi
            fi
            
            # Step 2: If no TMDb found but have parsed IMDb, use /find endpoint
            if [[ -z "$tmdb_details" && -n "$PARSED_IMDB" ]]; then
                should_debug high && echo "[DEBUG] Step 2: Using /find endpoint with parsed IMDb" >&2
                tmdb_details=$(search_tmdb "$lookup_title" "$YEAR" "$PARSED_IMDB")
                should_debug high && echo "[DEBUG] Step 2 result: tmdb_details length=$(echo \"$tmdb_details\" | wc -c)" >&2
            fi
            
            # Step 3: If TMDb found, extract IMDb and TMDb IDs from details
            if [[ -n "$tmdb_details" ]]; then
                should_debug high && echo "[DEBUG] Step 3: Extracting IDs from movie details (single API call)" >&2
                TMDB=$(extract_tmdb_id_from_details "$tmdb_details")
                IMDB=$(extract_imdb_from_details "$tmdb_details")
                should_debug high && echo "[DEBUG] Step 3 result: TMDB='$TMDB' IMDB='$IMDB' (from one API call)" >&2
                
                # Verify: If we had a parsed IMDB and the result doesn't match, offer interactive selection
                if [[ -n "$PARSED_IMDB" && "$IMDB" != "$PARSED_IMDB" ]]; then
                    print_warning "IMDb ID mismatch detected!" >&2
                    echo -e "${YELLOW}  Folder/File IMDb ID: $PARSED_IMDB${NC}" >&2
                    echo -e "${YELLOW}  TMDb returned IMDb ID: $IMDB${NC}" >&2
                    echo "" >&2
                    print_info "Use IMDb autocomplete to find correct match? (y/n):" >&2
                    read -r use_autocomplete </dev/tty
                    
                    if [[ "$use_autocomplete" == "y" ]]; then
                        local selected_imdb=$(imdb_autocomplete_search "$lookup_title" "$YEAR" || true)
                        if [[ -n "$selected_imdb" ]]; then
                            IMDB="$selected_imdb"
                            # Re-get TMDb with the corrected IMDB
                            tmdb_details=$(search_tmdb "$lookup_title" "$YEAR" "$IMDB")
                            TMDB=$(extract_tmdb_id_from_details "$tmdb_details")
                            should_debug high && echo "[DEBUG] After autocomplete: IMDB='$IMDB' TMDB='$TMDB'" >&2
                        fi
                    fi
                fi
            fi
        else
            should_debug high && echo "[DEBUG] TMDb API key not configured - skipping TMDb search" >&2
        fi
        
        # Step 4: If parsed IMDb available and not yet used, use it
        if [[ -z "$IMDB" && -n "$PARSED_IMDB" ]]; then
            should_debug high && echo "[DEBUG] Step 4: Using parsed IMDb from filename" >&2
            IMDB="$PARSED_IMDB"
            should_debug high && echo "[DEBUG] Step 4 result: IMDB='$IMDB'" >&2
            # Get TMDb using the parsed IMDb ID
            if [[ -z "$TMDB" && -n "$TMDB_API_KEY" ]]; then
                tmdb_details=$(search_tmdb "$lookup_title" "$YEAR" "$IMDB")
                TMDB=$(extract_tmdb_id_from_details "$tmdb_details")
                should_debug high && echo "[DEBUG] Step 4b: Got TMDb from parsed IMDb: TMDB='$TMDB'" >&2
            fi
        fi
        
        # Step 5: If still no IMDb/TMDb, try TMDb runtime matching from search results (PRIMARY METHOD)
        if [[ -z "$IMDB" && -z "$TMDB" && -n "$TMDB_API_KEY" ]]; then
            should_debug high && echo "[DEBUG] Step 5: TMDb search with runtime matching (primary method)" >&2
            
            # Get file runtime for comparison
            local file_runtime=""
            should_debug high && echo "[DEBUG] Step 5: Checking source_file='$source_file'" >&2
            if [[ -f "$source_file" ]]; then
                should_debug high && echo "[DEBUG] Step 5: source_file exists, extracting runtime..." >&2
                file_runtime=$(get_file_runtime "$source_file" 2>/dev/null | grep -oE '[0-9]+' || echo "")
                should_debug high && echo "[DEBUG] Step 5: Extracted file_runtime='$file_runtime'" >&2
                [[ -n "$file_runtime" ]] && echo "[DEBUG] File runtime: ${file_runtime} minutes" >&2
            else
                should_debug high && echo "[DEBUG] Step 5: source_file does not exist or is not accessible" >&2
            fi
            
            # Get all search results from TMDb WITHOUT year filter (to catch year mismatches)
            local encoded_title=$(url_encode "$lookup_title")
            local search_url="${TMDB_API_BASE}/search/movie?api_key=${TMDB_API_KEY}&query=${encoded_title}"
            api_delay
            local search_result=$(curl -s --connect-timeout 10 --max-time 30 "$search_url" 2>/dev/null)
            local result_count=$(echo "$search_result" | grep -o '"id":' | wc -l | tr -d ' ')
            
            should_debug high && echo "[DEBUG] TMDb search returned $result_count result(s) (searching all years)" >&2
            
            if [[ $result_count -gt 0 ]]; then
                # Parse the JSON to extract all results with their metadata
                # Format: id|title|year
                local search_data=$(echo "$search_result" | python3 -c '
import sys, json
try:
    data = json.load(sys.stdin)
    for movie in data.get("results", []):
        movie_id = movie.get("id", "")
        title = movie.get("title", "").replace("|", "")
        release = movie.get("release_date", "")
        year = release[:4] if release else ""
        print(f"{movie_id}|{title}|{year}")
except:
    pass
' 2>/dev/null)
                
                if [[ -z "$search_data" ]]; then
                    should_debug high && echo "[DEBUG] Failed to parse search results, falling back to IMDb search" >&2
                else
                    should_debug high && echo "[DEBUG] Parsed search results:" >&2
                    local best_match_id=""
                    local best_match_year=""
                    local best_match_title=""
                    local line_num=0
                    # Only calculate year_int if YEAR is a valid number
                    local year_int=0
                    [[ "$YEAR" =~ ^[0-9]+$ ]] && year_int=$((YEAR))
                    
                    # Normalize search title for comparison
                    local normalized_search_title=$(normalize_title_for_comparison "$TITLE")
                    
                    # Read each result line and filter by year ±1
                    should_debug high && echo "[DEBUG] Before loop: file_runtime='$file_runtime'" >&2
                    while IFS='|' read -r candidate_id candidate_title candidate_year; do
                        [[ -z "$candidate_id" ]] && continue
                        ((line_num++))
                        [[ $line_num -gt 20 ]] && break  # Check more results to find year matches
                        
                        # Check if year is within ±1 of filename year (skip if no valid year)
                        if [[ $year_int -gt 0 ]]; then
                            local candidate_year_int=$((candidate_year))
                            local year_diff=$((year_int > candidate_year_int ? year_int - candidate_year_int : candidate_year_int - year_int))
                        else
                            local year_diff=999  # No year to compare, accept all results
                        fi
                        
                        if [[ $year_diff -le 1 || $year_int -eq 0 ]]; then
                            # Normalize candidate title for comparison
                            local normalized_candidate_title=$(normalize_title_for_comparison "$candidate_title")
                            
                            # Check if titles match
                            if [[ "$normalized_search_title" == "$normalized_candidate_title" ]]; then
                                should_debug high && echo "[DEBUG]   ✓ \"$candidate_title\" ($candidate_year) - TMDb ID: $candidate_id [year ±1 match, TITLE MATCH]" >&2
                                should_debug high && echo "[DEBUG]   Checking file_runtime variable: file_runtime='$file_runtime'" >&2
                                
                                # Validate runtime before accepting (prevent matching shorts/wrong versions)
                                if [[ -n "$file_runtime" ]]; then
                                    should_debug high && echo "[DEBUG]   Validating runtime for TMDb ID $candidate_id..." >&2
                                    api_delay
                                    local validate_url="${TMDB_API_BASE}/movie/${candidate_id}?api_key=${TMDB_API_KEY}"
                                    local validate_details=$(curl -s --connect-timeout 10 --max-time 30 "$validate_url" 2>/dev/null)
                                    local candidate_runtime=$(echo "$validate_details" | grep -oE '"runtime":[0-9]+' | grep -oE '[0-9]+')
                                    
                                    if [[ -n "$candidate_runtime" ]]; then
                                        local runtime_diff=$((file_runtime > candidate_runtime ? file_runtime - candidate_runtime : candidate_runtime - file_runtime))
                                        should_debug high && echo "[DEBUG]   Runtime: ${candidate_runtime}min (file: ${file_runtime}min, diff: ${runtime_diff}min)" >&2
                                        
                                        # Accept if runtime is close (within 20 min) or if candidate is very short (likely wrong type)
                                        if [[ $runtime_diff -le 20 ]]; then
                                            should_debug high && echo "[DEBUG]   ✓ Runtime validated - accepting match" >&2
                                            best_match_id="$candidate_id"
                                            best_match_year="$candidate_year"
                                            best_match_title="$candidate_title"
                                            break
                                        else
                                            should_debug high && echo "[DEBUG]   ✗ Runtime mismatch too large (${runtime_diff}min) - rejecting, continuing search..." >&2
                                            continue
                                        fi
                                    fi
                                fi
                                
                                # No runtime check needed or no file runtime available
                                best_match_id="$candidate_id"
                                best_match_year="$candidate_year"
                                best_match_title="$candidate_title"
                                break
                            else
                                should_debug high && echo "[DEBUG]   ✓ \"$candidate_title\" ($candidate_year) - TMDb ID: $candidate_id [year ±1 match, title mismatch]" >&2
                                should_debug high && echo "[DEBUG]     Search: '$normalized_search_title' vs Candidate: '$normalized_candidate_title'" >&2
                                # Year matches but title doesn't - validate runtime before accepting as fallback
                                if [[ -z "$best_match_id" && -n "$file_runtime" ]]; then
                                    should_debug high && echo "[DEBUG]   Validating runtime for title mismatch TMDb ID $candidate_id..." >&2
                                    api_delay
                                    local validate_url="${TMDB_API_BASE}/movie/${candidate_id}?api_key=${TMDB_API_KEY}"
                                    local validate_details=$(curl -s --connect-timeout 10 --max-time 30 "$validate_url" 2>/dev/null)
                                    local candidate_runtime=$(echo "$validate_details" | grep -oE '"runtime":[0-9]+' | grep -oE '[0-9]+')
                                    
                                    if [[ -n "$candidate_runtime" ]]; then
                                        local runtime_diff=$((file_runtime > candidate_runtime ? file_runtime - candidate_runtime : candidate_runtime - file_runtime))
                                        should_debug high && echo "[DEBUG]   Runtime: ${candidate_runtime}min (file: ${file_runtime}min, diff: ${runtime_diff}min)" >&2
                                        
                                        if [[ $runtime_diff -le 20 ]]; then
                                            should_debug high && echo "[DEBUG]   ✓ Runtime validated - accepting as fallback" >&2
                                            best_match_id="$candidate_id"
                                            best_match_year="$candidate_year"
                                            best_match_title="$candidate_title"
                                        else
                                            should_debug high && echo "[DEBUG]   ✗ Runtime mismatch too large (${runtime_diff}min) - rejecting fallback" >&2
                                        fi
                                    fi
                                elif [[ -z "$best_match_id" ]]; then
                                    # No file runtime available, accept as fallback
                                    best_match_id="$candidate_id"
                                    best_match_year="$candidate_year"
                                    best_match_title="$candidate_title"
                                fi
                            fi
                        else
                            should_debug high && echo "[DEBUG]   ✗ \"$candidate_title\" ($candidate_year) - TMDb ID: $candidate_id [year diff: $year_diff]" >&2
                        fi
                    done <<< "$search_data"
                    
                    # Now fetch details for the best candidate (only 1 API call)
                    if [[ -n "$best_match_id" ]]; then
                        should_debug high && echo "[DEBUG] Fetching details for TMDb ID $best_match_id to get IMDb ID and runtime..." >&2
                        api_delay
                        local candidate_url="${TMDB_API_BASE}/movie/${best_match_id}?api_key=${TMDB_API_KEY}&append_to_response=external_ids"
                        tmdb_details=$(curl -s --connect-timeout 10 --max-time 30 "$candidate_url" 2>/dev/null)
                        TMDB=$(extract_tmdb_id_from_details "$tmdb_details")
                        IMDB=$(extract_imdb_from_details "$tmdb_details")
                        
                        if [[ -n "$IMDB" ]]; then
                            local match_runtime=$(echo "$tmdb_details" | grep -oE '"runtime":[0-9]+' | grep -oE '[0-9]+')
                            if [[ -n "$file_runtime" && -n "$match_runtime" ]]; then
                                local runtime_diff=$((file_runtime > match_runtime ? file_runtime - match_runtime : match_runtime - file_runtime))
                                print_success "TMDb match found: TMDb $TMDB, IMDb $IMDB (runtime diff: ${runtime_diff}min)" >&2
                            else
                                print_success "TMDb match found: TMDb $TMDB, IMDb $IMDB" >&2
                            fi
                            should_debug high && echo "[DEBUG] Step 5 result: TMDB='$TMDB' IMDB='$IMDB'" >&2
                        else
                            should_debug high && echo "[DEBUG] TMDb match found but no IMDb ID yet - will try alternate search" >&2
                            print_info "TMDb match: $best_match_title ($best_match_year) - TMDb $TMDB" >&2
                            should_debug high && echo "[DEBUG] Step 5 result: TMDB='$TMDB' IMDB='' (will search with TMDb title)" >&2
                            # Store the TMDb title for a better IMDb search
                            local tmdb_match_title="$best_match_title"
                        fi
                    fi
                fi
            fi
        fi
        
        # Step 6: Fallback to IMDb search if TMDb failed OR if we have TMDb but no IMDb
        if [[ -z "$IMDB" ]]; then
            # If we found a TMDb match but no IMDb ID, use the TMDb title for a better search
            local search_title="$lookup_title"
            local search_year="$YEAR"
            if [[ -n "$tmdb_match_title" ]]; then
                should_debug high && echo "[DEBUG] Step 6: IMDb search using TMDb title: '$tmdb_match_title' ($best_match_year)" >&2
                search_title="$tmdb_match_title"
                search_year="$best_match_year"
            else
                should_debug high && echo "[DEBUG] Step 6: IMDb search fallback (TMDb search didn't find match)" >&2
            fi
            
            # Capture both stdout and stderr separately to detect TV shows
            local temp_imdb_out=$(mktemp)
            local temp_imdb_err=$(mktemp)
            search_imdb_with_runtime "$search_title" "$search_year" "$source_file" > "$temp_imdb_out" 2> "$temp_imdb_err"
            
            # Show stderr output (runtime matching info) to user
            if [[ -s "$temp_imdb_err" ]]; then
                cat "$temp_imdb_err" >&2
            fi
            
            # TV show detection disabled - process miniseries as movies
            IMDB=$(cat "$temp_imdb_out")
            rm -f "$temp_imdb_out" "$temp_imdb_err"
            should_debug high && echo "[DEBUG] Step 6a result (IMDb with runtime): IMDB='$IMDB'" >&2
            if [[ -z "$IMDB" ]]; then
                should_debug high && echo "[DEBUG] Step 6b: Regular IMDb search" >&2
                IMDB=$(search_imdb "$search_title" "$search_year")
                should_debug high && echo "[DEBUG] Step 6b result: IMDB='$IMDB'" >&2
            fi
            # If we got IMDb but still no TMDb and have API key, use /find endpoint
            if [[ -n "$IMDB" && -z "$TMDB" && -n "$TMDB_API_KEY" ]]; then
                should_debug high && echo "[DEBUG] Step 6c: Using TMDb /find endpoint with IMDb from search" >&2
                local temp_tmdb_out=$(mktemp)
                local temp_tmdb_err=$(mktemp)
                search_tmdb "$search_title" "$search_year" "$IMDB" > "$temp_tmdb_out" 2> "$temp_tmdb_err"
                
                # TV show detection disabled - process miniseries as movies
                tmdb_details=$(cat "$temp_tmdb_out")
                TMDB=$(extract_tmdb_id_from_details "$tmdb_details")
                rm -f "$temp_tmdb_out" "$temp_tmdb_err"
                should_debug high && echo "[DEBUG] Step 6c result: TMDB='$TMDB'" >&2
            fi
            
            # Step 6d: Try TV database as final fallback for miniseries (if we have IMDb but no TMDb)
            if [[ -n "$IMDB" && -z "$TMDB" && -n "$TMDB_API_KEY" && "$JSON_DB_MODE" != "json_only" ]]; then
                should_debug high && echo "[DEBUG] Step 6d: Checking TV database as fallback (miniseries detection)" >&2
                local find_url="${TMDB_API_BASE}/find/${IMDB}?api_key=${TMDB_API_KEY}&external_source=imdb_id"
                local tv_result=$(curl -s --connect-timeout 10 --max-time 30 "$find_url" 2>/dev/null)
                local tv_tmdb=$(echo "$tv_result" | python3 -c 'import sys,json; data=json.load(sys.stdin); print(data.get("tv_results",[{}])[0].get("id",""))' 2>/dev/null)
                
                if [[ -n "$tv_tmdb" ]]; then
                    print_info "Note: Found as TV show/miniseries (TMDb TV: $tv_tmdb)" >&2
                    print_info "Fetching details from TV database for movie processing..." >&2
                    api_delay
                    
                    # Get details from TV database
                    local tv_details_url="${TMDB_API_BASE}/tv/${tv_tmdb}?api_key=${TMDB_API_KEY}"
                    local tv_details=$(curl -s --connect-timeout 10 --max-time 30 "$tv_details_url" 2>/dev/null)
                    
                    # Extract movie-compatible details
                    local tv_title=$(echo "$tv_details" | python3 -c 'import sys,json; print(json.load(sys.stdin).get("name",""))' 2>/dev/null)
                    
                    if [[ -n "$tv_title" ]]; then
                        TMDB="$tv_tmdb"
                        TITLE="$tv_title"
                        should_debug high && echo "[DEBUG] Step 6d result: Using TV database - TMDB='$TMDB' TITLE='$TITLE'" >&2
                    else
                        should_debug high && echo "[DEBUG] Step 6d result: TV details fetch failed" >&2
                    fi
                else
                    should_debug high && echo "[DEBUG] Step 6d result: Not found in TV database either" >&2
                fi
            fi
        fi
        
        # Step 7: Fallback to folder name if filename lookup failed completely
        if [[ -z "$IMDB" && -z "$TMDB" && -n "$folder_title" && "$folder_title" != "$TITLE" ]]; then
            should_debug high && echo "[DEBUG] Step 6: Filename lookup failed, retrying with folder name" >&2
            echo "[INFO] Retrying lookup with folder name: $folder_title ($folder_year)" >&2
            
            local folder_lookup_title=$(strip_editions_for_lookup "$folder_title")
            should_debug high && echo "[DEBUG] Stripped folder title for lookup: '$folder_lookup_title' (original: '$folder_title')" >&2
            
            # Check JSON database first by title/year (only in hybrid/json_only modes)
            if [[ "$JSON_DB_MODE" != "api_only" ]]; then
                should_debug high && echo "[DEBUG] Checking JSON database for folder title/year: '$folder_lookup_title' ($folder_year)" >&2
                local folder_tmdb_id=$(get_tmdb_id_from_json_by_title_year "$folder_lookup_title" "$folder_year" "$source_file")
                
                if [[ -n "$folder_tmdb_id" ]]; then
                    should_debug high && echo "[DEBUG] Found folder in JSON database: TMDb ID $folder_tmdb_id" >&2
                    tmdb_details=$(get_json_from_db_by_tmdb "$folder_tmdb_id")
                    
                    if [[ -n "$tmdb_details" ]]; then
                        print_success "Folder found in JSON database (TMDb: $folder_tmdb_id) - skipping API call" >&2
                        TMDB=$(extract_tmdb_id_from_details "$tmdb_details")
                        IMDB=$(extract_imdb_from_details "$tmdb_details")
                        should_debug high && echo "[DEBUG] Step 6a (from JSON DB): TMDB='$TMDB' IMDB='$IMDB'" >&2
                    fi
                fi
            fi
            
            # If not in JSON database, try TMDb API search with folder info
            if [[ -z "$tmdb_details" && -n "$TMDB_API_KEY" ]]; then
                tmdb_details=$(search_tmdb "$folder_lookup_title" "$folder_year" "")
                should_debug high && echo "[DEBUG] Step 6b (TMDb API with folder): tmdb_details length=$(echo \"$tmdb_details\" | wc -c)" >&2
                
                if [[ -n "$tmdb_details" ]]; then
                    TMDB=$(extract_tmdb_id_from_details "$tmdb_details")
                    IMDB=$(extract_imdb_from_details "$tmdb_details")
                    should_debug high && echo "[DEBUG] Step 6c (IDs from API details): TMDB='$TMDB' IMDB='$IMDB' (one call)" >&2
                fi
            fi
            
            # If still nothing, try IMDb search with folder info
            if [[ -z "$IMDB" ]]; then
                IMDB=$(search_imdb_with_runtime "$folder_lookup_title" "$folder_year" "$source_file")
                should_debug high && echo "[DEBUG] Step 6d (IMDb with folder): IMDB='$IMDB'" >&2
                
                if [[ -z "$IMDB" ]]; then
                    IMDB=$(search_imdb "$folder_lookup_title" "$folder_year")
                    should_debug high && echo "[DEBUG] Step 6e (IMDb regular with folder): IMDB='$IMDB'" >&2
                fi
                
                # If we got IMDb, try to get TMDb
                if [[ -n "$IMDB" && -z "$TMDB" && -n "$TMDB_API_KEY" ]]; then
                    tmdb_details=$(search_tmdb "$folder_lookup_title" "$folder_year" "$IMDB")
                    TMDB=$(extract_tmdb_id_from_details "$tmdb_details")
                    should_debug high && echo "[DEBUG] Step 6f (TMDb from IMDb): TMDB='$TMDB'" >&2
                fi
            fi
            
            # If folder lookup succeeded, validate year compatibility before accepting
            if [[ -n "$IMDB" || -n "$TMDB" ]]; then
                local year_diff=$((YEAR > folder_year ? YEAR - folder_year : folder_year - YEAR))
                
                # Only accept folder match if years are close (within 1 year) or filename has no year
                if [[ -z "$YEAR" ]] || [[ $year_diff -le 1 ]]; then
                    should_debug high && echo "[DEBUG] Folder lookup succeeded, using folder title/year" >&2
                    TITLE="$folder_title"
                    YEAR="$folder_year"
                else
                    echo "[WARNING] Folder lookup found match but year mismatch too large (file: $YEAR, folder: $folder_year, diff: ${year_diff}y) - rejecting folder match" >&2
                    IMDB=""
                    TMDB=""
                fi
            fi
        fi
        
        should_debug high && echo "[DEBUG] Final results: IMDB='$IMDB' TMDB='$TMDB'" >&2
        
        # Get canonical title and year from TMDb details (already fetched in one call)
        # Store original title as fallback
        local original_title="$TITLE"
        if [[ -n "$tmdb_details" ]]; then
            local canonical_title=$(extract_title_from_details "$tmdb_details")
            if [[ -n "$canonical_title" && ! "$canonical_title" =~ ^(Wait and [Tt]ry [Aa]gain|Rate [Ll]imit|Throttled)$ ]]; then
                TITLE="$canonical_title"
                # Immediately sanitize title to prevent glob expansion of asterisks
                TITLE="${TITLE//\*/}"
                should_debug high && echo "[DEBUG] Using canonical title from TMDb details (no extra API call): $TITLE" >&2
            else
                should_debug high && echo "[DEBUG] Canonical title extraction failed or rate limited, keeping original parsed title: $TITLE" >&2
            fi
            
            # Extract canonical year from TMDb details
            local canonical_year=$(extract_year_from_details "$tmdb_details")
            if [[ -n "$canonical_year" ]]; then
                YEAR="$canonical_year"
                should_debug high && echo "[DEBUG] Using canonical year from TMDb details: $YEAR" >&2
            fi
            
            # Note: Always trust TMDb canonical title (English) over IMDb original title
            # TMDb provides the canonical/English title, while IMDb often returns original language title
            # We only fall back to IMDb when we have no TMDb data at all (see section below)
            should_debug high && echo "[DEBUG] Using TMDb canonical title: $TITLE (TMDb is authoritative for canonical English names)" >&2
        elif [[ -n "$TMDB" ]]; then
            # Fallback to web scraping only if we don't have details
            local canonical_title=$(get_tmdb_movie_title "$TMDB")
            if [[ -n "$canonical_title" ]]; then
                TITLE="$canonical_title"
                should_debug high && echo "[DEBUG] Using canonical title from TMDb website: $TITLE" >&2
            else
                should_debug high && echo "[DEBUG] Canonical title fetch failed, keeping original parsed title: $TITLE" >&2
            fi
        elif [[ -n "$IMDB" ]]; then
            # If no TMDb but have IMDb, fetch canonical title/year from IMDb
            # WARNING: IMDb often returns original language titles, not canonical English titles
            should_debug high && echo "[DEBUG] No TMDb, fetching title/year from IMDb: $IMDB" >&2
            print_warning "⚠ No TMDb data available - using IMDb (may be original language title, not canonical English)"
            local imdb_title=$(get_title_from_imdb_id "$IMDB")
            if [[ -n "$imdb_title" && ! "$imdb_title" =~ ^(null|undefined)$ ]]; then
                TITLE="$imdb_title"
                # Immediately sanitize title to prevent glob expansion
                TITLE="${TITLE//\*/}"
                should_debug high && echo "[DEBUG] Using title from IMDb: $TITLE (WARNING: may not be canonical English)" >&2
            else
                should_debug high && echo "[DEBUG] IMDb title fetch failed, keeping parsed title: $TITLE" >&2
            fi
            
            # Fetch canonical year from IMDb if missing
            if [[ -z "$YEAR" ]]; then
                local imdb_year=$(get_year_from_imdb_id "$IMDB")
                if [[ -n "$imdb_year" && "$imdb_year" =~ ^[0-9]{4}$ ]]; then
                    YEAR="$imdb_year"
                    should_debug high && echo "[DEBUG] Using canonical year from IMDb: $YEAR" >&2
                fi
            fi
        fi
        fi  # End of: if not found in JSON database
        
        # Save to cache only if we have BOTH IDs and it's not already cached
        if [[ -n "$IMDB" && -n "$TMDB" && -z "$CACHED_DATA" ]]; then
            should_debug high && echo "[DEBUG] Saving to cache - both IDs present and not previously cached" >&2
            save_to_cache "$TITLE" "$YEAR" "$IMDB" "$TMDB"
        elif [[ -n "$CACHED_DATA" ]]; then
            should_debug high && echo "[DEBUG] Not saving to cache - already cached" >&2
        else
            should_debug high && echo "[DEBUG] Not saving to cache - missing IMDb='$IMDB' TMDb='$TMDB'" >&2
        fi
    fi
    
    # ALWAYS log this to see if we reach poster display code
    echo "[DEBUG] POSTER CHECK: SHOW_MOVIE_POSTERS='$SHOW_MOVIE_POSTERS' IMDB='$IMDB' DISABLE_IMAGES='$DISABLE_IMAGES'" >&2
    
    # Display poster for each non-duplicate file (if enabled) - works in both interactive and auto mode
    if [[ "$SHOW_MOVIE_POSTERS" == "yes" && -n "$IMDB" ]]; then
        should_debug high && echo "[DEBUG] Attempting to display poster for IMDb: $IMDB (SHOW_MOVIE_POSTERS=$SHOW_MOVIE_POSTERS)" >&2
        local poster_url=$(get_imdb_poster "$IMDB" || true)
        should_debug high && echo "[DEBUG] Poster URL retrieved: '$poster_url'" >&2
        if [[ -n "$poster_url" ]]; then
            echo "" >&2
            should_debug high && echo "[DEBUG] Calling show_poster with IMDb=$IMDB, URL=$poster_url" >&2
            show_poster "$IMDB" "$poster_url" 30 >&2 || true
            echo "" >&2
        else
            should_debug high && echo "[DEBUG] Poster URL is empty, skipping display" >&2
        fi
    else
        should_debug high && echo "[DEBUG] Skipping poster display: SHOW_MOVIE_POSTERS='$SHOW_MOVIE_POSTERS' IMDB='$IMDB'" >&2
    fi
    
    # Prompt or auto-use values
    if [[ "$auto_mode" != "y" ]]; then
        # Interactive mode - show what we found and allow manual entry
        if [[ -z "$IMDB" && -z "$TMDB" ]]; then
            echo "" >&2
            echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}" >&2
            print_warning "⚠  Could not find IMDb or TMDb IDs for: $TITLE ($YEAR)" >&2
            echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}" >&2
            echo "" >&2
            echo -e "${CYAN}You can:${NC}" >&2
            echo -e "  ${GREEN}1) Enter IDs manually below${NC}" >&2
            echo -e "  ${GREEN}2) Leave blank to skip this file${NC}" >&2
            echo "" >&2
            echo -e "${YELLOW}Find IDs at:${NC}" >&2
            echo -e "  ${DIM}IMDb: https://www.imdb.com/ (copy tt####### from URL)${NC}" >&2
            echo -e "  ${DIM}TMDb: https://www.themoviedb.org/ (copy number from URL)${NC}" >&2
            echo "" >&2
        fi
        
        echo ""
        echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${CYAN}MANUAL ID ENTRY${NC}"
        echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
        echo -e "${YELLOW}Instructions:${NC}"
        echo -e "  • ${DIM}Enter the ID and press ENTER${NC}"
        echo -e "  • ${DIM}If you see a title tag shown in brackets [tt1234567], just press ENTER to keep it${NC}"
        echo -e "  • ${DIM}Leave blank to skip entering that ID${NC}"
        echo ""
        echo -e "${YELLOW}Where to find IDs:${NC}"
        echo -e "  • ${DIM}IMDb: Go to https://www.imdb.com/ → Search for movie → Copy tt####### from URL${NC}"
        echo -e "  • ${DIM}TMDb: Go to https://www.themoviedb.org/ → Search for movie → Copy numbers from URL${NC}"
        echo ""
        echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
        
        print_info "Enter IMDb ID (format: tt#######) if you see tags on this line confirm they are correct and just hit enter -> [${IMDB}]:"
        read -r input
        [[ -n "$input" ]] && IMDB="$input"
        
        # Show poster after IMDb entry if available
        if [[ "$SHOW_MOVIE_POSTERS" == "yes" && -n "$IMDB" ]]; then
            local poster_url=$(get_imdb_poster "$IMDB" || true)
            if [[ -n "$poster_url" ]]; then
                echo ""
                echo -e "${CYAN}Fetching poster for IMDb: $IMDB${NC}"
                show_poster "$IMDB" "$poster_url" 30 || true
                echo ""
            fi
        fi
        
        print_info "Enter TMDb ID (numbers only) if you see tags on this line confirm they are correct and just hit enter -> [${TMDB}]:"
        read -r input
        [[ -n "$input" ]] && TMDB="$input"
        echo ""
    else
        # Auto mode - require at least IMDb ID (TMDb is optional but preferred)
        if [[ -z "$IMDB" ]]; then
            echo "" >&2
            echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}" >&2
            local rejection_reason=""
            
            # Check for missing IMDb ID
            if [[ -z "$TMDB" ]]; then
                rejection_reason="No IMDb or TMDb ID found - database searches returned no results"
                if [[ -n "$folder_title" && "$folder_title" != "$parsed_filename_title" ]]; then
                    print_error "⚠  Cannot auto-process: No IMDb or TMDb ID found" >&2
                    print_error "   Tried: file '$parsed_filename_title' and folder '$folder_title'" >&2
                    print_error "   Reason: All database lookups (TMDb search, IMDb search) returned empty results" >&2
                else
                    print_error "⚠  Cannot auto-process: No IMDb or TMDb ID found for $TITLE ($YEAR)" >&2
                    print_error "   Reason: All database lookups (TMDb search, IMDb search) returned empty results" >&2
                fi
            else
                # Only IMDb ID missing is a hard failure
                rejection_reason="IMDb ID missing - IMDb search returned no results"
                print_error "⚠  Cannot auto-process: IMDb ID missing for $TITLE ($YEAR)" >&2
                if [[ -n "$TMDB" ]]; then
                    print_error "   Found: TMDb ID $TMDB" >&2
                    print_error "   Missing: IMDb ID not found (IMDb search/suggestion API returned no results)" >&2
                else
                    print_error "   Both IMDb and TMDb IDs missing" >&2
                fi
            fi
            # Track rejection (write to temp file for cross-function persistence)
            REJECTED_FILES+=("$source_file|||$rejection_reason")
            echo "$source_file|||$rejection_reason" >> "${CACHE_DIR}/.rejected_files_$$.tmp"
            echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}" >&2
            echo "" >&2
            print_warning "Skipping hardlink - will be sent to post-processing" >&2
            echo "" >&2
            echo -e "${CYAN}To manually add this movie to cache:${NC}" >&2
            echo "" >&2
            echo -e "  ${GREEN}1) Find IMDb ID:${NC} ${DIM}https://www.imdb.com/${NC}" >&2
            echo -e "     ${DIM}Search for \"${TITLE} ${YEAR}\" and copy tt####### from URL${NC}" >&2
            echo "" >&2
            echo -e "  ${GREEN}2) Find TMDb ID:${NC} ${DIM}https://www.themoviedb.org/${NC}" >&2
            echo -e "     ${DIM}Search for \"${TITLE} ${YEAR}\" and copy number from URL${NC}" >&2
            echo "" >&2
            echo -e "  ${GREEN}3) Add to cache file:${NC}" >&2
            echo -e "     ${DIM}nano ${CACHE_FILE}${NC}" >&2
            echo "" >&2
            echo -e "  ${YELLOW}Format:${NC}" >&2
            echo -e "     ${DIM}${TITLE}|${YEAR}|tt1234567|12345|$(date +%s)${NC}" >&2
            echo "" >&2
            echo -e "${CYAN}Then re-run the script to process this file.${NC}" >&2
            echo "" >&2
            return 1
        fi
    fi
    
    # Set other fields
    EDITION="$PARSED_EDITION"
    CUSTOM_FORMAT="$PARSED_CUSTOM_FORMAT"
    IS_3D=$PARSED_3D
    FORMAT_3D="$PARSED_3D_FORMAT"
    QUALITY="$PARSED_FULL_QUALITY"
    AUDIO_CODEC="$PARSED_AUDIO_CODEC"
    AUDIO_CHANNELS="$PARSED_AUDIO_CHANNELS"
    HDR_TYPE="$PARSED_HDR"
    VIDEO_CODEC="$PARSED_VIDEO_CODEC"
    RELEASE_GROUP="$PARSED_RELEASE_GROUP"
    
    should_debug high && echo "[DEBUG] After setting final variables from PARSED_ variables:" >&2
    should_debug high && echo "[DEBUG]   AUDIO_CODEC='$AUDIO_CODEC' (from PARSED_AUDIO_CODEC='$PARSED_AUDIO_CODEC')" >&2
    should_debug high && echo "[DEBUG]   AUDIO_CHANNELS='$AUDIO_CHANNELS' (from PARSED_AUDIO_CHANNELS='$PARSED_AUDIO_CHANNELS')" >&2
    should_debug high && echo "[DEBUG]   VIDEO_CODEC='$VIDEO_CODEC' (from PARSED_VIDEO_CODEC='$PARSED_VIDEO_CODEC')" >&2
    should_debug high && echo "[DEBUG]   QUALITY='$QUALITY' (from PARSED_FULL_QUALITY='$PARSED_FULL_QUALITY')" >&2
    should_debug high && echo "[DEBUG]   RELEASE_GROUP='$RELEASE_GROUP' (from PARSED_RELEASE_GROUP='$PARSED_RELEASE_GROUP')" >&2
    
    # Canonical title already extracted earlier from TMDb details - no need to fetch again
    [[ "$DEBUG_MODE_MOVIES" == "true" ]] && print_info "[DEBUG] Using final title: $TITLE" >&2
    
    # Build paths
    local ext="${source_file##*.}"
    # Convert to title case first, then clean
    local title_cased=$(to_title_case "$TITLE")
    local clean_title=$(echo "$title_cased" | sed 's/[:<>"|?*]//g' | sed 's/\//\-/g')
    # Remove any existing year from title
    clean_title=$(echo "$clean_title" | sed -E 's/[[:space:]]*-?[[:space:]]*[\(\[]?[0-9]{4}(-[0-9]{4})?[\)\]]?[[:space:]]*$//' | sed 's/  */ /g' | sed 's/^ //;s/ $//')
    clean_title=$(echo "$clean_title" | sed -E 's/[[:space:]]*[-—_]+[[:space:]]*$//')
    local clean_title_dots=$(echo "$title_cased" | sed 's/[:<>"|?*]//g' | sed 's/\//\-/g' | sed 's/ /./g')
    local source_dir=$(dirname "$source_file")
    local original_folder=$(basename "$source_dir")
    
    # Build folder name based on selected scheme
    local folder_name
    case "$NAMING_FOLDER" in
        0) folder_name="${original_folder}" ;;  # No renaming - keep original
        1) folder_name="${clean_title} (${YEAR})" ;;  # Standard
        2) folder_name="${clean_title} (${YEAR}) [imdbid-${IMDB}]" ;;  # Jellyfin (IMDb)
        3) folder_name="${clean_title} (${YEAR}) [tmdbid-${TMDB}]" ;;  # Jellyfin (TMDb)
        4) folder_name="${clean_title} (${YEAR}) {imdb-${IMDB}}" ;;  # Plex (IMDb)
        5) folder_name="${clean_title} (${YEAR}) {tmdb-${TMDB}}" ;;  # Plex (TMDb)
        6) folder_name="${clean_title} (${YEAR}) [imdb-${IMDB}]" ;;  # Emby (IMDb)
        7) folder_name="${clean_title} (${YEAR}) [tmdb-${TMDB}]" ;;  # Emby (TMDb)
        *) folder_name="${clean_title} (${YEAR})" ;;  # Default to Standard
    esac
    local movie_folder="${DESTINATION}/${folder_name}"
    
    # Export folder name for post-processing tracking
    LAST_CREATED_FOLDER="$folder_name"
    
    # Build filename based on selected scheme
    local filename
    local original_basename=$(basename "$source_file")
    
    case "$NAMING_FILE" in
        0) # No renaming - keep original
            filename="${original_basename}"
            ;;
        8) # Standard
            filename="${clean_title} (${YEAR})"
            [[ -n "$EDITION" ]] && filename="${filename} - {edition-${EDITION}}"
            ;;
        9) # Jellyfin (IMDb)
            filename="${clean_title} (${YEAR}) [imdbid-${IMDB}]"
            [[ -n "$EDITION" ]] && filename="${filename} - {edition-${EDITION}}"
            ;;
        10) # Jellyfin (TMDb)
            filename="${clean_title} (${YEAR}) [tmdbid-${TMDB}]"
            [[ -n "$EDITION" ]] && filename="${filename} - {edition-${EDITION}}"
            ;;
        11) # Jellyfin Anime (IMDb)
            filename="${clean_title} (${YEAR}) [imdbid-${IMDB}]"
            [[ -n "$EDITION" ]] && filename="${filename} - {edition-${EDITION}}"
            ;;
        12) # Jellyfin Anime (TMDb)
            filename="${clean_title} (${YEAR}) [tmdbid-${TMDB}]"
            [[ -n "$EDITION" ]] && filename="${filename} - {edition-${EDITION}}"
            ;;
        13) # Plex (IMDb)
            filename="${clean_title} (${YEAR}) {imdb-${IMDB}}"
            [[ -n "$EDITION" ]] && filename="${filename} - {edition-${EDITION}}"
            ;;
        14) # Plex (TMDb)
            filename="${clean_title} (${YEAR}) {tmdb-${TMDB}}"
            [[ -n "$EDITION" ]] && filename="${filename} - {edition-${EDITION}}"
            ;;
        15) # Plex Anime (IMDb)
            filename="${clean_title} (${YEAR}) {imdb-${IMDB}}"
            [[ -n "$EDITION" ]] && filename="${filename} - {edition-${EDITION}}"
            ;;
        16) # Plex Anime (TMDb)
            filename="${clean_title} (${YEAR}) {tmdb-${TMDB}}"
            [[ -n "$EDITION" ]] && filename="${filename} - {edition-${EDITION}}"
            ;;
        17) # Emby (IMDb)
            filename="${clean_title} (${YEAR}) [imdb-${IMDB}]"
            [[ -n "$EDITION" ]] && filename="${filename} - {edition-${EDITION}}"
            ;;
        18) # Emby (TMDb)
            filename="${clean_title} (${YEAR}) [tmdb-${TMDB}]"
            [[ -n "$EDITION" ]] && filename="${filename} - {edition-${EDITION}}"
            ;;
        19) # Emby Anime (IMDb)
            filename="${clean_title} (${YEAR}) [imdb-${IMDB}]"
            [[ -n "$EDITION" ]] && filename="${filename} - {edition-${EDITION}}"
            ;;
        20) # Emby Anime (TMDb)
            filename="${clean_title} (${YEAR}) [tmdb-${TMDB}]"
            [[ -n "$EDITION" ]] && filename="${filename} - {edition-${EDITION}}"
            ;;
        *) # Default to Standard
            filename="${clean_title} (${YEAR}) [tmdbid-${TMDB}]"
            [[ -n "$EDITION" ]] && filename="${filename} {edition-${EDITION}}"
            ;;
    esac
    
    # Add common metadata fields based on format (skip for no-renaming option)
    if [[ "$NAMING_FILE" != "0" ]]; then
        # Debug: Show what metadata values we have
        should_debug high && echo "[DEBUG] Building filename with metadata:" >&2
        should_debug high && echo "[DEBUG]   IS_3D=$IS_3D" >&2
        should_debug high && echo "[DEBUG]   CUSTOM_FORMAT='$CUSTOM_FORMAT'" >&2
        should_debug high && echo "[DEBUG]   QUALITY='$QUALITY'" >&2
        should_debug high && echo "[DEBUG]   AUDIO_CODEC='$AUDIO_CODEC'" >&2
        should_debug high && echo "[DEBUG]   AUDIO_CHANNELS='$AUDIO_CHANNELS'" >&2
        should_debug high && echo "[DEBUG]   HDR_TYPE='$HDR_TYPE'" >&2
        should_debug high && echo "[DEBUG]   VIDEO_CODEC='$VIDEO_CODEC'" >&2
        should_debug high && echo "[DEBUG]   RELEASE_GROUP='$RELEASE_GROUP'" >&2
        
        # Standard bracket format (TRaSH-Guides)
        if $IS_3D; then
            filename="${filename} [3D]"
            [[ -n "$FORMAT_3D" ]] && filename="${filename} [${FORMAT_3D}]"
        fi
        [[ -n "$CUSTOM_FORMAT" ]] && filename="${filename} [${CUSTOM_FORMAT}]"
        [[ -n "$QUALITY" ]] && filename="${filename} [${QUALITY}]"
        if [[ -n "$AUDIO_CODEC" ]]; then
            if [[ -n "$AUDIO_CHANNELS" ]]; then
                filename="${filename} [${AUDIO_CODEC} ${AUDIO_CHANNELS}]"
            else
                filename="${filename} [${AUDIO_CODEC}]"
            fi
        fi
        [[ -n "$HDR_TYPE" ]] && filename="${filename} [${HDR_TYPE}]"
        [[ -n "$VIDEO_CODEC" ]] && filename="${filename} [${VIDEO_CODEC}]"
        [[ -n "$RELEASE_GROUP" ]] && filename="${filename}-${RELEASE_GROUP}"
        
        filename="${filename}.${ext}"
    fi
    # If NAMING_FILE == 0, filename already has extension from original_basename
    
    # Store the final video filename for subtitle renaming (without extension)
    local new_video_basename="$filename"
    
    local dest_file="${movie_folder}/${filename}"
    
    # Create and link/copy
    print_success "Creating: $folder_name/$filename"
    mkdir -p "$movie_folder"
    
    # Check if file already exists and is a hardlink to the source
    should_debug high && echo "[DEBUG] Checking if dest file exists: $dest_file" >&2
    if [[ -f "$dest_file" ]]; then
        should_debug high && echo "[DEBUG] Dest file exists, checking inodes" >&2
        local source_inode=$(stat -f "%i" "$source_file" 2>/dev/null || stat -c "%i" "$source_file" 2>/dev/null)
        local dest_inode=$(stat -f "%i" "$dest_file" 2>/dev/null || stat -c "%i" "$dest_file" 2>/dev/null)
        should_debug high && echo "[DEBUG] Source inode: $source_inode, Dest inode: $dest_inode" >&2
        
        if [[ "$source_inode" == "$dest_inode" ]]; then
            should_debug high && echo "[DEBUG] Inodes match - already hardlinked, skipping" >&2
            print_info "Video file already hardlinked, skipping"
            return 0
        else
            should_debug high && echo "[DEBUG] Inodes don't match - different file exists" >&2
            print_warning "Destination file already exists (different file), skipping to avoid overwrite"
            release_file_lock "$source_file"
            return 1
        fi
    else
        should_debug high && echo "[DEBUG] Dest file doesn't exist, checking for other hardlinks in folder" >&2
        # Check for other hardlinks with different names in same folder
        local source_inode=$(stat -f "%i" "$source_file" 2>/dev/null || stat -c "%i" "$source_file" 2>/dev/null)
        shopt -s nullglob
        for existing in "$movie_folder"/*."$ext"; do
            [[ -f "$existing" ]] || continue
            local existing_inode=$(stat -f "%i" "$existing" 2>/dev/null || stat -c "%i" "$existing" 2>/dev/null)
            should_debug high && echo "[DEBUG] Checking existing file: $(basename "$existing") (inode: $existing_inode)" >&2
            if [[ "$source_inode" == "$existing_inode" ]]; then
                should_debug high && echo "[DEBUG] Found hardlink with different name: $(basename "$existing")" >&2
                print_warning "Hardlink already exists with different name: $(basename "$existing")"
                shopt -u nullglob
                release_file_lock "$source_file"
                return 0
            fi
        done
        shopt -u nullglob
        should_debug high && echo "[DEBUG] No existing hardlinks found, proceeding with creation" >&2
    fi
    
    # Create hardlink/symlink/copy
    should_debug high && echo "[DEBUG] Creating hardlink/symlink/copy" >&2
    if $USE_COPY; then
        cp "$source_file" "$dest_file"
        print_success "Copied video file"
    elif $USE_SYMLINK; then
        ln -s "$source_file" "$dest_file"
        print_success "Created symbolic link"
    else
        if ! ln "$source_file" "$dest_file" 2>/dev/null; then
            print_warning "Hardlink failed (different volumes/filesystems) - will handle post-processing"
            # Track for post-processing - using tab delimiter to avoid issues with paths containing |||  
            FAILED_HARDLINKS+=("${source_file}	${dest_file}	${TITLE}	${YEAR}")
            # Clean up the created folder structure since hardlink failed
            rm -rf "$movie_folder" 2>/dev/null
            release_file_lock "$source_file"
            return 1
        else
            print_success "Hardlinked video file"
        fi
    fi
    
    # Get the directory containing the video file
    local source_dir=$(dirname "$source_file")
    local video_basename=$(basename "$source_file")
    local video_name="${video_basename%.*}"
    
    # Find and hardlink subtitle files in the same directory
    local subtitle_count=0
    while IFS= read -r -d '' subtitle_file; do
        local sub_basename=$(basename "$subtitle_file")
        local sub_name_no_ext="${sub_basename%.*}"
        
        # Remove any language/type suffixes to get base subtitle name for matching
        local sub_base_for_match="$sub_name_no_ext"
        sub_base_for_match=$(echo "$sub_base_for_match" | sed -E 's/\.(en|eng|es|spa|fr|fra|de|deu|ger|ja|jpn|ko|kor|zh|chi|pt|por|it|ita|ru|rus|ar|ara|hi|hin|[a-z]{2,3})$//i')
        sub_base_for_match=$(echo "$sub_base_for_match" | sed -E 's/\.(forced|sdh|cc|commentary|hearing.?impaired|hi)$//i')
        sub_base_for_match=$(echo "$sub_base_for_match" | sed -E 's/\.(en|eng|es|spa|fr|fra|de|deu|ger|ja|jpn|ko|kor|zh|chi|pt|por|it|ita|ru|rus|ar|ara|hi|hin|[a-z]{2,3})$//i')
        
        # Only process this subtitle if it matches the video filename
        if [[ "$sub_base_for_match" != "$video_name" ]]; then
            continue
        fi
        
        local sub_ext="${sub_basename##*.}"
        
        # Create new subtitle filename matching the video file exactly (without extension)
        local new_sub_name="${new_video_basename%.*}"
        
        # Preserve language code if present (e.g., .en.srt, .eng.srt)
        if [[ $sub_basename =~ \.([a-z]{2,3})\.(srt|sub|idx|ass|ssa)$ ]]; then
            local lang_code="${BASH_REMATCH[1]}"
            new_sub_name="${new_sub_name}.${lang_code}.${sub_ext}"
        else
            new_sub_name="${new_sub_name}.${sub_ext}"
        fi
        
        local dest_subtitle="${movie_folder}/${new_sub_name}"
        
        # Check if subtitle already exists and is hardlinked
        if [[ -f "$dest_subtitle" ]]; then
            local source_inode=$(stat -f "%i" "$subtitle_file" 2>/dev/null || stat -c "%i" "$subtitle_file" 2>/dev/null)
            local dest_inode=$(stat -f "%i" "$dest_subtitle" 2>/dev/null || stat -c "%i" "$dest_subtitle" 2>/dev/null)
            
            if [[ "$source_inode" != "$dest_inode" ]]; then
                rm "$dest_subtitle"
                if $USE_COPY; then
                    cp "$subtitle_file" "$dest_subtitle"
                elif $USE_SYMLINK; then
                    ln -s "$subtitle_file" "$dest_subtitle"
                else
                    ln "$subtitle_file" "$dest_subtitle" 2>/dev/null || cp "$subtitle_file" "$dest_subtitle"
                fi
                ((subtitle_count++))
            fi
        else
            if $USE_COPY; then
                cp "$subtitle_file" "$dest_subtitle"
            elif $USE_SYMLINK; then
                ln -s "$subtitle_file" "$dest_subtitle"
            else
                ln "$subtitle_file" "$dest_subtitle" 2>/dev/null || cp "$subtitle_file" "$dest_subtitle"
            fi
            ((subtitle_count++))
        fi
    done < <(find "$source_dir" -maxdepth 1 -type f \( -iname "*.srt" -o -iname "*.sub" -o -iname "*.idx" -o -iname "*.ass" -o -iname "*.ssa" \) -print0)
    
    # Extract and rename subtitles from Subs/Subtitles folders (modes 1 and 2 only, not mode 3)
    # Mode 3 preserves folder structure so Subs folder is included as-is
    if [[ "$HARDLINK_EXTRAS" != "preserve" ]]; then
        # Look for Subs/Subtitles folders
        while IFS= read -r -d '' subs_dir; do
            while IFS= read -r -d '' sub_file; do
                local sub_basename=$(basename "$sub_file")
                local sub_ext="${sub_basename##*.}"
                
                # Try to detect language from filename (comprehensive YIFY subtitle language support)
                # Convert to lowercase for pattern matching
                local sub_basename_lower=$(echo "$sub_basename" | tr '[:upper:]' '[:lower:]')
                local lang_code=""
                
                # Pattern 1: Extract 2-4 letter language code before extension (case insensitive)
                # Matches: .eng.srt, .chi.srt, .ENG.srt, .pt-br.srt
                if [[ "$sub_basename_lower" =~ \.([a-z]{2,4}(-[a-z]{2})?)\.(srt|sub|idx|ass|ssa|vtt)$ ]]; then
                    lang_code="${BASH_REMATCH[1]}"
                # Pattern 2: Underscore before language code
                # Matches: filename_eng.srt, filename_chi.srt
                elif [[ "$sub_basename_lower" =~ _([a-z]{2,4}(-[a-z]{2})?)\.(srt|sub|idx|ass|ssa|vtt)$ ]]; then
                    lang_code="${BASH_REMATCH[1]}"
                # Pattern 3: Any text followed by dot and language code (case insensitive)
                # Matches: "English.eng.srt", "Traditional.chi.srt", "SDH.eng.HI.srt"
                elif [[ "$sub_basename_lower" =~ [._-]([a-z]{2,4})\.([a-z]{2,4})\.(srt|sub|idx|ass|ssa|vtt)$ ]]; then
                    # Check if first match is a known descriptor (sdh, hi, cc, forced)
                    if [[ "${BASH_REMATCH[1]}" =~ ^(sdh|hi|cc|forced)$ ]]; then
                        lang_code="${BASH_REMATCH[2]}"  # Use second match as language
                    else
                        lang_code="${BASH_REMATCH[1]}"  # Use first match as language
                    fi
                # Pattern 4: Text.code.srt (Traditional.chi.srt, Simplified.chi.srt)
                elif [[ "$sub_basename_lower" =~ ^[a-z0-9[:space:]]+\.([a-z]{2,4})\.(srt|sub|idx|ass|ssa|vtt)$ ]]; then
                    lang_code="${BASH_REMATCH[1]}"
                # Pattern 5: Match full language names only (no code present)
                elif [[ "$sub_basename_lower" =~ ^(albanian)[._-] ]]; then lang_code="alb"
                elif [[ "$sub_basename_lower" =~ ^(arabic|ara)[._-] ]]; then lang_code="ara"
                elif [[ "$sub_basename_lower" =~ ^(armenian|arm)[._-] ]]; then lang_code="arm"
                elif [[ "$sub_basename_lower" =~ ^(azerbaijani|aze)[._-] ]]; then lang_code="aze"
                elif [[ "$sub_basename_lower" =~ ^(basque|baq)[._-] ]]; then lang_code="baq"
                elif [[ "$sub_basename_lower" =~ ^(belarusian|bel)[._-] ]]; then lang_code="bel"
                elif [[ "$sub_basename_lower" =~ ^(bengali|ben)[._-] ]]; then lang_code="ben"
                elif [[ "$sub_basename_lower" =~ ^(bosnian|bos)[._-] ]]; then lang_code="bos"
                elif [[ "$sub_basename_lower" =~ ^(brazilian.portuguese|portuguese.brazilian|pt-br|por-br)[._-] ]]; then lang_code="pt-br"
                elif [[ "$sub_basename_lower" =~ ^(european.portuguese|portuguese.european|pt-pt|por-pt)[._-] ]]; then lang_code="por"
                elif [[ "$sub_basename_lower" =~ ^(british.english|english.uk|en-gb)[._-] ]]; then lang_code="eng"
                elif [[ "$sub_basename_lower" =~ ^(us.english|american.english|en-us)[._-] ]]; then lang_code="eng"
                elif [[ "$sub_basename_lower" =~ ^(canadian.french|french.canadian|fr-ca)[._-] ]]; then lang_code="fre"
                elif [[ "$sub_basename_lower" =~ ^(european.french|french.european|fr-fr)[._-] ]]; then lang_code="fre"
                elif [[ "$sub_basename_lower" =~ ^(swiss.german|austrian.german)[._-] ]]; then lang_code="ger"
                elif [[ "$sub_basename_lower" =~ ^(bulgarian|bul)[._-] ]]; then lang_code="bul"
                elif [[ "$sub_basename_lower" =~ ^(burmese|bur)[._-] ]]; then lang_code="bur"
                elif [[ "$sub_basename_lower" =~ ^(catalan|cat)[._-] ]]; then lang_code="cat"
                elif [[ "$sub_basename_lower" =~ ^(chinese.simplified|chi.simp|zh-cn)[._-] ]]; then lang_code="chi"
                elif [[ "$sub_basename_lower" =~ ^(chinese.traditional|chi.trad|zh-tw)[._-] ]]; then lang_code="chi"
                elif [[ "$sub_basename_lower" =~ ^(chinese.cantonese|yue)[._-] ]]; then lang_code="yue"
                elif [[ "$sub_basename_lower" =~ ^(chinese|chi|zho)[._-] ]]; then lang_code="chi"
                elif [[ "$sub_basename_lower" =~ ^(croatian|hrv)[._-] ]]; then lang_code="hrv"
                elif [[ "$sub_basename_lower" =~ ^(czech|cze)[._-] ]]; then lang_code="cze"
                elif [[ "$sub_basename_lower" =~ ^(danish|dan)[._-] ]]; then lang_code="dan"
                elif [[ "$sub_basename_lower" =~ ^(dutch|dut|nld)[._-] ]]; then lang_code="dut"
                elif [[ "$sub_basename_lower" =~ ^(english|eng)[._-] ]]; then lang_code="eng"
                elif [[ "$sub_basename_lower" =~ ^(esperanto|epo)[._-] ]]; then lang_code="epo"
                elif [[ "$sub_basename_lower" =~ ^(estonian|est)[._-] ]]; then lang_code="est"
                elif [[ "$sub_basename_lower" =~ ^(farsi|persian|fas|per)[._-] ]]; then lang_code="fas"
                elif [[ "$sub_basename_lower" =~ ^(filipino|fil)[._-] ]]; then lang_code="fil"
                elif [[ "$sub_basename_lower" =~ ^(finnish|fin)[._-] ]]; then lang_code="fin"
                elif [[ "$sub_basename_lower" =~ ^(french|fre|fra)[._-] ]]; then lang_code="fre"
                elif [[ "$sub_basename_lower" =~ ^(georgian|geo)[._-] ]]; then lang_code="geo"
                elif [[ "$sub_basename_lower" =~ ^(german|ger|deu)[._-] ]]; then lang_code="ger"
                elif [[ "$sub_basename_lower" =~ ^(greek|gre|ell)[._-] ]]; then lang_code="gre"
                elif [[ "$sub_basename_lower" =~ ^(greenlandic|kal)[._-] ]]; then lang_code="kal"
                elif [[ "$sub_basename_lower" =~ ^(hebrew|heb)[._-] ]]; then lang_code="heb"
                elif [[ "$sub_basename_lower" =~ ^(hindi|hin)[._-] ]]; then lang_code="hin"
                elif [[ "$sub_basename_lower" =~ ^(hungarian|hun)[._-] ]]; then lang_code="hun"
                elif [[ "$sub_basename_lower" =~ ^(icelandic|ice)[._-] ]]; then lang_code="ice"
                elif [[ "$sub_basename_lower" =~ ^(indonesian|ind)[._-] ]]; then lang_code="ind"
                elif [[ "$sub_basename_lower" =~ ^(italian|ita)[._-] ]]; then lang_code="ita"
                elif [[ "$sub_basename_lower" =~ ^(japanese|jpn)[._-] ]]; then lang_code="jpn"
                elif [[ "$sub_basename_lower" =~ ^(kannada|kan)[._-] ]]; then lang_code="kan"
                elif [[ "$sub_basename_lower" =~ ^(kazakh|kaz)[._-] ]]; then lang_code="kaz"
                elif [[ "$sub_basename_lower" =~ ^(khmer|cambodian|khm)[._-] ]]; then lang_code="khm"
                elif [[ "$sub_basename_lower" =~ ^(korean|kor)[._-] ]]; then lang_code="kor"
                elif [[ "$sub_basename_lower" =~ ^(kurdish|kur)[._-] ]]; then lang_code="kur"
                elif [[ "$sub_basename_lower" =~ ^(latvian|lav)[._-] ]]; then lang_code="lav"
                elif [[ "$sub_basename_lower" =~ ^(lithuanian|lit)[._-] ]]; then lang_code="lit"
                elif [[ "$sub_basename_lower" =~ ^(macedonian|mac)[._-] ]]; then lang_code="mac"
                elif [[ "$sub_basename_lower" =~ ^(malay|may|msa)[._-] ]]; then lang_code="may"
                elif [[ "$sub_basename_lower" =~ ^(malayalam|mal)[._-] ]]; then lang_code="mal"
                elif [[ "$sub_basename_lower" =~ ^(manipuri|mni)[._-] ]]; then lang_code="mni"
                elif [[ "$sub_basename_lower" =~ ^(mongolian|mon)[._-] ]]; then lang_code="mon"
                elif [[ "$sub_basename_lower" =~ ^(nepali|nep)[._-] ]]; then lang_code="nep"
                elif [[ "$sub_basename_lower" =~ ^(norwegian|nor)[._-] ]]; then lang_code="nor"
                elif [[ "$sub_basename_lower" =~ ^(pashto|pus)[._-] ]]; then lang_code="pus"
                elif [[ "$sub_basename_lower" =~ ^(polish|pol)[._-] ]]; then lang_code="pol"
                elif [[ "$sub_basename_lower" =~ ^(portuguese|por)[._-] ]]; then lang_code="por"
                elif [[ "$sub_basename_lower" =~ ^(punjabi|pan)[._-] ]]; then lang_code="pan"
                elif [[ "$sub_basename_lower" =~ ^(romanian|rum)[._-] ]]; then lang_code="rum"
                elif [[ "$sub_basename_lower" =~ ^(russian|rus)[._-] ]]; then lang_code="rus"
                elif [[ "$sub_basename_lower" =~ ^(serbian|srp)[._-] ]]; then lang_code="srp"
                elif [[ "$sub_basename_lower" =~ ^(sinhala|sin)[._-] ]]; then lang_code="sin"
                elif [[ "$sub_basename_lower" =~ ^(slovak|slo)[._-] ]]; then lang_code="slo"
                elif [[ "$sub_basename_lower" =~ ^(slovenian|slv)[._-] ]]; then lang_code="slv"
                elif [[ "$sub_basename_lower" =~ ^(somali|som)[._-] ]]; then lang_code="som"
                elif [[ "$sub_basename_lower" =~ ^(latin.american|latinoamericano|spanish.latin.america|spanish.latin|es-la)[._-] ]]; then lang_code="spa"
                elif [[ "$sub_basename_lower" =~ ^(spanish.spain|castilian|es-es)[._-] ]]; then lang_code="spa"
                elif [[ "$sub_basename_lower" =~ ^(spanish|spa|esp)[._-] ]]; then lang_code="spa"
                elif [[ "$sub_basename_lower" =~ ^(sundanese|sun)[._-] ]]; then lang_code="sun"
                elif [[ "$sub_basename_lower" =~ ^(swahili|swa)[._-] ]]; then lang_code="swa"
                elif [[ "$sub_basename_lower" =~ ^(swedish|swe)[._-] ]]; then lang_code="swe"
                elif [[ "$sub_basename_lower" =~ ^(tagalog|tgl)[._-] ]]; then lang_code="tgl"
                elif [[ "$sub_basename_lower" =~ ^(tamil|tam)[._-] ]]; then lang_code="tam"
                elif [[ "$sub_basename_lower" =~ ^(telugu|tel)[._-] ]]; then lang_code="tel"
                elif [[ "$sub_basename_lower" =~ ^(thai|tha)[._-] ]]; then lang_code="tha"
                elif [[ "$sub_basename_lower" =~ ^(turkish|tur)[._-] ]]; then lang_code="tur"
                elif [[ "$sub_basename_lower" =~ ^(ukrainian|ukr)[._-] ]]; then lang_code="ukr"
                elif [[ "$sub_basename_lower" =~ ^(urdu|urd)[._-] ]]; then lang_code="urd"
                elif [[ "$sub_basename_lower" =~ ^(vietnamese|vie)[._-] ]]; then lang_code="vie"
                # Default to eng if no language detected
                else
                    lang_code="eng"
                fi
                
                # Build new subtitle name matching video file (remove extension from video basename)
                local video_base="${new_video_basename%.*}"
                
                # Extract ALL descriptors present (regional, simplified, traditional, forced, sdh, hi, cc, etc.)
                local -a descriptors=()
                local has_regional=false
                
                # Regional descriptors (must come before general language patterns)
                # Check multi-word regions first to avoid partial matches
                
                # Spanish regions
                if [[ "$sub_basename_lower" =~ (latin[[:space:]._-]+american|latinoamericano|latam) ]]; then
                    descriptors+=("latinamerican")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (castilian|spain) ]]; then
                    descriptors+=("spain")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (mexican|mexico) ]]; then
                    descriptors+=("mexican")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (argentine|argentina) ]]; then
                    descriptors+=("argentine")
                    has_regional=true
                fi
                
                # Portuguese regions
                if [[ "$sub_basename_lower" =~ (brazilian|brazil) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("brazilian")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (european.portuguese|portugal) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("european")
                    has_regional=true
                fi
                
                # English regions (skip if already matched latin american to avoid "american" overlap)
                if [[ "$sub_basename_lower" =~ (british|uk) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("british")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ ^(american|us)[^a-z] ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("american")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (australian|australia) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("australian")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (canadian.english) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("canadian")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (new.zealand) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("newzealand")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (south.african) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("southafrican")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (irish|ireland) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("irish")
                    has_regional=true
                fi
                
                # French regions
                if [[ "$sub_basename_lower" =~ (canadian.french|quebec) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("canadian")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (belgian.french) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("belgian")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (swiss.french) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("swiss")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (african.french) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("african")
                    has_regional=true
                fi
                
                # German regions
                if [[ "$sub_basename_lower" =~ (swiss.german) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("swiss")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (austrian) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("austrian")
                    has_regional=true
                fi
                
                # Chinese regions
                if [[ "$sub_basename_lower" =~ (hong.kong|hongkong) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("hongkong")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (taiwan) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("taiwan")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (singapore) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("singapore")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (mainland|prc) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("mainland")
                    has_regional=true
                fi
                
                # Arabic regions
                if [[ "$sub_basename_lower" =~ (egyptian|egypt) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("egyptian")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (gulf) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("gulf")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (levantine) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("levantine")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (maghreb) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("maghreb")
                    has_regional=true
                fi
                
                # Dutch regions
                if [[ "$sub_basename_lower" =~ (flemish|belgian.dutch) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("flemish")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (netherlands) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("netherlands")
                    has_regional=true
                fi
                
                # Norwegian variants
                if [[ "$sub_basename_lower" =~ (bokmal) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("bokmal")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (nynorsk) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("nynorsk")
                    has_regional=true
                fi
                
                # Serbian variants (skip if latin american already matched to avoid "latin" overlap)
                if [[ "$sub_basename_lower" =~ (cyrillic) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("cyrillic")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ ^(latin)[^a-z] ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("latin")
                    has_regional=true
                fi
                
                # Language variant descriptors
                if [[ "$sub_basename_lower" =~ (simplified|simp) ]]; then
                    descriptors+=("simplified")
                fi
                if [[ "$sub_basename_lower" =~ (traditional|trad) ]]; then
                    descriptors+=("traditional")
                fi
                if [[ "$sub_basename_lower" =~ (cantonese) ]]; then
                    descriptors+=("cantonese")
                fi
                
                # Quality/format descriptors
                if [[ "$sub_basename_lower" =~ (forced) ]]; then
                    descriptors+=("forced")
                fi
                if [[ "$sub_basename_lower" =~ sdh ]]; then
                    descriptors+=("sdh")
                fi
                if [[ "$sub_basename_lower" =~ \bhi\b ]]; then
                    descriptors+=("hi")
                fi
                if [[ "$sub_basename_lower" =~ \bcc\b ]]; then
                    descriptors+=("cc")
                fi
                if [[ "$sub_basename_lower" =~ (commentary) ]]; then
                    descriptors+=("commentary")
                fi
                
                # Build filename: moviename[.descriptor1][.descriptor2].langcode.ext
                local new_sub_name="${video_base}"
                
                # Add all descriptors in order
                for desc in "${descriptors[@]}"; do
                    new_sub_name="${new_sub_name}.${desc}"
                done
                
                # Add language code
                if [[ -n "$lang_code" ]]; then
                    new_sub_name="${new_sub_name}.${lang_code}"
                fi
                
                # Add extension
                new_sub_name="${new_sub_name}.${sub_ext}"
                
                local dest_subtitle="${movie_folder}/${new_sub_name}"
                
                # Check if subtitle already exists and is hardlinked
                if [[ -f "$dest_subtitle" ]]; then
                    local source_inode=$(stat -f "%i" "$sub_file" 2>/dev/null || stat -c "%i" "$sub_file" 2>/dev/null)
                    local dest_inode=$(stat -f "%i" "$dest_subtitle" 2>/dev/null || stat -c "%i" "$dest_subtitle" 2>/dev/null)
                    
                    if [[ "$source_inode" != "$dest_inode" ]]; then
                        rm "$dest_subtitle"
                        if $USE_COPY; then
                            cp "$sub_file" "$dest_subtitle"
                        elif $USE_SYMLINK; then
                            ln -s "$sub_file" "$dest_subtitle"
                        else
                            ln "$sub_file" "$dest_subtitle" 2>/dev/null || cp "$sub_file" "$dest_subtitle"
                        fi
                        ((subtitle_count++))
                    fi
                else
                    if $USE_COPY; then
                        cp "$sub_file" "$dest_subtitle"
                    elif $USE_SYMLINK; then
                        ln -s "$sub_file" "$dest_subtitle"
                    else
                        ln "$sub_file" "$dest_subtitle" 2>/dev/null || cp "$sub_file" "$dest_subtitle"
                    fi
                    ((subtitle_count++))
                fi
            done < <(find "$subs_dir" -type f \( -iname "*.srt" -o -iname "*.sub" -o -iname "*.idx" -o -iname "*.ass" -o -iname "*.ssa" -o -iname "*.vtt" \) -print0)
        done < <(find "$source_dir" -maxdepth 1 -type d \( -iname "subs" -o -iname "subtitles" -o -iname "subtitle" -o -iname "lang" -o -iname "language" -o -iname "languages" \) -print0)
    fi
    
    [[ $subtitle_count -gt 0 ]] && print_success "Hardlinked $subtitle_count subtitle file(s)"
        should_debug low && echo "[DEBUG] Subtitle processing complete for episode S${TV_SEASON}E${TV_EPISODE}: $subtitle_count subtitles processed" >&2
    # Hardlink extras/bonus content if enabled (Plex/Emby/Jellyfin format)
    if [[ "$HARDLINK_EXTRAS" == "true" ]] || [[ "$HARDLINK_EXTRAS" == "no-rename" ]]; then
        local extras_count=0
        # Official Plex/Emby/Jellyfin extras folder names
        local -a extras_folders=("behind the scenes" "deleted scenes" "interviews" "scenes" "samples" "shorts" "featurettes" "clips" "other" "extras" "trailers")
        
        # Process existing extras folders (exact match)
        for folder_name in "${extras_folders[@]}"; do
            while IFS= read -r -d '' extras_dir; do
                local extras_dirname=$(basename "$extras_dir")
                local dest_extras_dir="${movie_folder}/${extras_dirname}"
                mkdir -p "$dest_extras_dir"
                
                # Hardlink video files and subtitles from extras directory
                while IFS= read -r -d '' extra_file; do
                    local extra_basename=$(basename "$extra_file")
                    local dest_extra="${dest_extras_dir}/${extra_basename}"
                    
                    # Check if extra file already exists and is hardlinked
                    if [[ -f "$dest_extra" ]]; then
                        local source_inode=$(stat -f "%i" "$extra_file" 2>/dev/null || stat -c "%i" "$extra_file" 2>/dev/null)
                        local dest_inode=$(stat -f "%i" "$dest_extra" 2>/dev/null || stat -c "%i" "$dest_extra" 2>/dev/null)
                        
                        if [[ "$source_inode" != "$dest_inode" ]]; then
                            rm "$dest_extra"
                            if $USE_COPY; then
                                cp "$extra_file" "$dest_extra"
                            elif $USE_SYMLINK; then
                                ln -s "$extra_file" "$dest_extra"
                            else
                                ln "$extra_file" "$dest_extra" 2>/dev/null || cp "$extra_file" "$dest_extra"
                            fi
                            ((extras_count++))
                        fi
                    else
                        if $USE_COPY; then
                            cp "$extra_file" "$dest_extra"
                        elif $USE_SYMLINK; then
                            ln -s "$extra_file" "$dest_extra"
                        else
                            ln "$extra_file" "$dest_extra" 2>/dev/null || cp "$extra_file" "$dest_extra"
                        fi
                        ((extras_count++))
                    fi
                done < <(find "$extras_dir" -type f \( -iname "*.mkv" -o -iname "*.mp4" -o -iname "*.avi" -o -iname "*.m4v" -o -iname "*.mov" -o -iname "*.vob" -o -iname "*.wmv" -o -iname "*.flv" -o -iname "*.webm" -o -iname "*.ts" -o -iname "*.m2ts" -o -iname "*.mpg" -o -iname "*.mpeg" -o -iname "*.srt" -o -iname "*.sub" -o -iname "*.idx" -o -iname "*.ass" -o -iname "*.ssa" \) -print0)
            done < <(find "$source_dir" -maxdepth 1 -type d -iname "$folder_name" -print0)
        done
        
        # Process folders with extras-related keywords (like "Movie.Extras-Grym", "Other", etc.)
        while IFS= read -r -d '' extras_dir; do
            local extras_dirname=$(basename "$extras_dir")
            local extras_lower=$(echo "$extras_dirname" | tr '[:upper:]' '[:lower:]')
            
            # Skip if already processed (exact match above) or is the main movie folder
            [[ "$extras_dir" == "$source_dir" ]] && continue
            
            # Determine which standard extras folder this should map to
            local target_folder=""
            if [[ "$extras_lower" =~ (behind.?the.?scene|bts|making.?of) ]]; then
                target_folder="behind the scenes"
            elif [[ "$extras_lower" =~ deleted.?scene ]]; then
                target_folder="deleted scenes"
            elif [[ "$extras_lower" =~ interview ]]; then
                target_folder="interviews"
            elif [[ "$extras_lower" =~ sample ]]; then
                target_folder="samples"
            elif [[ "$extras_lower" =~ short ]]; then
                target_folder="shorts"
            elif [[ "$extras_lower" =~ featurette ]]; then
                target_folder="featurettes"
            elif [[ "$extras_lower" =~ clip ]]; then
                target_folder="clips"
            elif [[ "$extras_lower" =~ trailer ]]; then
                target_folder="trailers"
            elif [[ "$extras_lower" =~ extra ]]; then
                target_folder="extras"
            elif [[ "$extras_lower" =~ bonus ]]; then
                target_folder="extras"
            elif [[ "$extras_lower" =~ other ]]; then
                target_folder="other"
            else
                # Skip folders that don't match extras patterns
                continue
            fi
            
            local dest_extras_dir="${movie_folder}/${target_folder}"
            mkdir -p "$dest_extras_dir"
            
            # Hardlink all video files from this extras folder
            while IFS= read -r -d '' extra_file; do
                local extra_basename=$(basename "$extra_file")
                local dest_extra="${dest_extras_dir}/${extra_basename}"
                
                # Check if extra file already exists and is hardlinked
                if [[ -f "$dest_extra" ]]; then
                    local source_inode=$(stat -f "%i" "$extra_file" 2>/dev/null || stat -c "%i" "$extra_file" 2>/dev/null)
                    local dest_inode=$(stat -f "%i" "$dest_extra" 2>/dev/null || stat -c "%i" "$dest_extra" 2>/dev/null)
                    
                    if [[ "$source_inode" != "$dest_inode" ]]; then
                        rm "$dest_extra"
                        if $USE_COPY; then
                            cp "$extra_file" "$dest_extra"
                        elif $USE_SYMLINK; then
                            ln -s "$extra_file" "$dest_extra"
                        else
                            ln "$extra_file" "$dest_extra" 2>/dev/null || cp "$extra_file" "$dest_extra"
                        fi
                        ((extras_count++))
                    fi
                else
                    if $USE_COPY; then
                        cp "$extra_file" "$dest_extra"
                    elif $USE_SYMLINK; then
                        ln -s "$extra_file" "$dest_extra"
                    else
                        ln "$extra_file" "$dest_extra" 2>/dev/null || cp "$extra_file" "$dest_extra"
                    fi
                    ((extras_count++))
                fi
            done < <(find "$extras_dir" -type f \( -iname "*.mkv" -o -iname "*.mp4" -o -iname "*.avi" -o -iname "*.m4v" -o -iname "*.mov" -o -iname "*.vob" -o -iname "*.wmv" -o -iname "*.flv" -o -iname "*.webm" -o -iname "*.ts" -o -iname "*.m2ts" -o -iname "*.mpg" -o -iname "*.mpeg" -o -iname "*.srt" -o -iname "*.sub" -o -iname "*.idx" -o -iname "*.ass" -o -iname "*.ssa" \) -print0)
        done < <(find "$source_dir" -maxdepth 1 -type d ! -path "$source_dir" -print0)
        
        # Process loose extras files (not in folders) - categorize by filename
        while IFS= read -r -d '' extra_file; do
            local extra_basename=$(basename "$extra_file")
            local extra_lower=$(echo "$extra_basename" | tr '[:upper:]' '[:lower:]')
            
            # Determine which extras folder this file belongs to based on filename
            local target_folder=""
            if [[ "$extra_lower" =~ (behind.?the.?scene|bts|making.?of) ]]; then
                target_folder="behind the scenes"
            elif [[ "$extra_lower" =~ deleted.?scene ]]; then
                target_folder="deleted scenes"
            elif [[ "$extra_lower" =~ interview ]]; then
                target_folder="interviews"
            elif [[ "$extra_lower" =~ sample ]]; then
                target_folder="samples"
            elif [[ "$extra_lower" =~ short ]]; then
                target_folder="shorts"
            elif [[ "$extra_lower" =~ featurette ]]; then
                target_folder="featurettes"
            elif [[ "$extra_lower" =~ clip ]]; then
                target_folder="clips"
            elif [[ "$extra_lower" =~ scene ]]; then
                target_folder="scenes"
            elif [[ "$extra_lower" =~ trailer ]]; then
                target_folder="trailers"
            elif [[ "$extra_lower" =~ (extra|bonus) ]]; then
                target_folder="extras"
            else
                # Default catch-all
                target_folder="other"
            fi
            
            # Create destination extras folder and hardlink file
            local dest_extras_dir="${movie_folder}/${target_folder}"
            mkdir -p "$dest_extras_dir"
            local dest_extra="${dest_extras_dir}/${extra_basename}"
            
            # Check if extra file already exists and is hardlinked
            if [[ -f "$dest_extra" ]]; then
                local source_inode=$(stat -f "%i" "$extra_file" 2>/dev/null || stat -c "%i" "$extra_file" 2>/dev/null)
                local dest_inode=$(stat -f "%i" "$dest_extra" 2>/dev/null || stat -c "%i" "$dest_extra" 2>/dev/null)
                
                if [[ "$source_inode" != "$dest_inode" ]]; then
                    rm "$dest_extra"
                    if $USE_COPY; then
                        cp "$extra_file" "$dest_extra"
                    elif $USE_SYMLINK; then
                        ln -s "$extra_file" "$dest_extra"
                    else
                        ln "$extra_file" "$dest_extra" 2>/dev/null || cp "$extra_file" "$dest_extra"
                    fi
                    ((extras_count++))
                fi
            else
                if $USE_COPY; then
                    cp "$extra_file" "$dest_extra"
                elif $USE_SYMLINK; then
                    ln -s "$extra_file" "$dest_extra"
                else
                    ln "$extra_file" "$dest_extra" 2>/dev/null || cp "$extra_file" "$dest_extra"
                fi
                ((extras_count++))
            fi
        done < <(find "$source_dir" -maxdepth 1 -type f \( -iname "*behind*the*scene*" -o -iname "*bts*" -o -iname "*making*of*" -o -iname "*deleted*scene*" -o -iname "*interview*" -o -iname "*featurette*" -o -iname "*trailer*" -o -iname "*bonus*" -o -iname "*extra*" -o -iname "*short*" -o -iname "*sample*" -o -iname "*clip*" \) \( -iname "*.mkv" -o -iname "*.mp4" -o -iname "*.avi" -o -iname "*.m4v" -o -iname "*.mov" -o -iname "*.vob" -o -iname "*.wmv" -o -iname "*.flv" -o -iname "*.webm" -o -iname "*.ts" -o -iname "*.m2ts" -o -iname "*.mpg" -o -iname "*.mpeg" \) -print0)
        
        [[ $extras_count -gt 0 ]] && print_success "Hardlinked $extras_count file(s) from extras folders and loose extras files"
    elif [[ "$HARDLINK_EXTRAS" == "preserve" ]]; then
        # Preserve folder structure mode - only hardlink video files and subtitle files
        local extras_count=0
        
        # Mirror the entire directory structure, but only hardlink video and subtitle files
        while IFS= read -r -d '' source_file; do
            # Get the relative path from source_dir
            local rel_path="${source_file#$source_dir/}"
            
            # Skip if this is the main movie file or its associated files
            [[ "$source_file" == "$video_file" ]] && continue
            [[ "$source_file" == "$subtitle_file" ]] && continue
            
            # Create the destination path preserving folder structure
            local dest_file="${movie_folder}/${rel_path}"
            local dest_dir=$(dirname "$dest_file")
            
            # Create the directory structure if it doesn't exist
            mkdir -p "$dest_dir"
            
            # Check if file already exists and is hardlinked
            if [[ -f "$dest_file" ]]; then
                local source_inode=$(stat -f "%i" "$source_file" 2>/dev/null || stat -c "%i" "$source_file" 2>/dev/null)
                local dest_inode=$(stat -f "%i" "$dest_file" 2>/dev/null || stat -c "%i" "$dest_file" 2>/dev/null)
                
                if [[ "$source_inode" != "$dest_inode" ]]; then
                    rm "$dest_file"
                    if $USE_COPY; then
                        cp "$source_file" "$dest_file"
                    elif $USE_SYMLINK; then
                        ln -s "$source_file" "$dest_file"
                    else
                        ln "$source_file" "$dest_file" 2>/dev/null || cp "$source_file" "$dest_file"
                    fi
                    ((extras_count++))
                fi
            else
                if $USE_COPY; then
                    cp "$source_file" "$dest_file"
                elif $USE_SYMLINK; then
                    ln -s "$source_file" "$dest_file"
                else
                    ln "$source_file" "$dest_file" 2>/dev/null || cp "$source_file" "$dest_file"
                fi
                ((extras_count++))
            fi
        done < <(find "$source_dir" -type f \( -iname "*.mkv" -o -iname "*.mp4" -o -iname "*.avi" -o -iname "*.m4v" -o -iname "*.mov" -o -iname "*.vob" -o -iname "*.wmv" -o -iname "*.flv" -o -iname "*.webm" -o -iname "*.ts" -o -iname "*.m2ts" -o -iname "*.mpg" -o -iname "*.mpeg" -o -iname "*.srt" -o -iname "*.sub" -o -iname "*.idx" -o -iname "*.ass" -o -iname "*.ssa" -o -iname "*.vtt" \) -print0)
        
        [[ $extras_count -gt 0 ]] && print_success "Hardlinked $extras_count file(s) preserving original folder structure"
    fi
    
    # Release lock before returning
    release_file_lock "$source_file"
    return 0
}

# Function to edit custom format
edit_custom_format() {
    local format_type="$1"  # "folder" or "file"
    local format_file
    local default_format
    
    if [[ "$format_type" == "folder" ]]; then
        format_file="$CUSTOM_FOLDER_FORMAT"
        default_format="{Movie CleanTitle} ({Release Year})"
    else
        format_file="$CUSTOM_FILE_FORMAT"
        default_format="{Movie CleanTitle} ({Release Year})"
    fi
    
    # Load existing custom format or use default
    local current_format
    if [[ -f "$format_file" ]]; then
        current_format=$(<"$format_file")
    else
        current_format="$default_format"
    fi
    
    echo
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${CYAN}Custom ${format_type^} Format Editor${NC}"
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo
    echo -e "${YELLOW}Available Variables:${NC}"
    echo "  {Movie CleanTitle}    - Movie title without special characters"
    echo "  {Release Year}        - Year of release"
    echo "  {ImdbId}              - IMDb ID (e.g., tt1234567)"
    echo "  {TmdbId}              - TMDb ID (e.g., 12345)"
    
    if [[ "$format_type" == "file" ]]; then
        echo
        echo -e "${YELLOW}Additional File Variables:${NC}"
        echo "  {Edition Tags}        - Edition info (e.g., Extended, Director's Cut)"
        echo "  {Quality Full}        - Quality (e.g., Bluray-1080p, WEBDL-2160p)"
        echo "  {Custom Formats}      - Custom format tags"
        echo "  {MediaInfo 3D}        - 3D indicator"
        echo "  {AudioCodec}          - Audio codec (e.g., DTS, TrueHD)"
        echo "  {AudioChannels}       - Audio channels (e.g., 5.1, 7.1)"
        echo "  {AudioLanguages}      - Audio languages (e.g., EN, DE)"
        echo "  {VideoDynamicRange}   - HDR type (e.g., DV, HDR10)"
        echo "  {VideoCodec}          - Video codec (e.g., x264, HEVC)"
        echo "  {VideoBitDepth}       - Bit depth (e.g., 10bit)"
        echo "  {Release Group}       - Release group name"
    fi
    
    echo
    echo -e "${YELLOW}Format Styles:${NC}"
    echo "  Curly braces:   {imdb-{ImdbId}}    → {imdb-tt1234567}"
    echo "  Square brackets: [imdb-{ImdbId}]   → [imdb-tt1234567]"
    echo "  Dots:           {Movie.CleanTitle} → Movie.Title"
    echo "  Spaces:         {Movie CleanTitle} → Movie Title"
    echo
    echo -e "${GREEN}Current format:${NC}"
    echo "  $current_format"
    echo
    echo -e "${YELLOW}Options:${NC}"
    echo "  ${GREEN}e${NC}) Edit format"
    echo "  ${GREEN}t${NC}) Test format with example"
    echo "  ${GREEN}r${NC}) Reset to default"
    echo "  ${GREEN}s${NC}) Save and return"
    echo "  ${GREEN}q${NC}) Cancel without saving"
    echo
    
    while true; do
        read -p "$(echo -e ${CYAN}Choose option:${NC} )" choice
        
        case "$choice" in
            e|E)
                echo
                echo -e "${CYAN}Enter new format (or press Enter to keep current):${NC}"
                read -e -i "$current_format" new_format
                if [[ -n "$new_format" ]]; then
                    current_format="$new_format"
                    echo -e "${GREEN}✓${NC} Format updated"
                fi
                echo
                echo -e "${GREEN}Current format:${NC} $current_format"
                echo
                ;;
            t|T)
                echo
                echo -e "${CYAN}Testing format with example data...${NC}"
                local test_output="$current_format"
                test_output="${test_output//\{Movie CleanTitle\}/The Movie Title}"
                test_output="${test_output//\{Movie.CleanTitle\}/The.Movie.Title}"
                test_output="${test_output//\{Release Year\}/2010}"
                test_output="${test_output//\{ImdbId\}/tt1234567}"
                test_output="${test_output//\{TmdbId\}/345691}"
                test_output="${test_output//\{Edition Tags\}/Ultimate Extended Edition}"
                test_output="${test_output//\{Quality Full\}/Bluray-1080p Proper}"
                test_output="${test_output//\{Custom Formats\}/IMAX HYBRID}"
                test_output="${test_output//\{MediaInfo 3D\}/3D}"
                test_output="${test_output//\{AudioCodec\}/DTS}"
                test_output="${test_output//\{AudioChannels\}/5.1}"
                test_output="${test_output//\{AudioLanguages\}/EN}"
                test_output="${test_output//\{VideoDynamicRange\}/DV HDR10}"
                test_output="${test_output//\{VideoCodec\}/x264}"
                test_output="${test_output//\{VideoBitDepth\}/10bit}"
                test_output="${test_output//\{Release Group\}/RlsGrp}"
                echo -e "${GREEN}Example output:${NC}"
                echo "  $test_output"
                echo
                ;;
            r|R)
                current_format="$default_format"
                echo
                echo -e "${GREEN}✓${NC} Reset to default format"
                echo -e "${GREEN}Current format:${NC} $current_format"
                echo
                ;;
            s|S)
                echo "$current_format" > "$format_file"
                echo
                echo -e "${GREEN}✓${NC} Custom format saved"
                return 0
                ;;
            q|Q)
                echo
                echo -e "${YELLOW}Cancelled - no changes saved${NC}"
                return 1
                ;;
            *)
                echo -e "${RED}Invalid option${NC}"
                ;;
        esac
    done
}

# Arrow key selection menu
arrow_select_menu() {
    local title="$1"
    local saved_value="$2"
    local return_var="$3"
    shift 3
    local options=("$@")
    local selected_idx=0
    
    # Find currently selected index based on saved value
    for i in "${!options[@]}"; do
        local num="${options[$i]%%|*}"
        if [[ "$num" == "$saved_value" ]]; then
            selected_idx=$i
            break
        fi
    done
    
    # Timer for flashing instruction
    local flash_start=$SECONDS
    
    # Hide cursor
    tput civis 2>/dev/null
    
    while true; do
        # Clear screen and move to top
        clear
        
        echo ""
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${CYAN}$title${NC}"
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
        # Flash instruction for 5 seconds
        if [[ $((SECONDS - flash_start)) -lt 5 ]]; then
            echo -e "${YELLOW}\033[5mUse ↑/↓ arrow keys to navigate, Enter to select, 'b' to go back\033[25m${NC}"
        else
            echo -e "${YELLOW}Use ↑/↓ arrow keys to navigate, Enter to select, 'b' to go back${NC}"
        fi
        echo ""
        
        # Display options
        for i in "${!options[@]}"; do
            local num="${options[$i]%%|*}"
            local desc="${options[$i]#*|}"
            
            if [[ $i -eq $selected_idx ]]; then
                echo -e "  ${GREEN}► [✓] ${CYAN}$num) $desc${NC}"
            else
                echo -e "  ${DIM}  [ ] ${CYAN}$num) $desc${NC}"
            fi
        done
        
        echo ""
        echo -e "${DIM}Press Enter to confirm selection, 'b' to go back${NC}"
        
        # Read key input
        read -rsn1 key 2>/dev/null
        
        # Check if it's an escape sequence (arrow keys)
        if [[ "$key" == $'\x1b' ]]; then
            # Read next two characters for arrow keys
            read -rsn2 -t 1 key 2>/dev/null
            case "$key" in
                '[A'|'OA') # Up arrow
                    ((selected_idx--))
                    if [[ $selected_idx -lt 0 ]]; then
                        selected_idx=$((${#options[@]} - 1))
                    fi
                    ;;
                '[B'|'OB') # Down arrow
                    ((selected_idx++))
                    if [[ $selected_idx -ge ${#options[@]} ]]; then
                        selected_idx=0
                    fi
                    ;;
            esac
        elif [[ "$key" == "b" ]] || [[ "$key" == "B" ]]; then
            # Back key pressed
            tput cnorm 2>/dev/null  # Show cursor
            clear
            return 1
        elif [[ "$key" == "" ]]; then
            # Enter key pressed
            tput cnorm 2>/dev/null  # Show cursor
            clear
            local selected_num="${options[$selected_idx]%%|*}"
            # Use eval to set the variable in the calling scope
            eval "$return_var='$selected_num'"
            return 0
        fi
    done
}

# Link type selection with arrow key interface
select_link_type() {
    local -a link_opts=(
        "1|Hardlink (recommended for seeding)|Must be on same drive/volume/filesystem|Keeps original filename intact for seeding|Both files point to same data on disk|Deleting one file doesn't affect the other"
        "2|Symbolic link (for cross-volume)|Can link across different drives/volumes|Creates a pointer to original file|Original file must remain in place|Deleting original breaks the link"
        "3|Copy files|Creates full duplicate (uses more space)|Works across any filesystem||"
    )
    local selected_idx=0
    
    # Load saved preference
    if [[ -f "$LINK_TYPE_PREFS" ]]; then
        local saved_type=$(cat "$LINK_TYPE_PREFS")
        case "$saved_type" in
            "hardlink")
                selected_idx=0
                USE_SYMLINK=false
                USE_COPY=false
                ;;
            "symlink")
                selected_idx=1
                USE_SYMLINK=true
                USE_COPY=false
                ;;
            "copy")
                selected_idx=2
                USE_SYMLINK=false
                USE_COPY=true
                ;;
        esac
    fi
    
    # Hide cursor
    tput civis 2>/dev/null
    
    while true; do
        # Clear screen and move to top
        clear
        
        echo ""
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${CYAN}LINK TYPE SELECTION${NC}"
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
        echo -e "${YELLOW}Use ↑/↓ arrow keys to navigate, Enter to select, 'b' to go back${NC}"
        echo ""
        
        # Display options
        for i in "${!link_opts[@]}"; do
            IFS='|' read -r num title desc1 desc2 desc3 desc4 <<< "${link_opts[$i]}"
            
            if [[ $i -eq $selected_idx ]]; then
                echo -e "  ${GREEN}► [✓] $num) $title${NC}"
            else
                echo -e "  ${DIM}  [ ] $num) $title${NC}"
            fi
            echo -e "     ${DIM}• $desc1${NC}"
            [[ -n "$desc2" ]] && echo -e "     ${DIM}• $desc2${NC}"
            [[ -n "$desc3" ]] && echo -e "     ${DIM}• $desc3${NC}"
            [[ -n "$desc4" ]] && echo -e "     ${DIM}• $desc4${NC}"
            echo ""
        done
        
        echo -e "${DIM}Press Enter to confirm selection, 'b' to go back${NC}"
        
        # Read key input
        read -rsn1 key 2>/dev/null
        
        # Check if it's an escape sequence (arrow keys)
        if [[ "$key" == $'\x1b' ]]; then
            # Read next two characters for arrow keys
            read -rsn2 -t 1 key 2>/dev/null
            case "$key" in
                '[A'|'OA') # Up arrow
                    ((selected_idx--))
                    if [[ $selected_idx -lt 0 ]]; then
                        selected_idx=$((${#link_opts[@]} - 1))
                    fi
                    ;;
                '[B'|'OB') # Down arrow
                    ((selected_idx++))
                    if [[ $selected_idx -ge ${#link_opts[@]} ]]; then
                        selected_idx=0
                    fi
                    ;;
            esac
        elif [[ "$key" == "b" ]] || [[ "$key" == "B" ]]; then
            # Back key pressed
            tput cnorm 2>/dev/null  # Show cursor
            clear
            return 1
        elif [[ "$key" == "" ]]; then
            # Enter key pressed
            tput cnorm 2>/dev/null  # Show cursor
            clear
            local selected_num="${link_opts[$selected_idx]%%|*}"
            
            case "$selected_num" in
                1)
                    USE_SYMLINK=false
                    USE_COPY=false
                    echo "hardlink" > "$LINK_TYPE_PREFS"
                    ;;
                2)
                    USE_SYMLINK=true
                    USE_COPY=false
                    echo "symlink" > "$LINK_TYPE_PREFS"
                    ;;
                3)
                    USE_SYMLINK=false
                    USE_COPY=true
                    echo "copy" > "$LINK_TYPE_PREFS"
                    ;;
            esac
            return 0
        fi
    done
}

# Select extras/bonus content options
select_extras_options() {
    # Determine the action verb based on link type
    local action_verb="process"
    local action_verb_past="processed"
    local action_title="Process"
    if [[ "$USE_COPY" == "true" ]]; then
        action_verb="copy"
        action_verb_past="copied"
        action_title="Copy"
    elif [[ "$USE_SYMLINK" == "true" ]]; then
        action_verb="symlink"
        action_verb_past="symlinked"
        action_title="Symlink"
    else
        action_verb="hardlink"
        action_verb_past="hardlinked"
        action_title="Hardlink"
    fi
    
    local -a extras_opts=(
        "1|Don't ${action_verb} extras/bonus content|Only main video and subtitles are ${action_verb_past}|Skips featurettes, behind-the-scenes, bonus content|Sample files are automatically skipped"
        "2|${action_title} extras into subfolders|Extras are ${action_verb_past} with original filenames|Organized into proper subfolders (behind the scenes, samples, etc.)|Processes featurettes, behind-the-scenes, deleted scenes, trailers|Extracts and renames subtitles from Subs/Subtitles folders (MovieName.en.srt)"
        "3|${action_title} with preserved folder structure|Preserves original folder hierarchy|Only ${action_verb}s video and subtitle files|Includes: .mkv .mp4 .avi .mov .vob .srt .sub .idx .ass .ssa .vtt|All other files (nfo, jpg, txt, etc.) are skipped"
    )
    local selected_idx=0
    
    # Load saved preference
    if [[ -f "$EXTRAS_MODE_PREFS" ]]; then
        local saved_mode=$(cat "$EXTRAS_MODE_PREFS")
        if [[ "$saved_mode" == "true" ]]; then
            selected_idx=1
            HARDLINK_EXTRAS="true"
        elif [[ "$saved_mode" == "false" ]]; then
            selected_idx=0
            HARDLINK_EXTRAS="false"
        elif [[ "$saved_mode" == "preserve" ]]; then
            selected_idx=2
            HARDLINK_EXTRAS="preserve"
        fi
    elif [[ "$HARDLINK_EXTRAS" == "true" ]]; then
        selected_idx=1
    elif [[ "$HARDLINK_EXTRAS" == "preserve" ]]; then
        selected_idx=2
    fi
    
    # Hide cursor
    tput civis 2>/dev/null
    
    while true; do
        # Clear screen and move to top
        clear
        
        echo ""
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${CYAN}EXTRAS/BONUS CONTENT OPTIONS${NC}"
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
        echo -e "${YELLOW}Use ↑/↓ arrow keys to navigate, Enter to select, 'b' to go back${NC}"
        echo ""
        
        # Display options
        for i in "${!extras_opts[@]}"; do
            IFS='|' read -r num title desc1 desc2 desc3 desc4 <<< "${extras_opts[$i]}"
            
            if [[ $i -eq $selected_idx ]]; then
                echo -e "  ${GREEN}► [✓] $num) $title${NC}"
            else
                echo -e "  ${DIM}  [ ] $num) $title${NC}"
            fi
            echo -e "     ${DIM}• $desc1${NC}"
            [[ -n "$desc2" ]] && echo -e "     ${DIM}• $desc2${NC}"
            [[ -n "$desc3" ]] && echo -e "     ${DIM}• $desc3${NC}"
            [[ -n "$desc4" ]] && echo -e "     ${DIM}• $desc4${NC}"
            echo ""
        done
        
        echo -e "${DIM}Press Enter to confirm selection, 'b' to go back${NC}"
        
        # Read key input
        read -rsn1 key 2>/dev/null
        
        # Check if it's an escape sequence (arrow keys)
        if [[ "$key" == $'\x1b' ]]; then
            # Read next two characters for arrow keys
            read -rsn2 -t 1 key 2>/dev/null
            case "$key" in
                '[A'|'OA') # Up arrow
                    ((selected_idx--))
                    if [[ $selected_idx -lt 0 ]]; then
                        selected_idx=$((${#extras_opts[@]} - 1))
                    fi
                    ;;
                '[B'|'OB') # Down arrow
                    ((selected_idx++))
                    if [[ $selected_idx -ge ${#extras_opts[@]} ]]; then
                        selected_idx=0
                    fi
                    ;;
            esac
        elif [[ "$key" == "b" ]] || [[ "$key" == "B" ]]; then
            # Back key pressed
            tput cnorm 2>/dev/null  # Show cursor
            clear
            return 1
        elif [[ "$key" == "" ]]; then
            # Enter key pressed
            tput cnorm 2>/dev/null  # Show cursor
            clear
            local selected_num="${extras_opts[$selected_idx]%%|*}"
            
            case "$selected_num" in
                1)
                    HARDLINK_EXTRAS=false
                    echo "false" > "$EXTRAS_MODE_PREFS"
                    ;;
                2)
                    HARDLINK_EXTRAS=true
                    echo "true" > "$EXTRAS_MODE_PREFS"
                    ;;
                3)
                    HARDLINK_EXTRAS=preserve
                    echo "preserve" > "$EXTRAS_MODE_PREFS"
                    ;;
            esac
            return 0
        fi
    done
}

# Select parsing mode (Fast vs Thorough)
select_parsing_mode() {
    local -a parse_opts=(
        "fast|Fast Mode (Recommended)|Parses each file once and caches results in temp file|Reuses cached title/year during duplicate detection, cache sorting, and processing|Faster processing, especially for large batches|Suitable for most use cases"
        "fast-nocache|Fast No-Cache Mode|Parses each file once but doesn't use temp cache file|Still does duplicate detection and cache sorting by re-parsing|Slightly slower than fast mode|Good if temp file issues occur"
        "thorough|Thorough Mode|Re-parses files at each stage and caches results in temp file|Reuses cached results during each stage for consistency|More thorough than fast mode|Use if you suspect parsing inconsistencies"
        "thorough-nocache|Thorough No-Cache Mode|Re-parses files at each stage without using temp cache file|Skips cache-based file sorting but still does duplicate detection|Processes files in alphabetical order|Useful for debugging parsing issues"
    )
    local selected_idx=0
    
    # Load saved preference
    local parse_mode_file="$CACHE_DIR/parsing_mode.txt"
    if [[ -f "$parse_mode_file" ]]; then
        local saved_mode=$(cat "$parse_mode_file")
        if [[ "$saved_mode" == "fast-nocache" ]]; then
            selected_idx=1
        elif [[ "$saved_mode" == "thorough" ]]; then
            selected_idx=2
        elif [[ "$saved_mode" == "thorough-nocache" ]]; then
            selected_idx=3
        fi
    fi
    
    # Hide cursor
    tput civis 2>/dev/null
    
    while true; do
        # Clear screen and move to top
        clear
        
        echo ""
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${CYAN}PARSING MODE SELECTION${NC}"
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
        echo -e "${YELLOW}Use ↑/↓ arrow keys to navigate, Enter to select, 'b' to go back${NC}"
        echo ""
        
        # Display options
        for i in "${!parse_opts[@]}"; do
            IFS='|' read -r mode title desc1 desc2 desc3 desc4 <<< "${parse_opts[$i]}"
            
            if [[ $i -eq $selected_idx ]]; then
                echo -e "  ${GREEN}► [✓] $(echo "$title" | tr '[:lower:]' '[:upper:]')${NC}"
            else
                echo -e "  ${DIM}  [ ] $title${NC}"
            fi
            echo -e "     ${DIM}• $desc1${NC}"
            [[ -n "$desc2" ]] && echo -e "     ${DIM}• $desc2${NC}"
            [[ -n "$desc3" ]] && echo -e "     ${DIM}• $desc3${NC}"
            [[ -n "$desc4" ]] && echo -e "     ${DIM}• $desc4${NC}"
            echo ""
        done
        
        echo -e "${DIM}Press Enter to confirm selection, 'b' to go back${NC}"
        
        # Read key input
        read -rsn1 key 2>/dev/null
        
        if [[ "$key" == $'\x1b' ]]; then
            read -rsn2 -t 1 key 2>/dev/null
            case "$key" in
                '[A') # Up arrow
                    ((selected_idx > 0)) && ((selected_idx--))
                    ;;
                '[B') # Down arrow
                    ((selected_idx < ${#parse_opts[@]}-1)) && ((selected_idx++))
                    ;;
            esac
        elif [[ "$key" == "b" || "$key" == "B" ]]; then
            # Back pressed
            tput cnorm 2>/dev/null
            return 1
        elif [[ "$key" == "" ]]; then
            # Enter - confirm selection
            IFS='|' read -r mode title _ <<< "${parse_opts[$selected_idx]}"
            
            # Save preference
            echo "$mode" > "$parse_mode_file"
            
            tput cnorm 2>/dev/null
            return 0
        fi
    done
}

# Select copy mode options (only shown when USE_COPY is true)
select_copy_mode() {
    local -a copy_opts=(
        "1|Copy individual files with renaming|Only copies main video and subtitle files|Files are renamed according to naming scheme|Maintains organized library structure||"
        "2|Copy entire source folder as-is|Copies complete folder with all contents|Preserves original folder structure and filenames|Includes all extras, subtitles, and bonus content|No renaming applied|"
    )
    local selected_idx=0
    
    # Load saved preference
    if [[ -f "$COPY_MODE_PREFS" ]]; then
        local saved_mode=$(cat "$COPY_MODE_PREFS")
        if [[ "$saved_mode" == "true" ]]; then
            selected_idx=1
            COPY_ENTIRE_FOLDER="true"
        else
            selected_idx=0
            COPY_ENTIRE_FOLDER="false"
        fi
    elif [[ "$COPY_ENTIRE_FOLDER" == "true" ]]; then
        selected_idx=1
    fi
    
    # Hide cursor
    tput civis 2>/dev/null
    
    while true; do
        # Clear screen and move to top
        clear
        
        echo ""
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${CYAN}COPY MODE SELECTION${NC}"
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
        echo -e "${YELLOW}Use ↑/↓ arrow keys to navigate, Enter to select, 'b' to go back${NC}"
        echo ""
        
        # Display options
        for i in "${!copy_opts[@]}"; do
            IFS='|' read -r num title desc1 desc2 desc3 desc4 desc5 <<< "${copy_opts[$i]}"
            
            if [[ $i -eq $selected_idx ]]; then
                echo -e "  ${GREEN}► [✓] $num) $title${NC}"
            else
                echo -e "  ${DIM}  [ ] $num) $title${NC}"
            fi
            echo -e "     ${DIM}• $desc1${NC}"
            [[ -n "$desc2" ]] && echo -e "     ${DIM}• $desc2${NC}"
            [[ -n "$desc3" ]] && echo -e "     ${DIM}• $desc3${NC}"
            [[ -n "$desc4" ]] && echo -e "     ${DIM}• $desc4${NC}"
            [[ -n "$desc5" ]] && echo -e "     ${DIM}• $desc5${NC}"
            echo ""
        done
        
        echo -e "${DIM}Press Enter to confirm selection, 'b' to go back${NC}"
        
        # Read key input
        read -rsn1 key 2>/dev/null
        
        # Check if it's an escape sequence (arrow keys)
        if [[ "$key" == $'\x1b' ]]; then
            # Read next two characters for arrow keys
            read -rsn2 -t 1 key 2>/dev/null
            case "$key" in
                '[A'|'OA') # Up arrow
                    ((selected_idx--))
                    if [[ $selected_idx -lt 0 ]]; then
                        selected_idx=$((${#copy_opts[@]} - 1))
                    fi
                    ;;
                '[B'|'OB') # Down arrow
                    ((selected_idx++))
                    if [[ $selected_idx -ge ${#copy_opts[@]} ]]; then
                        selected_idx=0
                    fi
                    ;;
            esac
        elif [[ "$key" == "b" ]] || [[ "$key" == "B" ]]; then
            # Back key pressed
            tput cnorm 2>/dev/null  # Show cursor
            clear
            return 1
        elif [[ "$key" == "" ]]; then
            # Enter key pressed
            tput cnorm 2>/dev/null  # Show cursor
            clear
            local selected_num="${copy_opts[$selected_idx]%%|*}"
            
            case "$selected_num" in
                1)
                    COPY_ENTIRE_FOLDER=false
                    echo "false" > "$COPY_MODE_PREFS"
                    ;;
                2)
                    COPY_ENTIRE_FOLDER=true
                    echo "true" > "$COPY_MODE_PREFS"
                    ;;
            esac
            return 0
        fi
    done
}

# Select hardlink mode options (only shown when hardlinking)
select_hardlink_mode() {
    local -a hardlink_opts=(
        "1|Don't hardlink extras/bonus content|Only main video and subtitles are hardlinked|Skips featurettes, behind-the-scenes, bonus content|Sample files are automatically skipped"
        "2|Hardlink extras into subfolders|Extras are hardlinked with original filenames|Organized into proper subfolders (behind the scenes, samples, etc.)|Processes featurettes, behind-the-scenes, deleted scenes, trailers|Extracts and renames subtitles from Subs/Subtitles folders (MovieName.en.srt)"
        "3|Hardlink with preserved folder structure|Preserves original folder hierarchy|Only hardlinks video and subtitle files|Includes: .mkv .mp4 .avi .mov .vob .srt .sub .idx .ass .ssa .vtt|All other files (nfo, jpg, txt, etc.) are skipped"
    )
    local selected_idx=0
    
    # Load saved preference
    if [[ -f "$EXTRAS_MODE_PREFS" ]]; then
        local saved_mode=$(cat "$EXTRAS_MODE_PREFS")
        if [[ "$saved_mode" == "true" ]]; then
            selected_idx=1
            HARDLINK_EXTRAS="true"
        elif [[ "$saved_mode" == "false" ]]; then
            selected_idx=0
            HARDLINK_EXTRAS="false"
        elif [[ "$saved_mode" == "preserve" ]]; then
            selected_idx=2
            HARDLINK_EXTRAS="preserve"
        fi
    elif [[ "$HARDLINK_EXTRAS" == "true" ]]; then
        selected_idx=1
    elif [[ "$HARDLINK_EXTRAS" == "preserve" ]]; then
        selected_idx=2
    fi
    
    # Hide cursor
    tput civis 2>/dev/null
    
    while true; do
        # Clear screen and move to top
        clear
        
        echo ""
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${CYAN}HARDLINK MODE SELECTION${NC}"
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
        echo -e "${YELLOW}Use ↑/↓ arrow keys to navigate, Enter to select, 'b' to go back${NC}"
        echo ""
        
        # Display options
        for i in "${!hardlink_opts[@]}"; do
            IFS='|' read -r num title desc1 desc2 desc3 desc4 desc5 <<< "${hardlink_opts[$i]}"
            
            if [[ $i -eq $selected_idx ]]; then
                echo -e "  ${GREEN}► [✓] $num) $title${NC}"
            else
                echo -e "  ${DIM}  [ ] $num) $title${NC}"
            fi
            echo -e "     ${DIM}• $desc1${NC}"
            [[ -n "$desc2" ]] && echo -e "     ${DIM}• $desc2${NC}"
            [[ -n "$desc3" ]] && echo -e "     ${DIM}• $desc3${NC}"
            [[ -n "$desc4" ]] && echo -e "     ${DIM}• $desc4${NC}"
            [[ -n "$desc5" ]] && echo -e "     ${DIM}• $desc5${NC}"
            echo ""
        done
        
        echo -e "${DIM}Press Enter to confirm selection, 'b' to go back${NC}"
        
        # Read key input
        read -rsn1 key 2>/dev/null
        
        # Check if it's an escape sequence (arrow keys)
        if [[ "$key" == $'\x1b' ]]; then
            # Read next two characters for arrow keys
            read -rsn2 -t 1 key 2>/dev/null
            case "$key" in
                '[A'|'OA') # Up arrow
                    ((selected_idx--))
                    if [[ $selected_idx -lt 0 ]]; then
                        selected_idx=$((${#hardlink_opts[@]} - 1))
                    fi
                    ;;
                '[B'|'OB') # Down arrow
                    ((selected_idx++))
                    if [[ $selected_idx -ge ${#hardlink_opts[@]} ]]; then
                        selected_idx=0
                    fi
                    ;;
            esac
        elif [[ "$key" == "b" ]] || [[ "$key" == "B" ]]; then
            # Back key pressed
            tput cnorm 2>/dev/null  # Show cursor
            clear
            return 1
        elif [[ "$key" == "" ]]; then
            # Enter key pressed
            tput cnorm 2>/dev/null  # Show cursor
            clear
            local selected_num="${hardlink_opts[$selected_idx]%%|*}"
            
            case "$selected_num" in
                1)
                    HARDLINK_EXTRAS=false
                    echo "false" > "$EXTRAS_MODE_PREFS"
                    ;;
                2)
                    HARDLINK_EXTRAS=true
                    echo "true" > "$EXTRAS_MODE_PREFS"
                    ;;
                3)
                    HARDLINK_EXTRAS=preserve
                    echo "preserve" > "$EXTRAS_MODE_PREFS"
                    ;;
            esac
            return 0
        fi
    done
}

# Select symlink mode options (only shown when USE_SYMLINK is true)
select_symlink_mode() {
    local -a symlink_opts=(
        "1|Don't symlink extras/bonus content|Only main video and subtitles are symlinked|Skips featurettes, behind-the-scenes, bonus content|Sample files are automatically skipped"
        "2|Symlink extras into subfolders|Extras are symlinked with original filenames|Organized into proper subfolders (behind the scenes, samples, etc.)|Processes featurettes, behind-the-scenes, deleted scenes, trailers|Extracts and renames subtitles from Subs/Subtitles folders (MovieName.en.srt)"
        "3|Symlink with preserved folder structure|Preserves original folder hierarchy|Only symlinks video and subtitle files|Includes: .mkv .mp4 .avi .mov .vob .srt .sub .idx .ass .ssa .vtt|All other files (nfo, jpg, txt, etc.) are skipped"
    )
    local selected_idx=0
    
    # Load saved preference
    if [[ -f "$EXTRAS_MODE_PREFS" ]]; then
        local saved_mode=$(cat "$EXTRAS_MODE_PREFS")
        if [[ "$saved_mode" == "true" ]]; then
            selected_idx=1
            SYMLINK_EXTRAS="true"
        elif [[ "$saved_mode" == "false" ]]; then
            selected_idx=0
            SYMLINK_EXTRAS="false"
        elif [[ "$saved_mode" == "preserve" ]]; then
            selected_idx=2
            SYMLINK_EXTRAS="preserve"
        fi
    elif [[ "$SYMLINK_EXTRAS" == "true" ]]; then
        selected_idx=1
    elif [[ "$SYMLINK_EXTRAS" == "preserve" ]]; then
        selected_idx=2
    fi
    
    # Hide cursor
    tput civis 2>/dev/null
    
    while true; do
        # Clear screen and move to top
        clear
        
        echo ""
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${CYAN}SYMLINK MODE SELECTION${NC}"
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
        echo -e "${YELLOW}Use ↑/↓ arrow keys to navigate, Enter to select, 'b' to go back${NC}"
        echo ""
        
        # Display options
        for i in "${!symlink_opts[@]}"; do
            IFS='|' read -r num title desc1 desc2 desc3 desc4 desc5 <<< "${symlink_opts[$i]}"
            
            if [[ $i -eq $selected_idx ]]; then
                echo -e "  ${GREEN}► [✓] $num) $title${NC}"
            else
                echo -e "  ${DIM}  [ ] $num) $title${NC}"
            fi
            echo -e "     ${DIM}• $desc1${NC}"
            [[ -n "$desc2" ]] && echo -e "     ${DIM}• $desc2${NC}"
            [[ -n "$desc3" ]] && echo -e "     ${DIM}• $desc3${NC}"
            [[ -n "$desc4" ]] && echo -e "     ${DIM}• $desc4${NC}"
            [[ -n "$desc5" ]] && echo -e "     ${DIM}• $desc5${NC}"
            echo ""
        done
        
        echo -e "${DIM}Press Enter to confirm selection, 'b' to go back${NC}"
        
        # Read key input
        read -rsn1 key 2>/dev/null
        
        # Check if it's an escape sequence (arrow keys)
        if [[ "$key" == $'\x1b' ]]; then
            # Read next two characters for arrow keys
            read -rsn2 -t 1 key 2>/dev/null
            case "$key" in
                '[A'|'OA') # Up arrow
                    ((selected_idx--))
                    if [[ $selected_idx -lt 0 ]]; then
                        selected_idx=$((${#symlink_opts[@]} - 1))
                    fi
                    ;;
                '[B'|'OB') # Down arrow
                    ((selected_idx++))
                    if [[ $selected_idx -ge ${#symlink_opts[@]} ]]; then
                        selected_idx=0
                    fi
                    ;;
            esac
        elif [[ "$key" == "b" ]] || [[ "$key" == "B" ]]; then
            # Back key pressed
            tput cnorm 2>/dev/null  # Show cursor
            clear
            return 1
        elif [[ "$key" == "" ]]; then
            # Enter key pressed
            tput cnorm 2>/dev/null  # Show cursor
            clear
            local selected_num="${symlink_opts[$selected_idx]%%|*}"
            
            case "$selected_num" in
                1)
                    SYMLINK_EXTRAS=false
                    echo "false" > "$EXTRAS_MODE_PREFS"
                    ;;
                2)
                    SYMLINK_EXTRAS=true
                    echo "true" > "$EXTRAS_MODE_PREFS"
                    ;;
                3)
                    SYMLINK_EXTRAS=preserve
                    echo "preserve" > "$EXTRAS_MODE_PREFS"
                    ;;
            esac
            return 0
        fi
    done
}

# Normalize title for duplicate detection (case-insensitive + punctuation normalization)
normalize_title_for_comparison() {
    local title="$1"
    # Convert to lowercase
    title=$(echo "$title" | tr '[:upper:]' '[:lower:]')
    # Transliterate common accented characters to ASCII equivalents
    # This ensures "Così" becomes "cosi" not "cos"
    title=$(echo "$title" | sed 'y/àáâãäåèéêëìíîïòóôõöùúûüýÿñçÀÁÂÃÄÅÈÉÊËÌÍÎÏÒÓÔÕÖÙÚÛÜÝŸÑÇ/aaaaaaeeeeiiiiooooouuuuyyncAAAAAAEEEEIIIIOOOOOUUUUYYNC/')
    # Remove all apostrophes and quotes (', ", ', ')
    title=$(echo "$title" | sed "s/['\"\`''']//g")
    # Remove other punctuation and special characters (keep alphanumeric and spaces)
    title=$(echo "$title" | sed 's/[^a-z0-9 ]//g')
    # Remove ALL spaces to ensure "v h s" matches "vhs"
    title=$(echo "$title" | sed 's/ //g')
    echo "$title"
}

# Interactive duplicate selection with checkboxes
select_duplicates_to_process() {
    # Disable errexit for this function to prevent premature exit
    set +e
    
    local -a all_files=("$@")
    local temp_file="/tmp/movie_dup_groups_$$"
    local temp_parsed="/tmp/movie_parsed_$$"
    
    # Parse all files once and cache results
    > "$temp_file"
    > "$temp_parsed"
    
    local total=${#all_files[@]}
    local count=0
    
    echo "" >&2
    
    # Check if parallel parsing with rolling queue is enabled
    if [[ "$PARALLEL_PARSING" == "true" && "$PARSING_ROLLING_QUEUE_MODE" == "true" && $total -ge 2 ]]; then
        # Adaptive: use minimum of total files and PARALLEL_PARSE_JOBS
        local actual_jobs=$PARALLEL_PARSE_JOBS
        [[ $total -lt $actual_jobs ]] && actual_jobs=$total
        
        echo "  Analyzing files (rolling queue with $actual_jobs jobs)..." >&2
        
        # Rolling queue: indexed arrays for Bash 3.2 compatibility
        local -a active_pids=()
        local -a active_files=()
        local -a active_indices=()
        
        local file_index=0
        local completed=0
        
        # Temporary files for parallel processing
        local temp_batch_dir="/tmp/movie_dup_batch_$$"
        mkdir -p "$temp_batch_dir"
        
        # Keep queue full until all files are processed
        while [[ $file_index -lt $total ]] || [[ ${#active_pids[@]} -gt 0 ]]; do
            # Poll active jobs (non-blocking)
            for i in "${!active_pids[@]}"; do
                local pid="${active_pids[$i]}"
                if ! kill -0 "$pid" 2>/dev/null; then
                    # Process finished
                    wait "$pid" 2>/dev/null || true
                    ((completed++))
                    
                    # Update progress
                    printf "\r  Analyzed: %d/%d files" "$completed" "$total" >&2
                    
                    # Remove from active arrays
                    unset "active_pids[$i]"
                    unset "active_files[$i]"
                    unset "active_indices[$i]"
                fi
            done
            
            # Reindex arrays to remove gaps
            active_pids=("${active_pids[@]}")
            active_files=("${active_files[@]}")
            active_indices=("${active_indices[@]}")
            
            # Fill available slots
            while [[ ${#active_pids[@]} -lt $actual_jobs ]] && [[ $file_index -lt $total ]]; do
                local file="${all_files[$file_index]}"
                
                # Skip invalid files but count them
                if [[ "$file" == "unknown" || -z "$file" || ! -e "$file" ]]; then
                    should_debug medium && echo "[DEBUG] Skipping invalid file entry: '$file'" >&2
                    ((file_index++))
                    ((completed++))
                    continue
                fi
                
                # Launch background job for this file
                (
                    local batch_temp="$temp_batch_dir/file_${file_index}"
                    local batch_parsed="$temp_batch_dir/parsed_${file_index}"
                    > "$batch_temp"
                    > "$batch_parsed"
                    
                    # Parse parent folder first
                    local parent_folder=$(dirname "$file")
                    local folder_name=$(basename "$parent_folder")
                    parse_filename "$parent_folder" "folder"
                    local folder_title="$PARSED_TITLE"
                    local folder_year="$PARSED_YEAR"
                    
                    # Now parse the actual filename
                    parse_filename "$file"
                    
                    # Use folder info if filename parsing failed
                    if [[ -z "$PARSED_TITLE" && -n "$folder_title" ]]; then
                        PARSED_TITLE="$folder_title"
                    fi
                    if [[ -z "$PARSED_YEAR" && -n "$folder_year" ]]; then
                        PARSED_YEAR="$folder_year"
                    fi
                    
                    if [[ -n "$PARSED_TITLE" && -n "$PARSED_YEAR" ]]; then
                        local key="${PARSED_TITLE}|${PARSED_YEAR}"
                        local size=$(stat -f "%z" "$file" 2>/dev/null || stat -c "%s" "$file" 2>/dev/null)
                        echo "${key}|${file}|${size}" >> "$batch_temp"
                        echo "${file}|${PARSED_TITLE}|${PARSED_YEAR}" >> "$batch_parsed"
                    fi
                ) &
                
                local new_pid=$!
                active_pids+=("$new_pid")
                active_files+=("$file")
                active_indices+=("$file_index")
                
                ((file_index++))
            done
            
            sleep 0.1
        done
        
        echo "" >&2
        
        # Merge all results
        cat "$temp_batch_dir"/file_* > "$temp_file" 2>/dev/null || true
        cat "$temp_batch_dir"/parsed_* > "$temp_parsed" 2>/dev/null || true
        
        # Cleanup
        rm -rf "$temp_batch_dir"
    else
        # Sequential processing (when rolling queue disabled or not enough files)
        for file in "${all_files[@]}"; do
            ((count++))
            printf "\r  Analyzing files... %d/%d" "$count" "$total" >&2
            
            # Parse parent folder first (same logic as duplicate detection)
            local parent_folder=$(dirname "$file")
            local folder_name=$(basename "$parent_folder")
            parse_filename "$parent_folder" "folder"
            local folder_title="$PARSED_TITLE"
            local folder_year="$PARSED_YEAR"
            
            # Now parse the actual filename
            parse_filename "$file"
            
            # Use folder info if filename parsing failed or is incomplete
            if [[ -z "$PARSED_TITLE" && -n "$folder_title" ]]; then
                PARSED_TITLE="$folder_title"
            fi
            if [[ -z "$PARSED_YEAR" && -n "$folder_year" ]]; then
                PARSED_YEAR="$folder_year"
            fi
            
            if [[ -n "$PARSED_TITLE" && -n "$PARSED_YEAR" ]]; then
                local key="${PARSED_TITLE}|${PARSED_YEAR}"
                local size=$(stat -f "%z" "$file" 2>/dev/null || stat -c "%s" "$file" 2>/dev/null)
                echo "${key}|${file}|${size}" >> "$temp_file"
                echo "${file}|${PARSED_TITLE}|${PARSED_YEAR}" >> "$temp_parsed"
            fi
        done
        echo "" >&2
    fi
    
    # Quick check - if temp_file is empty or has fewer than 2 lines, no duplicates possible
    local line_count=$(wc -l < "$temp_file" 2>/dev/null | tr -d ' ')
    if [[ ! -s "$temp_file" ]] || [[ $line_count -lt 2 ]]; then
        rm -f "$temp_file" "$temp_parsed"
        printf '%s\n' "${all_files[@]}"
        return 0
    fi
    
    echo "  Finding duplicates..." >&2
    
    # Find movies with duplicates - group by title+year only (case-insensitive + normalized)
    local dup_keys_file="/tmp/movie_dup_keys_$$"
    local processed_normalized="/tmp/movie_processed_norm_$$"
    > "$dup_keys_file"
    > "$processed_normalized"
    
    # Get unique title+year combinations and check if they have multiple files
    cut -d'|' -f1,2 "$temp_file" | sort -f -u | while IFS='|' read -r title year; do
        # Normalize title for deduplication
        local title_normalized=$(normalize_title_for_comparison "$title")
        local norm_key="${title_normalized}|${year}"
        
        # Skip if we've already processed this normalized key
        if grep -Fxq "$norm_key" "$processed_normalized" 2>/dev/null; then
            continue
        fi
        echo "$norm_key" >> "$processed_normalized"
        
        # Count files for this normalized title+year
        local count=0
        while IFS='|' read -r t y file size; do
            local t_normalized=$(normalize_title_for_comparison "$t")
            if [[ "$t_normalized" == "$title_normalized" && "$y" == "$year" ]]; then
                ((count++))
            fi
        done < "$temp_file"
        
        # If more than one file, it's a duplicate (use original title for display)
        if [[ $count -gt 1 ]]; then
            echo "${title}|${year}" >> "$dup_keys_file"
        fi
    done
    
    local -a unique_keys=()
    while IFS= read -r key; do
        unique_keys+=("$key")
    done < "$dup_keys_file"
    rm -f "$dup_keys_file" "$processed_normalized"
    
    if [[ ${#unique_keys[@]} -eq 0 ]]; then
        echo "  No duplicates found!" >&2
        rm -f "$temp_file" "$temp_parsed"
        printf '%s\n' "${all_files[@]}"
        return 0
    fi
    
    echo "  Found ${#unique_keys[@]} movie(s) with duplicates" >&2
    echo "  Building file groups..." >&2
    
    # Build duplicate group info
    local -a group_data=()
    for key in "${unique_keys[@]}"; do
        local title="${key%%|*}"
        local year="${key##*|}"
        
        # Get all files for this key (title+year), sorted by size (largest first)
        local -a group_files=()
        local title_normalized=$(normalize_title_for_comparison "$title")
        while IFS='|' read -r ktitle kyear file size; do
            # Match files with same title and year (normalized comparison)
            local ktitle_normalized=$(normalize_title_for_comparison "$ktitle")
            if [[ "$ktitle_normalized" == "$title_normalized" && "$kyear" == "$year" ]]; then
                group_files+=("${file}|${size}")
            fi
        done < "$temp_file"
        
        # Sort by size (descending) - bubble sort for Bash 3.2 compatibility
        for ((i=0; i<${#group_files[@]}-1; i++)); do
            for ((j=i+1; j<${#group_files[@]}; j++)); do
                # Extract size (second field after splitting by |)
                local entry_i="${group_files[$i]}"
                local entry_j="${group_files[$j]}"
                local size_i="${entry_i#*|}"
                size_i="${size_i%%|*}"
                local size_j="${entry_j#*|}"
                size_j="${size_j%%|*}"
                
                if [[ $size_j -gt $size_i ]]; then
                    local temp="${group_files[$i]}"
                    group_files[$i]="${group_files[$j]}"
                    group_files[$j]="$temp"
                fi
            done
        done
        
        group_data+=("${title}|${year}||$(IFS='::'; echo "${group_files[*]}")")
    done
    
    # Display duplicates with numbered choices
    echo "" >&2
    echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}" >&2
    echo -e "${CYAN}DUPLICATE MOVIES FOUND${NC}" >&2
    echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}" >&2
    echo "" >&2
    
    local -a selected_files=()
    local -a all_choices=()
    
    # Show duplicates with numbers for each group
    local group_idx=0
    
    # Create temporary lookup cache file for duplicate selection to avoid re-querying same title/year
    local temp_dup_cache="/tmp/movie_dup_cache_$$"
    > "$temp_dup_cache"
    
    for gdata in "${group_data[@]}"; do
        local key="${gdata%%||*}"
        local title="${key%%|*}"
        local year="${key##*|}"
        local files_data="${gdata##*||}"
        
        echo -e "${BLUE}Movie ${group_idx}:${NC} ${title} (${year})" >&2
        echo "" >&2
        
        # Get IMDb IDs for each file to check if they're actually different movies
        IFS='::' read -ra file_array <<< "$files_data"
        local -a file_imdb_ids=()
        local -a unique_imdb_ids=()
        
        echo -e "${DIM}  Checking IMDb IDs for each file (this may take a moment)...${NC}" >&2
        
        # Create cache key for this title/year combo
        local cache_key="${title}|${year}"
        
        for file_info in "${file_array[@]}"; do
            local file_path="${file_info%%|*}"
            
            # Check cache first
            should_debug high && echo "[DEBUG] Looking up metadata for: TITLE='$title' YEAR='$year'" >&2
            local cached_data=$(get_cached_movie "$title" "$year")
            local file_imdb=""
            local file_tmdb=""
            
            if [[ -n "$cached_data" ]]; then
                file_imdb=$(extract_from_cache "$cached_data" "imdb")
                file_tmdb=$(extract_from_cache "$cached_data" "tmdb")
                should_debug high && echo "[DEBUG] Found in cache: IMDb=$file_imdb, TMDb=$file_tmdb" >&2
                echo -e "${DIM}    ✓ Using cached metadata: IMDb=$file_imdb, TMDb=$file_tmdb${NC}" >&2
            elif grep -q "^${cache_key}|" "$temp_dup_cache" 2>/dev/null; then
                # Use temporary duplicate selection cache (file-based for Bash 3.2 compatibility)
                # Cache format: title|year|imdb|tmdb (4 fields)
                local cached_line=$(grep "^${cache_key}|" "$temp_dup_cache" | head -1)
                # Extract field 3 (imdb) and field 4 (tmdb) from the cache line
                local temp="${cached_line#*|}"    # Remove title: "year|imdb|tmdb"
                temp="${temp#*|}"                  # Remove year: "imdb|tmdb"
                file_imdb="${temp%%|*}"            # Get imdb (everything before |)
                file_tmdb="${temp#*|}"             # Get tmdb (everything after |)
                should_debug high && echo "[DEBUG] Found in temporary duplicate cache: IMDb=$file_imdb, TMDb=$file_tmdb" >&2
                echo -e "${DIM}    ✓ Using cached duplicate metadata: IMDb=$file_imdb, TMDb=$file_tmdb${NC}" >&2
            else
                should_debug high && echo "[DEBUG] Not in cache, starting online lookup" >&2
                # Use same comprehensive TMDb search strategy as non-duplicates
                
                # Parse filename to check for IMDb ID
                local parsed_imdb_from_file=""
                parse_filename "$file_path"
                [[ -n "$PARSED_IMDB" ]] && parsed_imdb_from_file="$PARSED_IMDB"
                
                # Also parse parent folder for fallback
                local parent_folder=$(dirname "$file_path")
                parse_filename "$parent_folder" "folder"
                local folder_title="$PARSED_TITLE"
                local folder_year="$PARSED_YEAR"
                
                local lookup_title="$title"
                local search_year="$year"
                
                # Check if TMDb API key is available
                if [[ -n "$TMDB_API_KEY" ]]; then
                    # Step 1a: Try TMDb search by title/year (primary method)
                    should_debug high && echo "[DEBUG] Step 1a: TMDb title/year search with '$title'" >&2
                    local tmdb_details=$(search_tmdb "$lookup_title" "$search_year" "")
                    if [[ -n "$tmdb_details" ]]; then
                        file_tmdb=$(extract_tmdb_id_from_details "$tmdb_details")
                        should_debug high && echo "[DEBUG] Step 1a result: TMDB='$file_tmdb'" >&2
                    fi
                    
                    # Step 1b: If no match with filename title, try folder title
                    if [[ -z "$tmdb_details" && -n "$folder_title" && "$folder_title" != "$title" ]]; then
                        should_debug high && echo "[DEBUG] Step 1b: Trying folder title '$folder_title'" >&2
                        tmdb_details=$(search_tmdb "$folder_title" "$folder_year" "")
                        if [[ -n "$tmdb_details" ]]; then
                            file_tmdb=$(extract_tmdb_id_from_details "$tmdb_details")
                            lookup_title="$folder_title"
                            [[ -n "$folder_year" ]] && search_year="$folder_year"
                            should_debug high && echo "[DEBUG] Step 1b result: TMDB='$file_tmdb' (using folder title)" >&2
                        fi
                    fi
                    
                    # Step 2: If no TMDb found but have parsed IMDb, use /find endpoint
                    if [[ -z "$tmdb_details" && -n "$parsed_imdb_from_file" ]]; then
                        should_debug high && echo "[DEBUG] Step 2: Using /find endpoint with parsed IMDb" >&2
                        tmdb_details=$(search_tmdb "$lookup_title" "$search_year" "$parsed_imdb_from_file")
                        if [[ -n "$tmdb_details" ]]; then
                            file_tmdb=$(extract_tmdb_id_from_details "$tmdb_details")
                            should_debug high && echo "[DEBUG] Step 2 result: TMDB='$file_tmdb'" >&2
                        fi
                    fi
                    
                    # Step 3: If TMDb found, extract IMDb from details
                    if [[ -n "$tmdb_details" ]]; then
                        should_debug high && echo "[DEBUG] Step 3: Extracting IMDb from TMDb details" >&2
                        file_imdb=$(extract_imdb_from_details "$tmdb_details")
                        should_debug high && echo "[DEBUG] Step 3 result: IMDB='$file_imdb'" >&2
                    fi
                else
                    should_debug high && echo "[DEBUG] TMDb API key not configured - skipping TMDb search" >&2
                fi
                
                # Step 4: If parsed IMDb available and not yet used, use it
                if [[ -z "$file_imdb" && -n "$parsed_imdb_from_file" ]]; then
                    should_debug high && echo "[DEBUG] Step 4: Using parsed IMDb from filename" >&2
                    file_imdb="$parsed_imdb_from_file"
                    should_debug high && echo "[DEBUG] Step 4 result: IMDB='$file_imdb'" >&2
                    # Get TMDb using the parsed IMDb ID
                    if [[ -z "$file_tmdb" && -n "$TMDB_API_KEY" ]]; then
                        local tmdb_details=$(search_tmdb "$lookup_title" "$search_year" "$file_imdb")
                        file_tmdb=$(extract_tmdb_id_from_details "$tmdb_details")
                        should_debug high && echo "[DEBUG] Step 4b: Got TMDb from parsed IMDb: TMDB='$file_tmdb'" >&2
                    fi
                fi
                
                # Step 5: If still no IMDb/TMDb, try TMDb runtime matching from search results
                if [[ -z "$file_imdb" && -z "$file_tmdb" && -n "$TMDB_API_KEY" ]]; then
                    should_debug high && echo "[DEBUG] Step 5: TMDb search with runtime matching" >&2
                    
                    # Get file runtime for comparison
                    local file_runtime=""
                    if [[ -f "$file_path" ]]; then
                        file_runtime=$(get_video_runtime "$file_path" 2>/dev/null | grep -oE '[0-9]+' || echo "")
                        [[ -n "$file_runtime" ]] && should_debug high && echo "[DEBUG] File runtime: ${file_runtime} minutes" >&2
                    fi
                    
                    # Get all search results from TMDb
                    local encoded_title=$(url_encode "$lookup_title")
                    local search_url="${TMDB_API_BASE}/search/movie?api_key=${TMDB_API_KEY}&query=${encoded_title}"
                    api_delay
                    local search_result=$(curl -s --connect-timeout 10 --max-time 30 "$search_url" 2>/dev/null)
                    
                    if [[ -n "$search_result" && -n "$file_runtime" ]]; then
                        # Try to find best runtime match
                        local best_match=$(echo "$search_result" | python3 -c "
import sys, json
try:
    data = json.load(sys.stdin)
    target_runtime = $file_runtime
    best_id = None
    min_diff = 999999
    
    for movie in data.get('results', []):
        movie_id = movie.get('id')
        if movie_id:
            # Get full details to check runtime
            import urllib.request
            url = 'https://api.themoviedb.org/3/movie/{}?api_key=$TMDB_API_KEY'.format(movie_id)
            try:
                with urllib.request.urlopen(url, timeout=10) as response:
                    details = json.load(response)
                    runtime = details.get('runtime', 0)
                    if runtime and runtime > 0:
                        diff = abs(runtime - target_runtime)
                        if diff < min_diff:
                            min_diff = diff
                            best_id = movie_id
            except:
                pass
    
    if best_id and min_diff <= 15:  # Within 15 minutes
        print(best_id)
except:
    pass
" 2>/dev/null)
                        
                        if [[ -n "$best_match" ]]; then
                            file_tmdb="$best_match"
                            file_imdb=$(get_imdb_from_tmdb "$file_tmdb")
                            should_debug high && echo "[DEBUG] Step 5 runtime match: TMDB='$file_tmdb' IMDB='$file_imdb'" >&2
                        fi
                    fi
                fi
                
                # Step 6: If still no IMDb, try direct IMDb search with runtime fallback
                if [[ -z "$file_imdb" ]]; then
                    should_debug high && echo "[DEBUG] Step 6: Direct IMDb search with runtime fallback (non-interactive)" >&2
                    
                    # COMMENTED OUT: Interactive IMDb search during duplicate detection
                    # (kept for reference - was removed to avoid disruptive prompts)
                    #file_imdb=$(search_imdb_with_runtime "$lookup_title" "$search_year" "$file_path")
                    #should_debug high && echo "[DEBUG] Step 6a result (runtime): IMDB='$file_imdb'" >&2
                    #if [[ -z "$file_imdb" ]]; then
                    #    should_debug high && echo "[DEBUG] Step 6b: Regular IMDb search" >&2
                    #    file_imdb=$(search_imdb "$lookup_title" "$search_year")
                    #    should_debug high && echo "[DEBUG] Step 6b result: IMDB='$file_imdb'" >&2
                    #fi
                    
                    # Non-interactive fallback: Just skip if not found automatically
                    should_debug high && echo "[DEBUG] Step 6: Skipping interactive IMDb search during duplicate detection" >&2
                    echo -e "${YELLOW}    ⚠ Could not auto-match IMDb ID for this file${NC}" >&2
                    echo -e "${DIM}    (Will look up metadata again if this file is selected)${NC}" >&2
                    
                    # If we got IMDb but still no TMDb and have API key, use /find endpoint
                    if [[ -n "$file_imdb" && -z "$file_tmdb" && -n "$TMDB_API_KEY" ]]; then
                        should_debug high && echo "[DEBUG] Step 6c: Using /find endpoint with IMDb from search" >&2
                        file_tmdb=$(search_tmdb "$lookup_title" "$search_year" "$file_imdb")
                        should_debug high && echo "[DEBUG] Step 6c result: TMDB='$file_tmdb'" >&2
                    fi
                fi
                
                # Step 7: Skip IMDb autocomplete during duplicate detection
                # Interactive prompts would disrupt the duplicate selection flow
                # If metadata can't be found automatically, it will be looked up again
                # when the selected file is actually processed
                
                # COMMENTED OUT: Interactive autocomplete during duplicate detection
                # (kept for reference - was removed to avoid disruptive prompts)
                #if [[ -z "$file_imdb" ]]; then
                #    should_debug high && echo "[DEBUG] Step 7: IMDb autocomplete search (final fallback)" >&2
                #    echo -e "${YELLOW}    ⚠ Could not find IMDb ID using automatic search${NC}" >&2
                #    echo -e "${CYAN}    Trying IMDb autocomplete as final fallback...${NC}" >&2
                #    
                #    file_imdb=$(imdb_autocomplete_search "$lookup_title" "$search_year" || true)
                #    
                #    if [[ -n "$file_imdb" ]]; then
                #        should_debug high && echo "[DEBUG] Step 7 result (autocomplete): IMDB='$file_imdb'" >&2
                #        echo -e "${GREEN}    ✓ Found via IMDb autocomplete: $file_imdb${NC}" >&2
                #        
                #        # Get TMDb using the autocomplete IMDb ID
                #        if [[ -z "$file_tmdb" && -n "$TMDB_API_KEY" ]]; then
                #            file_tmdb=$(search_tmdb "$lookup_title" "$search_year" "$file_imdb")
                #            should_debug high && echo "[DEBUG] Step 7b: Got TMDb from autocomplete IMDb: TMDB='$file_tmdb'" >&2
                #        fi
                #    else
                #        should_debug high && echo "[DEBUG] Step 7 failed: autocomplete returned nothing" >&2
                #        echo -e "${RED}    ✗ IMDb autocomplete also failed${NC}" >&2
                #    fi
                #fi
                
                if [[ -z "$file_imdb" ]]; then
                    should_debug high && echo "[DEBUG] Step 7: Skipping IMDb autocomplete during duplicate detection" >&2
                    echo -e "${YELLOW}    ⚠ Could not auto-match IMDb ID for this file${NC}" >&2
                    echo -e "${DIM}    (Will look up metadata again if this file is selected)${NC}" >&2
                fi

                
                should_debug high && echo "[DEBUG] Final results: IMDB='$file_imdb' TMDB='$file_tmdb'" >&2
                
                # Save to temporary duplicate cache file for reuse within this duplicate group
                if [[ -n "$file_imdb" || -n "$file_tmdb" ]]; then
                    echo "${cache_key}|${file_imdb}|${file_tmdb}" >> "$temp_dup_cache"
                    should_debug high && echo "[DEBUG] Saved to temporary duplicate cache for reuse: '$cache_key' -> IMDb=$file_imdb, TMDb=$file_tmdb" >&2
                fi
                
                # Don't save to cache yet - only save when file is actually selected and processed
                # The cache will be saved during process_file() for selected duplicates
                should_debug high && echo "[DEBUG] Not saving to cache during duplicate selection - will save only for selected files" >&2
                
                echo -e "${DIM}    → Matched to IMDb: ${file_imdb}, TMDb: ${file_tmdb}${NC}" >&2
            fi
            
            file_imdb_ids+=("$file_imdb")
            
            # Track unique IMDb IDs
            local is_unique=1
            for uid in "${unique_imdb_ids[@]}"; do
                if [[ "$uid" == "$file_imdb" ]]; then
                    is_unique=0
                    break
                fi
            done
            [[ $is_unique -eq 1 ]] && unique_imdb_ids+=("$file_imdb")
        done
        
        # Rebuild file_array with IMDb IDs included for later reuse
        local -a enriched_file_array=()
        local enrich_idx=0
        for file_info in "${file_array[@]}"; do
            local this_imdb="${file_imdb_ids[$enrich_idx]}"
            enriched_file_array+=("${file_info}|${this_imdb}")
            ((enrich_idx++))
        done
        
        # Update group_data with enriched file info
        group_data[$group_idx]="${title}|${year}||$(IFS='::'; echo "${enriched_file_array[*]}")"
        
        # Check if all files got the SAME IMDb ID but have different runtimes
        # This might indicate different movies that IMDb search couldn't distinguish
        if [[ ${#unique_imdb_ids[@]} -eq 1 && ${#file_array[@]} -gt 1 ]]; then
            # Extract runtimes from files
            local -a file_runtimes=()
            for file_info in "${file_array[@]}"; do
                local fruntime="${file_info##*|}"
                file_runtimes+=("$fruntime")
            done
            
            # Check if runtimes are actually different
            local first_runtime="${file_runtimes[0]}"
            local has_different_runtimes=0
            for frt in "${file_runtimes[@]}"; do
                if [[ "$frt" != "$first_runtime" && "$frt" != "unknown" && "$first_runtime" != "unknown" ]]; then
                    local diff=$((first_runtime - frt))
                    diff=${diff#-}
                    if [[ $diff -gt 2 ]]; then  # More than 2 min difference
                        has_different_runtimes=1
                        break
                    fi
                fi
            done
            
            # If different runtimes but same IMDb ID, warn user
            if [[ $has_different_runtimes -eq 1 ]]; then
                echo "" >&2
                echo -e "${YELLOW}⚠ NOTE: All files matched to IMDb ${unique_imdb_ids[0]}, but have different runtimes.${NC}" >&2
                echo -e "${YELLOW}These might be:${NC}" >&2
                echo -e "${YELLOW}  - Same movie, different cuts (theatrical vs extended)${NC}" >&2
                echo -e "${YELLOW}  - Different movies with same name that IMDb search couldn't distinguish${NC}" >&2
                echo "" >&2
            fi
        fi
        
        # If multiple unique IMDb IDs found, these might be different movies!
        if [[ ${#unique_imdb_ids[@]} -gt 1 ]]; then
            echo "" >&2
            echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}" >&2
            echo -e "${YELLOW}⚠  WARNING: Multiple different movies detected with same title!${NC}" >&2
            echo -e "${CYAN}Please review ALL posters and runtimes below:${NC}" >&2
            echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}" >&2
            echo "" >&2
            
            # Show each unique movie with its poster
            local poster_idx=1
            for uid in "${unique_imdb_ids[@]}"; do
                if [[ -n "$uid" ]]; then
                    local uid_runtime=$(get_imdb_runtime "$uid")
                    echo "" >&2
                    echo -e "${GREEN}═══ OPTION ${poster_idx}: IMDb ${uid} ═══${NC}" >&2
                    echo -e "${BLUE}Runtime: ${uid_runtime} minutes${NC}" >&2
                    echo "" >&2
                    
                    local poster_url=$(get_imdb_poster "$uid")
                    if [[ -n "$poster_url" ]]; then
                        if show_poster "$uid" "$poster_url" 35 >&2; then
                            echo "" >&2
                        else
                            echo -e "${DIM}Poster URL: ${poster_url}${NC}" >&2
                            echo -e "${YELLOW}(Poster display failed - check cache: ~/.movie_simulator/posters/${uid}.jpg)${NC}" >&2
                        fi
                    else
                        echo -e "${YELLOW}(No poster available for this version)${NC}" >&2
                    fi
                    
                    echo -e "${GREEN}═══════════════════════════════════${NC}" >&2
                    echo "" >&2
                    ((poster_idx++))
                fi
            done
            
            echo -e "${YELLOW}⚠  These files have similar runtimes but may be DIFFERENT movies.${NC}" >&2
            echo -e "${CYAN}Review the posters above carefully before selecting versions.${NC}" >&2
            echo "" >&2
        else
            # Single movie - show poster once
            local main_imdb="${unique_imdb_ids[0]}"
            if [[ -n "$main_imdb" ]]; then
                echo -e "${DIM}  IMDb: ${main_imdb}${NC}" >&2
                local poster_url=$(get_imdb_poster "$main_imdb")
                if [[ -n "$poster_url" ]]; then
                    if show_poster "$main_imdb" "$poster_url" 30 >&2; then
                        echo "" >&2
                    else
                        echo -e "${DIM}  🎬 Poster: ${poster_url}${NC}" >&2
                    fi
                fi
            fi
        fi
        
        local file_idx=1
        local -a group_choices=()
        
        echo -e "${CYAN}Versions found:${NC}" >&2
        echo "" >&2
        
        for file_info in "${file_array[@]}"; do
            # Parse: file_path|size|runtime
            local file_path="${file_info%%|*}"
            local rest="${file_info#*|}"
            local file_size="${rest%%|*}"
            local file_runtime="${rest##*|}"
            
            # Get the IMDb ID for this specific file
            local this_imdb="${file_imdb_ids[$((file_idx-1))]}"
            
            # Format size using decimal (GB/MB) to match Finder
            local size_display
            if [[ $file_size -gt 1000000000 ]]; then
                size_display=$(awk "BEGIN {printf \"%.2f GB\", $file_size/1000000000}")
            elif [[ $file_size -gt 1000000 ]]; then
                size_display=$(awk "BEGIN {printf \"%.1f MB\", $file_size/1000000}")
            elif [[ $file_size -gt 1000 ]]; then
                size_display=$(awk "BEGIN {printf \"%.1f KB\", $file_size/1000}")
            else
                size_display="${file_size} bytes"
            fi
            
            # Add runtime and IMDb info
            local runtime_display=""
            if [[ "$file_runtime" != "unknown" && "$file_runtime" =~ ^[0-9]+$ ]]; then
                runtime_display=" [${file_runtime}min]"
            fi
            
            local imdb_display=""
            if [[ -n "$this_imdb" ]]; then
                imdb_display=" ${CYAN}[IMDb: ${this_imdb}]${NC}"
            fi
            
            if [[ $file_idx -eq 1 ]]; then
                echo -e "  ${GREEN}${file_idx})${NC} $size_display${runtime_display}${imdb_display} - $(basename "$file_path") ${GREEN}[largest]${NC}" >&2
            else
                echo -e "  ${DIM}${file_idx})${NC} $size_display${runtime_display}${imdb_display} - $(basename "$file_path")" >&2
            fi
            echo -e "     ${DIM}$file_path${NC}" >&2
            
            # Don't show individual posters - they were already shown at the top grouped by unique IMDb IDs
            
            group_choices+=("$file_path")
            ((file_idx++))
        done
        
        all_choices+=("${group_idx}|$(IFS='::'; echo "${group_choices[*]}")")
        echo "" >&2
        ((group_idx++))
    done
    
    echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}" >&2
    echo "" >&2
    
    # Ask what to do with unchosen duplicates
    stty echo 2>/dev/null
    echo -e "${CYAN}What should happen to unchosen duplicate folders?${NC}" >&2
    echo -e "  ${GREEN}1)${NC} Leave them in place (do nothing)" >&2
    echo -e "  ${GREEN}2)${NC} Move them to a duplicates folder" >&2
    echo "" >&2
    
    local move_unchosen=""
    local duplicates_folder=""
    while true; do
        echo -ne "${CYAN}Enter your choice [1-2]: ${NC}" >&2
        if ! read -r move_choice </dev/tty 2>/dev/null; then
            echo "" >&2
            echo -e "${YELLOW}Operation cancelled${NC}" >&2
            rm -f "$temp_file" "$temp_parsed" 2>/dev/null
            return 1
        fi
        
        case "$move_choice" in
            1)
                echo -e "${GREEN}  → Unchosen duplicates will be left in place${NC}" >&2
                move_unchosen="no"
                break
                ;;
            2)
                echo -e "${GREEN}  → Unchosen duplicates will be moved${NC}" >&2
                move_unchosen="yes"
                
                # Get cache name from CACHE_FILE to determine folder name
                local cache_display_name=""
                if [[ -n "$CACHE_FILE" ]]; then
                    # Extract cache name from file path
                    local cache_basename=$(basename "$CACHE_FILE" .txt)
                    # Remove "MOVIE " or "SHOWS " prefix and " CACHE" suffix
                    cache_display_name=$(echo "$cache_basename" | sed -E 's/^(MOVIE|SHOWS) //;s/ CACHE$//')
                fi
                
                # Determine base directory - parent of the source directory
                # Get first file -> movie folder -> source directory -> parent of source
                local first_file="${all_files[0]}"
                local first_movie_folder=$(dirname "$first_file")
                local source_directory=$(dirname "$first_movie_folder")
                local source_base=$(dirname "$source_directory")
                
                # Create folder name with cache name
                if [[ -n "$cache_display_name" ]]; then
                    duplicates_folder="$source_base/Duplicates ${cache_display_name}"
                else
                    duplicates_folder="$source_base/Duplicates"
                fi
                
                echo -e "${CYAN}  Duplicates will be moved to: ${duplicates_folder}${NC}" >&2
                break
                ;;
            *)
                echo -e "${RED}  Invalid choice. Please enter 1 or 2${NC}" >&2
                ;;
        esac
    done
    echo "" >&2
    
    # Ask for bulk processing choice
    echo -e "${CYAN}How would you like to handle duplicates?${NC}" >&2
    echo -e "  ${GREEN}1)${NC} Keep largest version for all (bulk)" >&2
    echo -e "  ${GREEN}2)${NC} Keep smallest version for all (bulk)" >&2
    echo -e "  ${GREEN}3)${NC} Skip all duplicates" >&2
    echo -e "  ${GREEN}4)${NC} Choose individually (interactive)" >&2
    echo "" >&2
    
    local bulk_choice=""
    while true; do
        echo -ne "${CYAN}Enter your choice [1-4]: ${NC}" >&2
        if ! read -r bulk_choice </dev/tty 2>/dev/null; then
            echo "" >&2
            echo -e "${YELLOW}Cannot read from terminal - processing all duplicates by default${NC}" >&2
            # Default: process all files when terminal input unavailable
            for file in "${all_files[@]}"; do
                selected_files+=("$file")
            done
            rm -f "$temp_file" "$temp_parsed" 2>/dev/null
            printf '%s\n' "${selected_files[@]}"
            return 0
        fi
        
        case "$bulk_choice" in
            1)
                # Keep largest for all
                echo -e "${GREEN}  → Keeping largest version for all duplicates${NC}" >&2
                for gdata in "${group_data[@]}"; do
                    local files_data="${gdata##*||}"
                    IFS='::' read -ra file_array <<< "$files_data"
                    if [[ ${#file_array[@]} -gt 0 ]]; then
                        local largest_file="${file_array[0]%%|*}"
                        selected_files+=("$largest_file")
                    fi
                done
                break
                ;;
            2)
                # Keep smallest for all
                echo -e "${GREEN}  → Keeping smallest version for all duplicates${NC}" >&2
                for gdata in "${group_data[@]}"; do
                    local files_data="${gdata##*||}"
                    IFS='::' read -ra file_array <<< "$files_data"
                    if [[ ${#file_array[@]} -gt 0 ]]; then
                        local smallest_file="${file_array[-1]%%|*}"
                        selected_files+=("$smallest_file")
                    fi
                done
                break
                ;;
            3)
                # Skip all duplicates
                echo -e "${YELLOW}  → Skipping all duplicates${NC}" >&2
                # selected_files remains empty
                break
                ;;
            4)
                # Interactive mode - continue to individual prompts
                echo -e "${CYAN}  → Interactive selection mode${NC}" >&2
                echo "" >&2
                bulk_choice="interactive"
                break
                ;;
            *)
                echo -e "${RED}  Invalid choice. Please enter 1, 2, 3, or 4${NC}" >&2
                ;;
        esac
    done
    echo "" >&2
    
    # Only do individual prompts if user chose interactive mode
    if [[ "$bulk_choice" == "interactive" ]]; then
        # Prompt for each group
    for choice_data in "${all_choices[@]}"; do
        local group_num="${choice_data%%|*}"
        local files="${choice_data#*|}"
        IFS='::' read -ra file_paths <<< "$files"
        local num_files=${#file_paths[@]}
        
        # Get movie name from group_data
        local gdata="${group_data[$group_num]}"
        local key="${gdata%%||*}"
        local title="${key%%|*}"
        local year="${key##*|}"
        local files_data="${gdata##*||}"
        
        # Show poster for this movie before displaying versions
        IFS='::' read -ra file_array_temp <<< "$files_data"
        if [[ ${#file_array_temp[@]} -gt 0 ]]; then
            local first_file_info="${file_array_temp[0]}"
            local this_imdb="${first_file_info##*|}"
            
            if [[ -n "$this_imdb" ]]; then
                local poster_url=$(get_imdb_poster "$this_imdb")
                if [[ -n "$poster_url" ]]; then
                    if show_poster "$this_imdb" "$poster_url" 30 >&2; then
                        echo "" >&2
                    fi
                fi
            fi
        fi
        
        # Re-display the versions for this group before prompting
        echo -e "${CYAN}Versions found for \"${title} (${year})\":${NC}" >&2
        echo "" >&2
        
        IFS='::' read -ra file_array <<< "$files_data"
        local display_idx=1
        for file_info in "${file_array[@]}"; do
            # Parse: file_path|size|runtime|imdb
            local file_path="${file_info%%|*}"
            local rest="${file_info#*|}"
            local file_size="${rest%%|*}"
            rest="${rest#*|}"
            local file_runtime="${rest%%|*}"
            local this_imdb="${rest##*|}"
            
            # Format size using decimal (GB/MB) to match Finder
            local size_display
            if [[ $file_size -gt 1000000000 ]]; then
                size_display=$(awk "BEGIN {printf \"%.2f GB\", $file_size/1000000000}")
            elif [[ $file_size -gt 1000000 ]]; then
                size_display=$(awk "BEGIN {printf \"%.1f MB\", $file_size/1000000}")
            elif [[ $file_size -gt 1000 ]]; then
                size_display=$(awk "BEGIN {printf \"%.1f KB\", $file_size/1000}")
            else
                size_display="${file_size} bytes"
            fi
            
            # Add runtime and IMDb info
            local runtime_display=""
            if [[ "$file_runtime" != "unknown" && "$file_runtime" =~ ^[0-9]+$ ]]; then
                runtime_display=" [${file_runtime}min]"
            fi
            
            local imdb_display=""
            if [[ -n "$this_imdb" ]]; then
                imdb_display=" ${CYAN}[IMDb: ${this_imdb}]${NC}"
            fi
            
            if [[ $display_idx -eq 1 ]]; then
                echo -e "  ${GREEN}${display_idx})${NC} $size_display${runtime_display}${imdb_display} - $(basename "$file_path") ${GREEN}[largest]${NC}" >&2
            else
                echo -e "  ${DIM}${display_idx})${NC} $size_display${runtime_display}${imdb_display} - $(basename "$file_path")" >&2
            fi
            echo -e "     ${DIM}$file_path${NC}" >&2
            
            ((display_idx++))
        done
        echo "" >&2
        
        local user_cancelled=0
        while true; do
            echo -ne "${CYAN}For \"${title} (${year})\", keep which version? [1-${num_files}/all/skip] (or multiple: \"1 2 3\"): ${NC}" >&2
            if ! read -r selection </dev/tty 2>/dev/null; then
                echo -e "\n${YELLOW}Selection cancelled, keeping all versions to avoid moving them${NC}" >&2
                user_cancelled=1
                # Keep all versions when cancelled to prevent moving them
                for fp in "${file_paths[@]}"; do
                    selected_files+=("$fp")
                done
                break
            fi
            
            case "$selection" in
                all|ALL|a|A)
                    # Keep all versions of this movie
                    for fp in "${file_paths[@]}"; do
                        selected_files+=("$fp")
                    done
                    echo -e "${GREEN}  → Keeping all ${num_files} version(s)${NC}" >&2
                    break
                    ;;
                skip|SKIP|s|S|n|N)
                    # Skip all versions of this movie - don't add to selected_files
                    echo -e "${YELLOW}  → Skipping all versions (will not be processed)${NC}" >&2
                    # Don't add any files to selected_files array
                    break
                    ;;
                *[0-9]*)
                    # Support multiple selections: "1 2 3" or "1,2,3" or "1 3"
                    local -a selections=()
                    local valid_all=true
                    
                    # Parse space-separated or comma-separated numbers
                    local cleaned_selection=$(echo "$selection" | tr ',' ' ')
                    for num in $cleaned_selection; do
                        # Check if it's a valid number in range
                        if [[ "$num" =~ ^[0-9]+$ ]] && [[ $num -ge 1 && $num -le $num_files ]]; then
                            selections+=("$num")
                        else
                            echo -e "${RED}  Invalid number: $num (must be 1-${num_files})${NC}" >&2
                            valid_all=false
                            break
                        fi
                    done
                    
                    if [[ "$valid_all" == "true" && ${#selections[@]} -gt 0 ]]; then
                        # Add selected files
                        for num in "${selections[@]}"; do
                            local selected_file="${file_paths[$((num-1))]}"
                            selected_files+=("$selected_file")
                            echo -e "${GREEN}  → Keeping version $num: $(basename "$selected_file")${NC}" >&2
                        done
                        break
                    elif [[ ${#selections[@]} -eq 0 ]]; then
                        echo -e "${RED}  Invalid choice. Please enter numbers (1-${num_files}), 'all', or 'skip'${NC}" >&2
                    fi
                    ;;
                "")
                    # Default: keep largest (first one)
                    selected_files+=("${file_paths[0]}")
                    echo -e "${GREEN}  → Keeping largest version (default)${NC}" >&2
                    break
                    ;;
                *)
                    echo -e "${RED}  Invalid choice. Please enter numbers (1-${num_files}), 'all', or 'skip'${NC}" >&2
                    ;;
            esac
        done
        echo "" >&2
    done
    fi  # End of interactive mode
    
    # Build final list: NON-DUPLICATES FIRST, then selected duplicates
    local -a final_files=()
    local -a non_duplicate_files=()
    
    # First pass: collect non-duplicate files
    for file in "${all_files[@]}"; do
        # Check if file is in temp_parsed (was successfully parsed)
        local cached=$(awk -F'|' -v f="$file" '$1 == f {print; exit}' "$temp_parsed" 2>/dev/null)
        
        if [[ -n "$cached" ]]; then
            # Parse: file|title|year|runtime
            local file_info="${cached#*|}"
            local title="${file_info%%|*}"
            local rest="${file_info#*|}"
            local year="${rest%%|*}"
            local runtime="${rest##*|}"
            
            local is_duplicate=0
            
            # Check if this file's title+year matches any duplicate group (normalized comparison)
            local title_normalized=$(normalize_title_for_comparison "$title")
            for ukey in "${unique_keys[@]}"; do
                local ukey_title="${ukey%%|*}"
                local ukey_year="${ukey##*|}"
                local ukey_title_normalized=$(normalize_title_for_comparison "$ukey_title")
                
                if [[ "$title_normalized" == "$ukey_title_normalized" && "$year" == "$ukey_year" ]]; then
                    is_duplicate=1
                    break
                fi
            done
            
            if [[ $is_duplicate -eq 0 ]]; then
                non_duplicate_files+=("$file")
            fi
        else
            # Wasn't parsed (couldn't extract title/year), include it
            non_duplicate_files+=("$file")
        fi
    done
    
    # Move unchosen duplicates if requested (do this BEFORE building final_files)
    local -a moved_folders=()
    if [[ "$move_unchosen" == "yes" ]]; then
        echo "" >&2
        echo -e "${CYAN}Moving unchosen duplicate folders...${NC}" >&2
        
        # Create duplicates folder if it doesn't exist
        if [[ ! -d "$duplicates_folder" ]]; then
            mkdir -p "$duplicates_folder" 2>/dev/null
            if [[ $? -eq 0 ]]; then
                echo -e "${GREEN}  Created: ${duplicates_folder}${NC}" >&2
            else
                echo -e "${RED}  Failed to create duplicates folder${NC}" >&2
                move_unchosen="no"
            fi
        fi
        
        if [[ "$move_unchosen" == "yes" ]]; then
            # Get all duplicate files (not selected)
            local -a files_to_move=()
            for gdata in "${group_data[@]}"; do
                local files_data="${gdata##*||}"
                IFS='::' read -ra file_array <<< "$files_data"
                
                for file_info in "${file_array[@]}"; do
                    local file_path="${file_info%%|*}"
                    
                    # Check if this file was selected
                    local was_selected=0
                    for sel in "${selected_files[@]}"; do
                        if [[ "$sel" == "$file_path" ]]; then
                            was_selected=1
                            break
                        fi
                    done
                    
                    # If not selected, add to move list
                    if [[ $was_selected -eq 0 ]]; then
                        files_to_move+=("$file_path")
                    fi
                done
            done
            
            # Get unique folders to move (avoid duplicates)
            local -a folders_to_move=()
            local -a seen_folders=()
            for file_path in "${files_to_move[@]}"; do
                local movie_folder=$(dirname "$file_path")
                
                # Check if we've already added this folder
                local already_added=0
                for seen in "${seen_folders[@]}"; do
                    if [[ "$seen" == "$movie_folder" ]]; then
                        already_added=1
                        break
                    fi
                done
                
                if [[ $already_added -eq 0 ]]; then
                    folders_to_move+=("$movie_folder")
                    seen_folders+=("$movie_folder")
                fi
            done
            
            # Move the folders
            local moved_count=0
            local failed_count=0
            for movie_folder in "${folders_to_move[@]}"; do
                local folder_name=$(basename "$movie_folder")
                local dest_folder="$duplicates_folder/$folder_name"
                
                # Move the entire folder
                if [[ -d "$movie_folder" ]]; then
                    if mv "$movie_folder" "$dest_folder" 2>/dev/null; then
                        echo -e "${GREEN}  ✓ Moved: ${folder_name}${NC}" >&2
                        ((moved_count++))
                        # Track the folder path so we can remove files from it later
                        moved_folders+=("$movie_folder")
                    else
                        echo -e "${RED}  ✗ Failed to move: ${folder_name}${NC}" >&2
                        ((failed_count++))
                    fi
                fi
            done
            
            echo "" >&2
            echo -e "${CYAN}Move Summary:${NC}" >&2
            echo -e "  ${GREEN}Moved: ${moved_count}${NC}" >&2
            [[ $failed_count -gt 0 ]] && echo -e "  ${RED}Failed: ${failed_count}${NC}" >&2
        fi
    fi
    
    # Remove moved files from both selected_files and non_duplicate_files lists
    if [[ ${#moved_folders[@]} -gt 0 ]]; then
        # Filter selected_files
        local -a filtered_selected=()
        for sel_file in "${selected_files[@]}"; do
            local sel_folder=$(dirname "$sel_file")
            local should_keep=1
            
            # Check if this file's folder was moved
            for moved_folder in "${moved_folders[@]}"; do
                if [[ "$sel_folder" == "$moved_folder" ]]; then
                    should_keep=0
                    break
                fi
            done
            
            # Only keep files whose folders weren't moved
            if [[ $should_keep -eq 1 ]]; then
                filtered_selected+=("$sel_file")
            fi
        done
        
        selected_files=("${filtered_selected[@]}")
        
        # Filter non_duplicate_files
        local -a filtered_non_dups=()
        for non_dup_file in "${non_duplicate_files[@]}"; do
            local non_dup_folder=$(dirname "$non_dup_file")
            local should_keep=1
            
            # Check if this file's folder was moved
            for moved_folder in "${moved_folders[@]}"; do
                if [[ "$non_dup_folder" == "$moved_folder" ]]; then
                    should_keep=0
                    break
                fi
            done
            
            # Only keep files whose folders weren't moved
            if [[ $should_keep -eq 1 ]]; then
                filtered_non_dups+=("$non_dup_file")
            fi
        done
        
        non_duplicate_files=("${filtered_non_dups[@]}")
    fi
    
    # Now build final_files after moves and filtering
    local -a final_files=()
    
    # Add non-duplicates first
    final_files=("${non_duplicate_files[@]}")
    
    # Then add selected duplicates at the end (already filtered)
    final_files+=("${selected_files[@]}")
    
    rm -f "$temp_file" "$temp_parsed" "$temp_dup_cache"
    
    # Show processing order summary
    if [[ ${#non_duplicate_files[@]} -gt 0 && ${#selected_files[@]} -gt 0 ]]; then
        echo "" >&2
        echo -e "${CYAN}Processing order:${NC}" >&2
        echo -e "  ${GREEN}1. Non-duplicates: ${#non_duplicate_files[@]} file(s)${NC}" >&2
        echo -e "  ${YELLOW}2. Selected duplicates: ${#selected_files[@]} file(s)${NC}" >&2
    fi
    
    printf '%s\n' "${final_files[@]}"
    
    # Re-enable errexit
    set -e
}

# MediaInfo tool selection with arrow key interface
select_mediainfo_tool() {
    local tool_file="${CACHE_DIR}/mediainfo_tool.txt"
    
    # Tool options
    local -a tool_opts=(
        "mediainfo|MediaInfo CLI (Most Accurate)|Best codec/HDR detection (DTS-HD MA, Dolby Vision, HDR10+)|Requires installation: brew install mediainfo|Slower but most detailed metadata"
        "ffprobe|FFprobe (Fast & Reliable)|Good basic codec/resolution detection|Always available with ffmpeg|Faster but less detailed metadata"
        "off|Off (Filename Only)|Uses quality/codec tags from filename only|Fastest - no file scanning|May miss actual video properties"
    )
    
    # Check for saved preference
    local saved_tool="mediainfo"
    if [[ -f "$tool_file" ]]; then
        saved_tool=$(cat "$tool_file")
    fi
    
    # Find saved index
    local saved_idx=0
    for i in "${!tool_opts[@]}"; do
        local tool="${tool_opts[$i]%%|*}"
        if [[ "$tool" == "$saved_tool" ]]; then
            saved_idx=$i
            break
        fi
    done
    
    local selected_idx=$saved_idx
    
    # Timer for flashing instruction
    local flash_start=$SECONDS
    
    # Hide cursor
    tput civis 2>/dev/null
    
    while true; do
        # Clear screen and move to top
        clear
        
        echo ""
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${CYAN}MEDIAINFO TOOL SELECTION${NC}"
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
        # Flash instruction for 5 seconds
        if [[ $((SECONDS - flash_start)) -lt 5 ]]; then
            echo -e "${YELLOW}\033[5mUse ↑/↓ arrow keys to navigate, Enter to select, 'b' to go back\033[25m${NC}"
        else
            echo -e "${YELLOW}Use ↑/↓ arrow keys to navigate, Enter to select, 'b' to go back${NC}"
        fi
        echo ""
        echo -e "${DIM}Extract video metadata from files for accurate codec/resolution/HDR info${NC}"
        echo ""
        
        # Display options
        for i in "${!tool_opts[@]}"; do
            local tool="${tool_opts[$i]%%|*}"
            local rest="${tool_opts[$i]#*|}"
            local title="${rest%%|*}"
            local desc="${rest#*|}"
            
            if [[ $i -eq $selected_idx ]]; then
                echo -e "  ${GREEN}► [✓] $title${NC}"
                # Show description lines for selected item
                while IFS='|' read -r line; do
                    [[ -n "$line" ]] && echo -e "        ${DIM}• $line${NC}"
                done <<< "${desc//|/$'\n'}"
            else
                echo -e "  ${DIM}  [ ] $title${NC}"
            fi
            echo ""
        done
        
        echo -e "${DIM}Press Enter to confirm selection, 'b' to go back${NC}"
        
        # Read key input
        read -rsn1 key 2>/dev/null
        
        # Check if it's an escape sequence (arrow keys)
        if [[ "$key" == $'\x1b' ]]; then
            read -rsn2 -t 1 key 2>/dev/null
            case "$key" in
                '[A'|'OA') # Up arrow
                    ((selected_idx--))
                    if [[ $selected_idx -lt 0 ]]; then
                        selected_idx=$((${#tool_opts[@]} - 1))
                    fi
                    ;;
                '[B'|'OB') # Down arrow
                    ((selected_idx++))
                    if [[ $selected_idx -ge ${#tool_opts[@]} ]]; then
                        selected_idx=0
                    fi
                    ;;
            esac
        elif [[ "$key" == "b" ]] || [[ "$key" == "B" ]]; then
            # Back key pressed
            tput cnorm 2>/dev/null
            clear
            return 1
        elif [[ "$key" == "" ]]; then
            # Enter key pressed
            tput cnorm 2>/dev/null
            clear
            
            local selected_tool="${tool_opts[$selected_idx]%%|*}"
            echo "$selected_tool" > "$tool_file"
            
            # Update global variable
            MEDIAINFO_TOOL="$selected_tool"
            
            clear
            echo ""
            print_success "MediaInfo tool set to: $selected_tool"
            echo ""
            
            # Check if selected tool is available
            if [[ "$selected_tool" == "mediainfo" ]]; then
                if ! command -v mediainfo &>/dev/null; then
                    print_warning "MediaInfo not found - will fall back to ffprobe if available"
                    echo -e "${DIM}To install: brew install mediainfo${NC}"
                    echo ""
                fi
            elif [[ "$selected_tool" == "ffprobe" ]]; then
                if ! command -v ffprobe &>/dev/null; then
                    print_warning "ffprobe not found - will fall back to filename parsing"
                    echo -e "${DIM}To install: brew install ffmpeg${NC}"
                    echo ""
                fi
            fi
            
            return 0
        fi
    done
}

# ═══════════════════════════════════════════════════════════════════════════════
# TV SHOW PROCESSING FUNCTIONS
# ═══════════════════════════════════════════════════════════════════════════════

# Process batch season folder (e.g., Legion.S02.WEBRip without episode markers)
process_season_batch() {
    local source_folder="$1"
    local auto_mode="$2"
    should_debug high && print_info "[DEBUG] process_season_batch: source_folder='$source_folder' auto_mode='$auto_mode'" >&2
    
    # Determine cache category based on TV_CACHE_FILE
    local cache_category="tv"
    case "$TV_CACHE_FILE" in
        *"ANIME"*) cache_category="anime" ;;
        *"CARTOONS"*) cache_category="cartoon" ;;
    esac
    should_debug high && print_info "[DEBUG] process_season_batch: cache_category='$cache_category'" >&2
    
    local folder_name=$(basename "$source_folder")
    should_debug high && print_info "[DEBUG] process_season_batch: folder_name='$folder_name'" >&2
    
    print_info "========================================="
    print_info "Processing Season Batch Folder"
    print_info "Video files inside don't have clear episode markers (e.g., S01E01, 1x01, Episode 01)"
    print_info "Classifying them as a Season Batch Folder"
    print_info "Compar(es)ing video runtimes to TMDb episode data for accurate matching..."
    print_info "========================================="
    echo ""
    
    # Parse folder name to extract series title, year, and season
    local series_title=""
    local season_num=""
    local series_year=""
    
    # Extract season number from folder name FIRST
    if [[ "$folder_name" =~ [Ss]([0-9]{1,2})[^Ee0-9] ]]; then
        season_num="${BASH_REMATCH[1]}"
        season_num=$((10#$season_num))  # Remove leading zeros
        should_debug high && print_info "[DEBUG] process_season_batch: Extracted season_num='$season_num' (pattern 1)" >&2
    elif [[ "$folder_name" =~ [Ss]eason[[:space:]]?([0-9]{1,2}) ]]; then
        season_num="${BASH_REMATCH[1]}"
        season_num=$((10#$season_num))
        should_debug high && print_info "[DEBUG] process_season_batch: Extracted season_num='$season_num' (pattern 2)" >&2
    fi
    
    # Use parse_series_folder_name() for consistent title/year extraction
    parse_series_folder_name "$folder_name"
    series_title="$FOLDER_SERIES_TITLE"
    series_year="$FOLDER_SERIES_YEAR"
    should_debug high && print_info "[DEBUG] process_season_batch: After parse_series_folder_name - title='$series_title' year='$series_year'" >&2
    
    # If folder name is just "Season X", look at parent folder for series name
    # Use -z to check for empty string after trimming whitespace
    local trimmed_title=$(echo "$series_title" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    if [[ -z "$trimmed_title" ]]; then
        local parent_folder=$(basename "$(dirname "$source_folder")")
        should_debug high && print_info "[DEBUG] process_season_batch: Folder has no title, checking parent: '$parent_folder'" >&2
        
        # Check if parent is an extras folder (Featurettes, etc.) - if so, skip to grandparent
        local lower_parent=$(echo "$parent_folder" | tr '[:upper:]' '[:lower:]')
        if [[ "$lower_parent" == "featurettes" ]] || \
           [[ "$lower_parent" == "extras" ]] || \
           [[ "$lower_parent" == "specials" ]] || \
           [[ "$lower_parent" == "bonus" ]]; then
            should_debug high && print_info "[DEBUG] process_season_batch: Parent is extras folder, skipping to grandparent" >&2
            local grandparent_folder=$(basename "$(dirname "$(dirname "$source_folder")")")
            parse_series_folder_name "$grandparent_folder"
            series_title="$FOLDER_SERIES_TITLE"
            series_year="$FOLDER_SERIES_YEAR"
            should_debug high && print_info "[DEBUG] process_season_batch: Using grandparent folder - title='$series_title' year='$series_year'" >&2
        # Skip container folder name (stored in SKIP_SOURCE_FOLDER) - use its name for series info
        elif [[ -n "$SKIP_SOURCE_FOLDER" && "$(dirname "$source_folder")" == "$SKIP_SOURCE_FOLDER" ]]; then
            # Parent is the container we're skipping, use container's name for series info
            parse_series_folder_name "$parent_folder"
            series_title="$FOLDER_SERIES_TITLE"
            series_year="$FOLDER_SERIES_YEAR"
            should_debug high && print_info "[DEBUG] process_season_batch: Using container folder name - title='$series_title' year='$series_year'" >&2
        else
            # Try parent folder
            parse_series_folder_name "$parent_folder"
            series_title="$FOLDER_SERIES_TITLE"
            series_year="$FOLDER_SERIES_YEAR"
            should_debug high && print_info "[DEBUG] process_season_batch: Using parent folder - title='$series_title' year='$series_year'" >&2
        fi
        
        # If still empty, try grandparent
        trimmed_title=$(echo "$series_title" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        if [[ -z "$trimmed_title" ]]; then
            local grandparent_folder=$(basename "$(dirname "$(dirname "$source_folder")")")
            should_debug high && print_info "[DEBUG] process_season_batch: Still no title, checking grandparent: '$grandparent_folder'" >&2
            parse_series_folder_name "$grandparent_folder"
            series_title="$FOLDER_SERIES_TITLE"
            series_year="$FOLDER_SERIES_YEAR"
            should_debug high && print_info "[DEBUG] process_season_batch: Using grandparent folder - title='$series_title' year='$series_year'" >&2
        fi
    fi
    
    print_info "Detected:"
    [[ -n "$series_title" ]] && print_success "Series: $series_title"
    [[ -n "$series_year" ]] && print_success "Year: $series_year"
    [[ -n "$season_num" ]] && print_success "Season: $season_num"
    echo ""
    
    # Get/confirm series info
    if [[ -z "$series_title" ]]; then
        if [[ "$auto_mode" == "y" ]]; then
            print_error "Cannot auto-process: series title not detected"
            return 1
        fi
        print_info "Series Title:"
        read -r series_title
    elif [[ "$auto_mode" != "y" ]]; then
        print_info "Series Title [$series_title]:"
        read -r input
        [[ -n "$input" ]] && series_title="$input"
    fi
    
    if [[ -z "$season_num" ]]; then
        if [[ "$auto_mode" == "y" ]]; then
            print_error "Cannot auto-process: season number not detected"
            return 1
        fi
        print_info "Season Number:"
        read -r season_num
    elif [[ "$auto_mode" != "y" ]]; then
        print_info "Season Number [$season_num]:"
        read -r input
        [[ -n "$input" ]] && season_num="$input"
    fi
    
    if [[ -z "$series_year" && "$auto_mode" != "y" ]]; then
        print_info "Series Year (optional):"
        read -r series_year
    fi
    
    # Search for TV show metadata
    local CACHED_TV_DATA=$(get_cached_tvshow "$series_title" "$series_year")
    local TV_IMDB TV_TMDB TV_TVDB
    
    if [[ -n "$CACHED_TV_DATA" ]]; then
        TV_IMDB=$(extract_from_tv_cache "$CACHED_TV_DATA" "imdb")
        TV_TMDB=$(extract_from_tv_cache "$CACHED_TV_DATA" "tmdb")
        TV_TVDB=$(extract_from_tv_cache "$CACHED_TV_DATA" "tvdb")
        # Extract year from cache if we don't have it
        if [[ -z "$series_year" ]]; then
            series_year=$(echo "$CACHED_TV_DATA" | cut -d'|' -f2)
        fi
        print_info "✓ Using cached TV metadata: TMDb=$TV_TMDB, Year=$series_year"
    else
        TV_TMDB=$(search_tmdb_tv "$series_title" "$series_year" "")
        
        if [[ -n "$TV_TMDB" ]]; then
            TV_IMDB=$(get_tv_imdb_from_tmdb "$TV_TMDB")
            TV_TVDB=$(get_tvdb_from_tmdb "$TV_TMDB")
            
            # Get year from TMDb if we don't have it
            if [[ -z "$series_year" ]]; then
                series_year=$(get_year_from_tmdb_tv "$TV_TMDB")
            fi
            
            save_tvshow_to_cache "$series_title" "$series_year" "$TV_IMDB" "$TV_TMDB" "$TV_TVDB"
        fi
    fi
    
    # Set TV_YEAR for folder naming
    TV_YEAR="$series_year"
    
    if [[ -z "$TV_TMDB" ]]; then
        print_error "Could not find TV show on TMDb"
        
        if [[ "$auto_mode" != "y" ]]; then
            print_info "TMDb ID (manual entry):"
            read -r TV_TMDB
        fi
        
        if [[ -z "$TV_TMDB" ]]; then
            return 1
        fi
    fi
    
    # Collect all video files in the folder (search recursively for season subfolders)
    local -a video_files=()
    while IFS= read -r -d '' file; do
        video_files+=("$file")
    done < <(find "$source_folder" -type f \( -iname "*.mkv" -o -iname "*.mp4" -o -iname "*.avi" -o -iname "*.m4v" \) -print0)
    
    # Filter out files with S## but no E## (mislabeled specials)
    local -a filtered_files=()
    for file in "${video_files[@]}"; do
        local basename_check=$(basename "$file")
        # Skip files that have S## but no E##
        if [[ "$basename_check" =~ [Ss][0-9]{1,2}[^Ee0-9] ]] && ! [[ "$basename_check" =~ [Ee][0-9] ]]; then
            should_debug low && echo "[DEBUG] Skipping file with S## but no E##: $(basename "$file")" >&2
            continue
        fi
        filtered_files+=("$file")
    done
    video_files=("${filtered_files[@]}")
    
    if [[ ${#video_files[@]} -eq 0 ]]; then
        print_error "No video files found in folder or subfolders"
        return 1
    fi
    
    # Sort files alphabetically
    IFS=$'\n' video_files=($(sort <<<"${video_files[*]}"))
    unset IFS
    
    print_success "Found ${#video_files[@]} video files"
    echo ""
    
    # Match files to episodes by runtime
    local matches=$(match_files_to_episodes_by_runtime "$TV_TMDB" "$season_num" "${video_files[@]}")
    
    if [[ -z "$matches" ]]; then
        print_error "Could not match any files to episodes"
        return 1
    fi
    
    # Parse quality and metadata from folder name
    parse_filename "$folder_name" "folder"
    
    # Extract MediaInfo from first video file (if enabled)
    MEDIAINFO_VIDEO_CODEC=""
    MEDIAINFO_AUDIO_CODEC=""
    MEDIAINFO_AUDIO_CHANNELS=""
    MEDIAINFO_HDR=""
    MEDIAINFO_RESOLUTION=""
    
    if [[ "$MEDIAINFO_TOOL" != "off" ]] && [[ ${#video_files[@]} -gt 0 ]]; then
        local first_file="${video_files[0]}"
        if get_mediainfo_from_file "$first_file"; then
            [[ -n "$MEDIAINFO_VIDEO_CODEC" ]] && PARSED_VIDEO_CODEC="$MEDIAINFO_VIDEO_CODEC"
            [[ -n "$MEDIAINFO_AUDIO_CODEC" ]] && PARSED_AUDIO_CODEC="$MEDIAINFO_AUDIO_CODEC"
            [[ -n "$MEDIAINFO_AUDIO_CHANNELS" ]] && PARSED_AUDIO_CHANNELS="$MEDIAINFO_AUDIO_CHANNELS"
            [[ -n "$MEDIAINFO_HDR" ]] && PARSED_HDR="$MEDIAINFO_HDR"
            
            if [[ -n "$MEDIAINFO_RESOLUTION" ]]; then
                if [[ -z "$PARSED_FULL_QUALITY" ]]; then
                    PARSED_FULL_QUALITY="$MEDIAINFO_RESOLUTION"
                elif [[ "$PARSED_FULL_QUALITY" =~ ^([^-]+)-[0-9]+p$ ]]; then
                    # Quality has source-resolution format, replace resolution
                    PARSED_FULL_QUALITY="${BASH_REMATCH[1]}-${MEDIAINFO_RESOLUTION}"
                elif [[ "$PARSED_FULL_QUALITY" =~ ^[0-9]+p$ ]]; then
                    # Quality is just resolution, replace it
                    PARSED_FULL_QUALITY="$MEDIAINFO_RESOLUTION"
                elif [[ ! "$PARSED_FULL_QUALITY" =~ [0-9]+p ]]; then
                    # Quality is just source, append resolution
                    PARSED_FULL_QUALITY="${PARSED_FULL_QUALITY}-${MEDIAINFO_RESOLUTION}"
                fi
            fi
        fi
    fi
    
    # Get official series title from TMDb API (use this instead of parsed filename)
    # Use file-based cache to avoid redundant API calls (works with parallel processing)
    if [[ -n "$TV_TMDB" ]]; then
        local canon_cache_file="${CACHE_DIR}/.canon_${TV_TMDB}.tmp"
        local cached_canon_title=""
        
        # Check file cache first
        if [[ -f "$canon_cache_file" ]]; then
            cached_canon_title=$(sed -n '1p' "$canon_cache_file" 2>/dev/null)
        fi
        
        if [[ -n "$cached_canon_title" ]]; then
            series_title="$cached_canon_title"
            print_info "Using cached official title: $series_title"
        else
            local tmdb_series_title=$(get_tmdb_tv_title "$TV_TMDB")
            if [[ -n "$tmdb_series_title" ]]; then
                series_title="$tmdb_series_title"
                print_info "Using official title from TMDb: $series_title"
                # Cache for other parallel processes
                printf '%s\n%s\n' "$series_title" "" > "$canon_cache_file" 2>/dev/null
            fi
        fi
        
        # Update main TV cache with canonical title if it differs from parsed title
        # This ensures special characters like & are preserved in the cache
        if [[ -n "$series_title" && -n "$TV_YEAR" && -n "$TV_IMDB" ]]; then
            local cache_line=$(grep "|${TV_IMDB}|" "$TV_CACHE_FILE" 2>/dev/null | head -1)
            if [[ -n "$cache_line" ]]; then
                local cached_title=$(echo "$cache_line" | cut -d'|' -f1)
                if [[ "$cached_title" != "$series_title" ]]; then
                    should_debug high && print_info "[DEBUG] Updating cache title from '$cached_title' to '$series_title'" >&2
                    # Remove old entry and add new one with canonical title
                    grep -v "|${TV_IMDB}|" "$TV_CACHE_FILE" > "${TV_CACHE_FILE}.tmp" 2>/dev/null
                    mv "${TV_CACHE_FILE}.tmp" "$TV_CACHE_FILE" 2>/dev/null
                    save_tvshow_to_cache "$series_title" "$TV_YEAR" "$TV_IMDB" "$TV_TMDB" "$TV_TVDB"
                fi
            fi
        fi
    fi
    
    print_info "Creating hardlinks with proper episode names..."
    echo ""
    
    local success_count=0
    local fail_count=0
    
    # Get episode cache file for saving episode titles
    local episode_cache_file=$(get_episode_cache_file "$series_title" "$TV_IMDB" "$cache_category")
    
    # Process each match
    while IFS='|' read -r file_path ep_num ep_title ep_runtime; do
        [[ -z "$file_path" ]] && continue
        
        local ext="${file_path##*.}"
        local clean_series=$(echo "$series_title" | sed 's/[:<>"|?*]//g' | sed 's/\//\-/g')
        # Remove any existing year from series title (with or without parentheses/brackets, with or without dashes)
        # Handles: "Title 2023", "Title (2023)", "Title - 2023", "Title - (2023)", etc.
        clean_series=$(echo "$clean_series" | sed -E 's/[[:space:]]*-?[[:space:]]*[\(\[]?[0-9]{4}(-[0-9]{4})?[\)\]]?[[:space:]]*$//' | sed 's/  */ /g' | sed 's/^ //;s/ $//')
        # Remove trailing dashes/separators after year removal
        clean_series=$(echo "$clean_series" | sed -E 's/[[:space:]]*[-—_]+[[:space:]]*$//')
        # Convert to title case (capitalize first letter of each word)
        clean_series=$(echo "$clean_series" | awk '{for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1)) tolower(substr($i,2))}1')
        # Strip bracketed release tags and torrent IDs from episode title
        ep_title=$(echo "$ep_title" | sed -E 's/[[:space:]]*-?\[([A-Za-z0-9]+)\]\[([A-Fa-f0-9]+)\][[:space:]]*$//')
        ep_title=$(echo "$ep_title" | sed -E 's/[[:space:]]*-?\[([A-Fa-f0-9]{6,})\][[:space:]]*$//')
        local clean_ep_title=$(echo "$ep_title" | sed 's/[:<>"|?*]//g' | sed 's/\//\-/g' | cut -c 1-90)
        # Convert episode title to title case
        clean_ep_title=$(echo "$clean_ep_title" | awk '{for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1)) tolower(substr($i,2))}1')
        
        # Build series folder
        local series_folder
        case "$TV_NAMING_FOLDER" in
            0) series_folder="${clean_series}${TV_YEAR:+ ($TV_YEAR)}" ;;
            1) series_folder="${clean_series}${TV_YEAR:+ ($TV_YEAR)} {imdb-${TV_IMDB}}" ;;
            2) series_folder="${clean_series}${TV_YEAR:+ ($TV_YEAR)} {tmdb-${TV_TMDB}}" ;;
            3) series_folder="${clean_series}${TV_YEAR:+ ($TV_YEAR)} {tvdb-${TV_TVDB}}" ;;
            4) series_folder="${clean_series}${TV_YEAR:+ ($TV_YEAR)} [imdb-${TV_IMDB}]" ;;
            5) series_folder="${clean_series}${TV_YEAR:+ ($TV_YEAR)} [tmdb-${TV_TMDB}]" ;;
            6) series_folder="${clean_series}${TV_YEAR:+ ($TV_YEAR)} [tvdb-${TV_TVDB}]" ;;
            7) series_folder="${clean_series}${TV_YEAR:+ ($TV_YEAR)} [tvdbid-${TV_TVDB}]" ;;
            8) series_folder="${clean_series}${TV_YEAR:+ ($TV_YEAR)} [imdb-${TV_IMDB}]" ;;
            9) series_folder="${clean_series}${TV_YEAR:+ ($TV_YEAR)} [tmdbid-${TV_TMDB}]" ;;
            *) series_folder="${clean_series}${TV_YEAR:+ ($TV_YEAR)}" ;;
        esac
        
        local season_folder="Season $(printf "%02d" $season_num)"
        local tv_folder="${DESTINATION}/${series_folder}/${season_folder}"
        
        # Build episode filename
        local ep_num_padded=$(printf "S%02dE%02d" $season_num $ep_num)
        local episode_filename="${clean_series}${TV_YEAR:+ ($TV_YEAR)} - ${ep_num_padded}"
        [[ -n "$clean_ep_title" ]] && episode_filename="${episode_filename} - ${clean_ep_title}"
        
        # Add quality tags from folder name
        [[ -n "$PARSED_CUSTOM_FORMAT" ]] && episode_filename="${episode_filename} [${PARSED_CUSTOM_FORMAT}]"
        [[ -n "$PARSED_FULL_QUALITY" ]] && episode_filename="${episode_filename} [${PARSED_FULL_QUALITY}]"
        [[ -n "$PARSED_AUDIO_CODEC" ]] && episode_filename="${episode_filename} [${PARSED_AUDIO_CODEC}${PARSED_AUDIO_CHANNELS:+ $PARSED_AUDIO_CHANNELS}]"
        [[ -n "$PARSED_HDR" ]] && episode_filename="${episode_filename} [${PARSED_HDR}]"
        [[ -n "$PARSED_VIDEO_CODEC" ]] && episode_filename="${episode_filename} [${PARSED_VIDEO_CODEC}]"
        [[ -n "$PARSED_RELEASE_GROUP" ]] && episode_filename="${episode_filename}-${PARSED_RELEASE_GROUP}"
        
        local dest_file="${tv_folder}/${episode_filename}.${ext}"
        
        # Create directory
        mkdir -p "$tv_folder"
        
        # Check if file already exists and is hardlinked
        if [[ -f "$dest_file" ]]; then
            local source_inode=$(stat -f "%i" "$file_path" 2>/dev/null || stat -c "%i" "$file_path" 2>/dev/null)
            local dest_inode=$(stat -f "%i" "$dest_file" 2>/dev/null || stat -c "%i" "$dest_file" 2>/dev/null)
            
            if [[ "$source_inode" == "$dest_inode" ]]; then
                print_warning "⚠ Already linked: E${ep_num} - $ep_title"
                ((success_count++))
                continue
            fi
        fi
        
        # Create hardlink, symlink, or copy (same logic as movies)
        if $USE_COPY; then
            if cp "$file_path" "$dest_file" 2>/dev/null; then
                print_success "✓ Copied: E${ep_num} - $ep_title"
                ((success_count++))
            else
                print_error "✗ Failed: E${ep_num} - $ep_title"
                ((fail_count++))
            fi
        elif $USE_SYMLINK; then
            if ln -s "$file_path" "$dest_file" 2>/dev/null; then
                print_success "✓ Symlinked: E${ep_num} - $ep_title"
                ((success_count++))
            else
                print_error "✗ Failed: E${ep_num} - $ep_title"
                ((fail_count++))
            fi
        else
            if ln "$file_path" "$dest_file" 2>/dev/null; then
                print_success "✓ Hardlinked: E${ep_num} - $ep_title"
                ((success_count++))
                # Save episode to cache
                save_episode_to_cache "$episode_cache_file" "$season_num" "$ep_num" "$ep_title" "" "$TV_IMDB" "$TV_TMDB" "$TV_TVDB"
            elif cp -p "$file_path" "$dest_file" 2>/dev/null; then
                print_warning "✓ Copied: E${ep_num} - $ep_title (different filesystem)"
                ((success_count++))
                # Save episode to cache
                save_episode_to_cache "$episode_cache_file" "$season_num" "$ep_num" "$ep_title" "" "$TV_IMDB" "$TV_TMDB" "$TV_TVDB"
            else
                print_error "✗ Failed: E${ep_num} - $ep_title"
                ((fail_count++))
            fi
        fi
    done <<< "$matches"
    
    echo ""
    print_info "Batch complete: $success_count successful, $fail_count failed"
    
    return 0
}

# Helper function to log skipped extras files (for statistics tracking)
log_skipped_extra() {
    local file="$1"
    local reason="$2"
    # Append to temp file for aggregation (thread-safe with >>)
    if [[ -n "$EXTRAS_SKIPPED_FILE" ]]; then
        echo "${file}|${reason}" >> "$EXTRAS_SKIPPED_FILE"
    fi
}

# Helper function to log processed extras files (for statistics tracking)
log_processed_extra() {
    local file="$1"
    # Append to temp file for aggregation (thread-safe with >>)
    if [[ -n "$EXTRAS_PROCESSED_FILE" ]]; then
        echo "$file" >> "$EXTRAS_PROCESSED_FILE"
    fi
}

# Process all extras for a TV series ONCE (before processing episodes)
# This eliminates redundant scanning and enables full parallel processing
process_series_extras() {
    local source_dir="$1"
    local series_folder="$2"
    local auto_mode="$3"
    
    # Check if extras processing is enabled
    if [[ "$HARDLINK_EXTRAS" != "true" ]] && [[ "$HARDLINK_EXTRAS" != "no-rename" ]] && [[ "$HARDLINK_EXTRAS" != "preserve" ]]; then
        return 0
    fi
    
    should_debug low && echo "[DEBUG] process_series_extras: Starting for series '$series_folder' in '$source_dir'" >&2
    
    echo "[DEBUG] Extras scan - source_dir: $source_dir"
    echo "[DEBUG] Extras scan - series_folder: $series_folder"
    echo "[DEBUG] Extras scan - HARDLINK_EXTRAS: $HARDLINK_EXTRAS"
    
    local extras_start_time=$SECONDS
    local extras_processed=0
    local extras_skipped=0
    
    # Arrays for extras folder types
    local -a extras_folders=("behind the scenes" "deleted scenes" "interviews" "scenes" "samples" "shorts" "featurettes" "featurette" "feaaturettes" "clips" "other" "extras" "trailers" "webisodes" "bonus")
    
    # Create temp file for tracking processed inodes (thread-safe)
    local PROCESSED_INODES_FILE=$(mktemp "${TMPDIR:-/tmp}/processed_inodes.XXXXXX")
    
    # Collect all extras files from the series folder (one scan instead of 125)
    local -a all_extras_files=()
    
    echo "[DEBUG] Searching for extras in: $source_dir"
    
    # 1. Find files in existing extras type folders - search deeper for nested season folders
    for folder_name in "${extras_folders[@]}"; do
        echo "[DEBUG] Searching for '$folder_name' folders..."
        local folder_count=0
        while IFS= read -r -d '' extras_file; do
            all_extras_files+=("$extras_file")
            ((folder_count++))
        done < <(find "$source_dir" -type d -iname "$folder_name" -exec find {} -type f \( -iname "*.mkv" -o -iname "*.mp4" -o -iname "*.avi" -o -iname "*.m4v" -o -iname "*.mov" -o -iname "*.vob" -o -iname "*.wmv" -o -iname "*.flv" -o -iname "*.webm" -o -iname "*.ts" -o -iname "*.m2ts" -o -iname "*.mpg" -o -iname "*.mpeg" \) -print0 \;)
        echo "[DEBUG]   Found $folder_count files in '$folder_name' folders"
    done
    
    # 2. Find loose extras files (by filename keywords) - also search generic "Extras" folders
    echo "[DEBUG] Searching for loose extras by filename keywords..."
    local loose_count=0
    while IFS= read -r -d '' extra_file; do
        all_extras_files+=("$extra_file")
        ((loose_count++))
    done < <(find "$source_dir" -type f \( -iname "*behind*the*scene*" -o -iname "*bts*" -o -iname "*making*of*" -o -iname "*deleted*scene*" -o -iname "*interview*" -o -iname "*featurette*" -o -iname "*trailer*" -o -iname "*bonus*" -o -iname "*sample*" -o -iname "*extended*" -o -iname "*alternate*" -o -iname "*unused*" -o -iname "*outtake*" -o -iname "*gag*reel*" \) \( -iname "*.mkv" -o -iname "*.mp4" -o -iname "*.avi" -o -iname "*.m4v" -o -iname "*.mov" -o -iname "*.vob" -o -iname "*.wmv" -o -iname "*.flv" -o -iname "*.webm" -o -iname "*.ts" -o -iname "*.m2ts" -o -iname "*.mpg" -o -iname "*.mpeg" \) -print0)
    echo "[DEBUG]   Found $loose_count loose extras files"
    
    # Remove duplicates from array (files found in both searches)
    # Use a simpler approach that works in both bash and when run from other shells
    local -a unique_extras=()
    local seen_inodes=""
    local duplicates_removed=0
    
    for extra_file in "${all_extras_files[@]}"; do
        local inode=$(stat -f "%i" "$extra_file" 2>/dev/null || stat -c "%i" "$extra_file" 2>/dev/null)
        if [[ ! " $seen_inodes " =~ " $inode " ]]; then
            seen_inodes="$seen_inodes $inode"
            unique_extras+=("$extra_file")
        else
            ((duplicates_removed++))
        fi
    done
    
    all_extras_files=("${unique_extras[@]}")
    
    local total_extras_found=${#all_extras_files[@]}
    
    echo "[DEBUG] Total extras files found: $total_extras_found (removed $duplicates_removed duplicates)"
    
    if [[ $total_extras_found -eq 0 ]]; then
        should_debug low && echo "[DEBUG] process_series_extras: No extras found for series '$series_folder'" >&2
        rm -f "$PROCESSED_INODES_FILE"
        return 0
    fi
    
    print_info "Found $total_extras_found extras file(s) for series '$series_folder'"
    echo "[INFO] Processing extras in parallel (${PARALLEL_JOBS:-4} concurrent jobs)..."
    
    # Export variables needed by background processes
    export DESTINATION
    export USE_COPY
    export USE_SYMLINK
    export EXTRAS_SKIPPED_FILE
    export EXTRAS_PROCESSED_FILE
    export PROCESSED_INODES_FILE
    
    # Function to process a single extra file (will be run in background)
    process_single_extra() {
        local extra_file="$1"
        local default_series_folder="$2"
        local source_dir="$3"
        
        local extra_basename=$(basename "$extra_file")
        local extra_lower=$(echo "$extra_basename" | tr '[:upper:]' '[:lower:]')
        local extra_parent=$(dirname "$extra_file")
        local extra_parent_name=$(basename "$extra_parent")
        
        # Get full path for better season/folder detection
        local extra_full_path="$extra_file"
        local extra_relative_path="${extra_file#$source_dir/}"
        
        should_debug low && echo "[DEBUG] Processing extra: $extra_basename" >&2
        should_debug low && echo "[DEBUG]   Full path: $extra_file" >&2
        should_debug low && echo "[DEBUG]   Relative path: $extra_relative_path" >&2
        
        # First, try to extract series title from source directory path
        # This is more reliable than filename parsing
        local extra_series_title=""
        local check_path="$extra_file"
        should_debug low && echo "[DEBUG]   Searching source path for series name..." >&2
        while [[ "$check_path" != "$source_dir" ]] && [[ "$check_path" != "/" ]]; do
            check_path=$(dirname "$check_path")
            local folder_name=$(basename "$check_path")
            
            should_debug low && echo "[DEBUG]     Checking: $folder_name" >&2
            
            # Match "Series Name (Year)" pattern
            if [[ "$folder_name" =~ ^(.+)[[:space:]]+\([0-9]{4}\) ]]; then
                extra_series_title="${BASH_REMATCH[1]}"
                extra_series_title="${extra_series_title## }"
                extra_series_title="${extra_series_title%% }"
                should_debug low && echo "[DEBUG]     MATCH! Parsed series title from source path: '$extra_series_title' (from folder: $folder_name)" >&2
                break
            fi
            
            # Stop if we've reached source_dir
            if [[ "$check_path" == "$source_dir" ]]; then
                should_debug low && echo "[DEBUG]     Reached source_dir, stopping search" >&2
                break
            fi
        done
        
        # Only try filename parsing if path didn't provide series name
        # AND filename has S## pattern (more reliable indicator)
        if [[ -z "$extra_series_title" ]]; then
            should_debug low && echo "[DEBUG]   No series from path, trying filename..." >&2
            if [[ "$extra_basename" =~ ^([^-]+)[[:space:]]*-[[:space:]]*[Ss][0-9]{1,2} ]]; then
                extra_series_title="${BASH_REMATCH[1]}"
                extra_series_title="${extra_series_title## }"
                extra_series_title="${extra_series_title%% }"
                should_debug low && echo "[DEBUG]   Parsed series title from filename (with S##): '$extra_series_title'" >&2
            fi
        fi
        
        # Determine which series folder to use
        local series_folder="$default_series_folder"
        if [[ -n "$extra_series_title" ]]; then
            # Search for matching series folder in destination
            should_debug low && echo "[DEBUG]   Searching destination for: '${extra_series_title}*'" >&2
            should_debug low && echo "[DEBUG]   Available folders in destination:" >&2
            should_debug low && find "$DESTINATION" -maxdepth 1 -type d 2>/dev/null | head -5 | while read f; do echo "[DEBUG]     $(basename "$f")" >&2; done
            
            # Try exact match with wildcard first
            local matching_folder=$(find "$DESTINATION" -maxdepth 1 -type d -iname "${extra_series_title}*" 2>/dev/null | head -1)
            
            # If no match, try matching just the base name (without country/region in parentheses)
            # e.g., "Shameless (US)" should match "Shameless (2011)"
            if [[ -z "$matching_folder" ]]; then
                # Extract text before the first opening parenthesis
                local base_title="${extra_series_title%% (*}"
                if [[ "$base_title" != "$extra_series_title" ]]; then
                    should_debug low && echo "[DEBUG]   No match, trying base title: '${base_title}*'" >&2
                    matching_folder=$(find "$DESTINATION" -maxdepth 1 -type d -iname "${base_title}*" 2>/dev/null | head -1)
                fi
            fi
            
            if [[ -n "$matching_folder" ]]; then
                series_folder=$(basename "$matching_folder")
                should_debug low && echo "[DEBUG]   Found matching series folder: '$series_folder'" >&2
            else
                echo "[WARNING] No matching destination folder found for series '$extra_series_title' - skipping extra: $extra_basename"
                should_debug low && echo "[DEBUG]   No matching folder found for '$extra_series_title' in destination" >&2
                should_debug low && echo "[DEBUG]   Tried pattern: ${extra_series_title}*" >&2
                log_skipped_extra "$extra_file" "no_matching_series"
                return 0  # Skip this extra - wrong series
            fi
        else
            # No series title detected - this might be from wrong series
            echo "[WARNING] Could not detect series for extra, using default folder - this may be incorrect: $extra_basename"
            should_debug low && echo "[DEBUG]   No series title found, using default: '$default_series_folder' (may be wrong!)" >&2
        fi
        
        # Skip if this is an episode file (has S##E## without extras keywords)
        # BUT: Check full path first - if file is IN an extras folder, keep it even if named like episode
        # Pattern handles plurals: "scene/scenes", "reel/reels", etc.
        local full_path_lower=$(echo "$extra_file" | tr '[:upper:]' '[:lower:]')
        if [[ "$extra_basename" =~ [Ss][0-9]{1,2}[Ee][0-9]{1,2} ]] || [[ "$extra_basename" =~ [0-9]{1,2}x[0-9]{1,2} ]]; then
            # Check both filename AND full path for extras keywords
            if ! [[ "$extra_lower" =~ (behind.?the.?scenes?|bts|making.?of|deleted.?scenes?|interviews?|featurettes?|trailers?|bonus|shorts?|samples?|clips?|extras?|extended|alternates?|unused|outtakes?|gag.?reels?) ]] && \
               ! [[ "$full_path_lower" =~ (behind.?the.?scenes?|bts|making.?of|deleted.?scenes?|interviews?|featurettes?|trailers?|bonus|shorts?|samples?|clips?|extras?|extended|alternates?|unused|outtakes?|gag.?reels?) ]]; then
                should_debug low && echo "[DEBUG] Skipping regular episode file (no extras keywords in filename or path): $extra_basename" >&2
                log_skipped_extra "$extra_file" "episode_file"
                return 0  # Skip - this is a regular episode file
            fi
        fi
        
        # Detect season from full path (check all parent folders)
        local extra_season=""
        local path_to_check=$(dirname "$extra_file")
        
        should_debug low && echo "[DEBUG] Detecting season from path: $path_to_check" >&2
        
        # Walk up the directory tree looking for season indicators
        while [[ -n "$path_to_check" ]] && [[ "$path_to_check" != "/" ]]; do
            local dir_name=$(basename "$path_to_check")
            
            should_debug low && echo "[DEBUG]   Checking folder: '$dir_name'" >&2
            
            # Check for Season folder patterns
            if [[ "$dir_name" =~ [Ss]eason[[:space:]]?([0-9]{1,2}) ]]; then
                extra_season="${BASH_REMATCH[1]}"
                should_debug low && echo "[DEBUG]     MATCH! Found season $extra_season from 'Season ##' pattern" >&2
                break
            elif [[ "$dir_name" =~ ^[Ss]([0-9]{1,2})$ ]]; then
                extra_season="${BASH_REMATCH[1]}"
                should_debug low && echo "[DEBUG]     MATCH! Found season $extra_season from 'S##' pattern" >&2
                break
            # Match folders like "The X-Files (1993) S05" or "True Detective (2014) S04 (quality info)"
            elif [[ "$dir_name" =~ [[:space:]][Ss]([0-9]{1,2})($|[[:space:]\(]) ]]; then
                extra_season="${BASH_REMATCH[1]}"
                should_debug low && echo "[DEBUG]     MATCH! Found season $extra_season from 'Series Name S##' pattern" >&2
                break
            # SKIP: Numbered descriptive folders like '4. Blackmail' - digit followed by period and text
            elif [[ ! "$dir_name" =~ ^[0-9]{1,2}\.[[:space:]] ]]; then
                # Only match pure digit folders if they're not numbered list items
                if [[ "$dir_name" =~ ^([0-9]{1,2})$ ]]; then
                    extra_season="${BASH_REMATCH[1]}"
                    should_debug low && echo "[DEBUG]     MATCH! Found season $extra_season from digit-only folder" >&2
                    break
                fi
            fi
            
            # Stop if we've reached source_dir parent (so we check source_dir itself)
            if [[ "$path_to_check" == "$source_dir" ]]; then
                should_debug low && echo "[DEBUG]     Reached source_dir, stopping search" >&2
                break
            fi
            
            path_to_check=$(dirname "$path_to_check")
        done
        
        # If no season from path, check filename
        if [[ -z "$extra_season" ]]; then
            if [[ "$extra_basename" =~ [Ss]([0-9]{1,2})[Ee][0-9]{1,2} ]]; then
                extra_season="${BASH_REMATCH[1]}"
                should_debug low && echo "[DEBUG] Season from filename (S##E##): $extra_season" >&2
            elif [[ "$extra_basename" =~ ([0-9]{1,2})x[0-9]{1,2} ]]; then
                extra_season="${BASH_REMATCH[1]}"
                should_debug low && echo "[DEBUG] Season from filename (##x##): $extra_season" >&2
            elif [[ "$extra_basename" =~ [Ss]([0-9]{1,2})[[:space:]]?[Ee]xtra ]]; then
                # Matches "S05 Extra" or "S05Extra"
                extra_season="${BASH_REMATCH[1]}"
                should_debug low && echo "[DEBUG] Season from filename (S##Extra): $extra_season" >&2
            elif [[ "$extra_basename" =~ [Ss]([0-9]{1,2})\. ]]; then
                extra_season="${BASH_REMATCH[1]}"
                should_debug low && echo "[DEBUG] Season from filename (S##.): $extra_season" >&2
            fi
        fi
        
        # Categorize based on path first, then filename
        local categorized_type=""
        
        should_debug low && echo "[DEBUG] Detecting category from path..." >&2
        
        # Check parent folder names in path for extras type
        path_to_check=$(dirname "$extra_file")
        while [[ "$path_to_check" != "$source_dir" ]] && [[ -n "$path_to_check" ]] && [[ "$path_to_check" != "/" ]] && [[ -z "$categorized_type" ]]; do
            local dir_name=$(basename "$path_to_check")
            local dir_lower=$(echo "$dir_name" | tr '[:upper:]' '[:lower:]')
            
            should_debug low && echo "[DEBUG]   Checking folder: '$dir_name'" >&2
            
            if [[ "$dir_lower" =~ ^deleted.?scenes?$ ]]; then
                categorized_type="deleted scenes"
                should_debug low && echo "[DEBUG]     MATCH! Category: deleted scenes" >&2
                break
            elif [[ "$dir_lower" =~ ^(behind.?the.?scenes?|bts|making.?of)$ ]]; then
                categorized_type="behind the scenes"
                should_debug low && echo "[DEBUG]     MATCH! Category: behind the scenes" >&2
                break
            elif [[ "$dir_lower" =~ ^interviews?$ ]]; then
                categorized_type="interviews"
                should_debug low && echo "[DEBUG]     MATCH! Category: interviews" >&2
                break
            elif [[ "$dir_lower" =~ ^trailers?$ ]]; then
                categorized_type="trailers"
                should_debug low && echo "[DEBUG]     MATCH! Category: trailers" >&2
                break
            elif [[ "$dir_lower" =~ ^featurettes?$ ]]; then
                categorized_type="featurettes"
                should_debug low && echo "[DEBUG]     MATCH! Category: featurettes" >&2
                break
            elif [[ "$dir_lower" =~ ^webisodes?$ ]]; then
                categorized_type="featurettes"
                should_debug low && echo "[DEBUG]     MATCH! Category: featurettes (webisodes)" >&2
                break
            elif [[ "$dir_lower" =~ ^samples?$ ]]; then
                categorized_type="samples"
                break
            elif [[ "$dir_lower" =~ ^shorts?$ ]]; then
                categorized_type="shorts"
                break
            elif [[ "$dir_lower" =~ ^(scenes?|clips?)$ ]]; then
                categorized_type="scenes"
                break
            fi
            
            path_to_check=$(dirname "$path_to_check")
        done
        
        # If not categorized by path, try filename
        # If not categorized by directory walk, try filename patterns
        if [[ -z "$categorized_type" ]]; then
            if [[ "$extra_lower" =~ deleted.?scene ]]; then
                categorized_type="deleted scenes"
            elif [[ "$extra_lower" =~ (behind.?the.?scene|bts|making.?of) ]]; then
                categorized_type="behind the scenes"
            elif [[ "$extra_lower" =~ interview ]]; then
                categorized_type="interviews"
            elif [[ "$extra_lower" =~ gag.?reel|blooper|outtake ]]; then
                categorized_type="behind the scenes"
            elif [[ "$extra_lower" =~ trailer ]]; then
                categorized_type="trailers"
            elif [[ "$extra_lower" =~ featurette ]]; then
                categorized_type="featurettes"
            elif [[ "$extra_lower" =~ sample ]]; then
                categorized_type="samples"
            elif [[ "$extra_lower" =~ short ]]; then
                categorized_type="shorts"
            elif [[ "$extra_lower" =~ (extended|alternate.?scene|unused.?footage|scene|clip) ]]; then
                categorized_type="scenes"
            elif [[ "$extra_lower" =~ (extra|bonus) ]]; then
                categorized_type="featurettes"
            fi
        fi
        
        # Default if still not categorized
        if [[ -z "$categorized_type" ]]; then
            categorized_type="featurettes"
            should_debug low && echo "[DEBUG] No category detected, using default: featurettes" >&2
        fi
        
        should_debug low && echo "[DEBUG] Season detected: ${extra_season:-none}" >&2
        should_debug low && echo "[DEBUG] Category detected: $categorized_type" >&2
        
        # Determine destination path
        local dest_extras_dir
        if [[ -n "$extra_season" ]]; then
            extra_season=$((10#$extra_season))  # Remove leading zeros
            local season_num=$(printf "%02d" "$extra_season")
            dest_extras_dir="${DESTINATION}/${series_folder}/Season ${season_num}/$(echo "$categorized_type" | tr '[:upper:]' '[:lower:]')"
            should_debug low && echo "[DEBUG] Destination: Season ${season_num}/$categorized_type" >&2
        else
            # Series-level extras
            dest_extras_dir="${DESTINATION}/${series_folder}/$(echo "$categorized_type" | tr '[:upper:]' '[:lower:]')"
            should_debug low && echo "[DEBUG] Destination: Series-level/$categorized_type" >&2
        fi
        
        local dest_extra="${dest_extras_dir}/${extra_basename}"
        
        # Get inode for tracking
        local source_inode=$(stat -f "%i" "$extra_file" 2>/dev/null || stat -c "%i" "$extra_file" 2>/dev/null)
        
        # Check for filename conflicts (same name, different source file)
        if [[ -f "$dest_extra" ]]; then
            local existing_inode=$(stat -f "%i" "$dest_extra" 2>/dev/null || stat -c "%i" "$dest_extra" 2>/dev/null)
            if [[ "$source_inode" != "$existing_inode" ]]; then
                # Filename conflict - build unique name from parent folders
                # Extract relative path from source_dir to file, remove source_dir prefix
                local relative_to_series="${extra_file#$source_dir/}"
                # Remove the source series folder part (e.g., "The X-Files (1993) S03/")
                local relative_path="${relative_to_series#*/}"
                # Remove the final filename to get just the folder path
                local folder_path=$(dirname "$relative_path")
                # Remove the typed extras folder name (first component) since it's redundant with destination
                folder_path=$(echo "$folder_path" | sed 's|^[^/]*/||')
                # Replace slashes with " - " and remove leading numbers like "5. "
                local unique_prefix=$(echo "$folder_path" | sed 's|/| - |g' | sed 's/^[0-9]*\. //' | sed 's/ - [0-9]*\. / - /g')
                # Build new filename: prefix - basename
                local file_extension="${extra_basename##*.}"
                local file_name_no_ext="${extra_basename%.*}"
                dest_extra="${dest_extras_dir}/${unique_prefix} - ${file_name_no_ext}.${file_extension}"
                should_debug low && echo "[DEBUG] Filename conflict detected, renaming to: $(basename "$dest_extra")" >&2
            fi
        fi
        
        # Check if already processed (thread-safe)
        if grep -q "^${source_inode}$" "$PROCESSED_INODES_FILE" 2>/dev/null; then
            log_skipped_extra "$extra_file" "already_processed"
            return 0
        fi
        
        # Create destination folder
        mkdir -p "$dest_extras_dir"
        
        # Check if destination file exists
        if [[ -f "$dest_extra" ]]; then
            local dest_inode=$(stat -f "%i" "$dest_extra" 2>/dev/null || stat -c "%i" "$dest_extra" 2>/dev/null)
            
            # Already hardlinked to same source
            if [[ "$source_inode" == "$dest_inode" ]]; then
                echo "$source_inode" >> "$PROCESSED_INODES_FILE"
                log_skipped_extra "$extra_file" "already_exists"
                return 0
            fi
            
            # In copy mode, check if files are identical
            if $USE_COPY && files_are_identical "$extra_file" "$dest_extra"; then
                echo "$source_inode" >> "$PROCESSED_INODES_FILE"
                log_skipped_extra "$extra_file" "already_exists"
                return 0
            fi
            
            # Different file, replace it
            rm "$dest_extra"
        fi
        
        # Hardlink/copy the file
        local link_result=0
        if $USE_COPY; then
            cp "$extra_file" "$dest_extra" 2>/dev/null
            link_result=$?
        elif $USE_SYMLINK; then
            ln -s "$extra_file" "$dest_extra" 2>/dev/null
            link_result=$?
        else
            ln "$extra_file" "$dest_extra" 2>/dev/null || cp "$extra_file" "$dest_extra" 2>/dev/null
            link_result=$?
        fi
        
        if [[ ! -f "$dest_extra" ]]; then
            echo "[ERROR] Failed to link/copy extra: $extra_basename"
            should_debug low && echo "[DEBUG] Failed to create: $dest_extra" >&2
            log_skipped_extra "$extra_file" "link_failed"
            return 0
        fi
        
        # Verify it's actually a hardlink (not a copy)
        if ! $USE_COPY && ! $USE_SYMLINK; then
            local dest_inode=$(stat -f "%i" "$dest_extra" 2>/dev/null || stat -c "%i" "$dest_extra" 2>/dev/null)
            if [[ "$source_inode" != "$dest_inode" ]]; then
                should_debug low && echo "[WARNING] File was copied instead of hardlinked: $extra_basename (source inode: $source_inode, dest inode: $dest_inode)" >&2
            else
                should_debug low && echo "[DEBUG] Successfully hardlinked (same inode $source_inode): $extra_basename" >&2
            fi
        fi
        
        should_debug low && echo "[DEBUG] Successfully linked: $extra_basename -> $dest_extra" >&2
        echo "$source_inode" >> "$PROCESSED_INODES_FILE"
        log_processed_extra "$extra_file"
        return 1  # Return 1 to indicate file was processed
    }
    
    # Export the function
    export -f process_single_extra
    export -f log_skipped_extra
    export -f log_processed_extra
    export -f files_are_identical
    
    # Process all extras in parallel using rolling queue
    local -a active_pids=()
    local file_index=0
    
    while [[ $file_index -lt $total_extras_found ]] || [[ ${#active_pids[@]} -gt 0 ]]; do
        # Poll active jobs (non-blocking)
        local -a completed_indices=()
        
        for i in "${!active_pids[@]}"; do
            local pid="${active_pids[$i]}"
            
            if ! kill -0 "$pid" 2>/dev/null; then
                # Process finished
                wait "$pid" 2>/dev/null
                local exit_code=$?
                
                if [[ $exit_code -eq 1 ]]; then
                    ((extras_processed++))
                else
                    ((extras_skipped++))
                fi
                
                completed_indices+=("$i")
            fi
        done
        
        # Remove completed jobs
        for ((idx=${#completed_indices[@]}-1; idx>=0; idx--)); do
            local i="${completed_indices[$idx]}"
            unset 'active_pids[$i]'
        done
        active_pids=("${active_pids[@]}")
        
        # Fill available slots
        while [[ ${#active_pids[@]} -lt ${PARALLEL_JOBS:-4} ]] && [[ $file_index -lt $total_extras_found ]]; do
            local extra_file="${all_extras_files[$file_index]}"
            
            # Start background job
            (
                process_single_extra "$extra_file" "$series_folder" "$source_dir"
                exit $?
            ) &
            
            active_pids+=($!)
            ((file_index++))
        done
        
        # Brief sleep to avoid busy-waiting
        sleep 0.01
    done
    
    # Clean up temp file
    rm -f "$PROCESSED_INODES_FILE"
    
    local extras_elapsed=$((SECONDS - extras_start_time))
    echo "[INFO] Extras processing complete: $extras_processed processed, $extras_skipped skipped (${extras_elapsed}s)"
    
    # Show skip reasons if debug enabled
    if should_debug low && [[ -f "$EXTRAS_SKIPPED_FILE" ]]; then
        echo "[DEBUG] Skip reasons breakdown:" >&2
        echo "[DEBUG]   Episode files: $(grep -c '|episode_file$' "$EXTRAS_SKIPPED_FILE" 2>/dev/null || echo 0)" >&2
        echo "[DEBUG]   Already processed: $(grep -c '|already_processed$' "$EXTRAS_SKIPPED_FILE" 2>/dev/null || echo 0)" >&2
        echo "[DEBUG]   Already exists: $(grep -c '|already_exists$' "$EXTRAS_SKIPPED_FILE" 2>/dev/null || echo 0)" >&2
    fi
    
    should_debug low && echo "[DEBUG] process_series_extras: Completed for '$series_folder' - processed: $extras_processed, skipped: $extras_skipped, time: ${extras_elapsed}s" >&2
    
    if [[ $extras_processed -gt 0 ]]; then
        print_success "✓ Processed $extras_processed extras file(s) for series in ${extras_elapsed}s"
        echo ""
    fi
    
    return 0
}

# Process TV episode file
process_tv_episode() {
    local source_file="$1"
    local auto_mode="$2"
    
    # Set processing type for context-aware debug messages
    PROCESSING_TYPE="tv"
    
    should_debug high && print_info "[DEBUG] process_tv_episode: source_file='$source_file' auto_mode='$auto_mode'" >&2
    
    # Set link type flags based on TV_LINK_TYPE
    local USE_SYMLINK=false
    local USE_COPY=false
    if [[ "$TV_LINK_TYPE" == "symlink" ]]; then
        USE_SYMLINK=true
    fi
    should_debug high && print_info "[DEBUG] Link type: TV_LINK_TYPE='$TV_LINK_TYPE', USE_SYMLINK=$USE_SYMLINK, USE_COPY=$USE_COPY" >&2
    
    # FIRST: Check if file still exists (may have been moved/deleted by another instance)
    if [[ ! -f "$source_file" ]]; then
        should_debug low && echo "[DEBUG] Source file no longer exists: $source_file" >&2
        echo "⏭️  File no longer exists (moved/processed by another instance): $(basename "$source_file")"
        return 4  # Exit code 4: already processed
    fi
    
    # Get inode first for lock tracking
    local source_inode=$(stat -f "%i" "$source_file" 2>/dev/null || stat -c "%i" "$source_file" 2>/dev/null)
    
    # Handle case where stat failed (file disappeared between existence check and stat)
    if [[ -z "$source_inode" ]]; then
        should_debug low && echo "[DEBUG] Could not get inode for source file (file may have been deleted): $source_file" >&2
        echo "⏭️  File disappeared during processing (processed by another instance): $(basename "$source_file")"
        return 4  # Exit code 4: already processed
    fi
    
    # EARLY CHECK: Skip if source file is already hardlinked to destination
    
    # Load TV Extension Duplicate Mode setting (ensure it's set correctly for each episode)
    if [[ -z "$TV_EXTENSION_DUP_MODE" ]] || [[ "$TV_EXTENSION_DUP_MODE" != "off" && "$TV_EXTENSION_DUP_MODE" != "resolution" && "$TV_EXTENSION_DUP_MODE" != "bitrate" ]]; then
        if [[ -f "${CACHE_DIR}/tv_extension_dup_mode.txt" ]]; then
            TV_EXTENSION_DUP_MODE=$(cat "${CACHE_DIR}/tv_extension_dup_mode.txt")
        else
            TV_EXTENSION_DUP_MODE="off"
        fi
        should_debug low && echo "[DEBUG] Loaded TV_EXTENSION_DUP_MODE: $TV_EXTENSION_DUP_MODE" >&2
    fi
    
    # SKIP: Check if this is a .ia file with a non-.ia duplicate
    # Internet Archive files often have .ia before extension (e.g., file.ia.mp4)
    if [[ "$source_file" =~ \.ia\.[^.]+$ ]]; then
        # This file has .ia before the extension - check if non-.ia version exists
        local non_ia_file="${source_file/.ia./.}"
        if [[ -f "$non_ia_file" ]]; then
            should_debug low && echo "[DEBUG] Skipping .ia file - non-.ia version exists: $non_ia_file" >&2
            echo "⏭️  Skipping Internet Archive duplicate (non-.ia version exists): $(basename "$source_file")"
            # Log to temp file for statistics
            if [[ -n "$IA_SKIPPED_FILE" ]]; then
                echo "${source_file}|${non_ia_file}" >> "$IA_SKIPPED_FILE"
            fi
            return 5  # Exit code 5: .ia duplicate skipped
        fi
        should_debug low && echo "[DEBUG] .ia file but no non-.ia duplicate found, processing normally" >&2
    fi
    # This saves parsing, cache lookups, and API calls for files already processed
    should_debug low && echo "[DEBUG] Quick check: Is source already hardlinked to destination?" >&2
    
    # Check if any file in destination has the same inode (already hardlinked)
    if [[ -n "$DESTINATION" && -d "$DESTINATION" ]]; then
        local already_linked=$(find "$DESTINATION" -type f -inum "$source_inode" 2>/dev/null | head -n 1)
        if [[ -n "$already_linked" ]]; then
            should_debug low && echo "[DEBUG] Source inode $source_inode already exists at: $already_linked" >&2
            echo -e "${CYAN}${GREEN}✓${CYAN} File already hardlinked to destination, skipping: $(basename "$source_file")${NC}"
            return 2  # Exit code 2: already linked before lock
        fi
    fi
    should_debug low && echo "[DEBUG] Source not yet hardlinked, proceeding with processing" >&2
    
    # Try to acquire lock for this file (prevents multiple instances from processing same file)
    if ! acquire_file_lock "$source_file"; then
        echo "⏭️  File locked by another instance, skipping: $(basename "$source_file")"
        should_debug low && echo "[DEBUG] File is locked by another instance, skipping: $(basename "$source_file")" >&2
        return 3  # Exit code 3: locked by another instance
    fi
    
    echo "🔒 Lock acquired for: $(basename "$source_file")"
    
    # Double-check after acquiring lock (in case another instance just finished)

    if [[ "$basename_check" =~ [Ss][0-9]{1,2}[[:space:]]+(Live|Special|Bonus|Behind|Deleted|Extra|Featurette) ]] || \
       [[ "$parent_check" =~ [Ss][0-9]{1,2}[[:space:]]+(Live|Special|Bonus|Behind|Deleted|Extra|Featurette) ]]; then
        print_warning "Skipping: File appears to be a special/bonus episode mislabeled with season number"
        print_info "  File: $(basename "$source_file")"
        print_info "  Detected pattern: Season number followed by '${BASH_REMATCH[1]}' keyword"
        print_info "  Tip: These should be in Specials folder with proper S00Exx numbering"
        release_file_lock "$source_file"
        return 1
    fi
    
    # Parse episode information from filename
    parse_tv_episode "$source_file"
    should_debug high && print_info "[DEBUG] process_tv_episode: After parse - TV_SERIES_TITLE='$TV_SERIES_TITLE' TV_YEAR='$TV_YEAR' TV_SEASON='$TV_SEASON' TV_EPISODE='$TV_EPISODE' TV_EPISODE_TITLE='$TV_EPISODE_TITLE'" >&2
    
    # If series title not found in filename OR year not found, try parent folder
    if [[ -z "$TV_SERIES_TITLE" ]] || [[ -z "$TV_YEAR" ]]; then
        # Save ALL episode info from filename before parsing parent
        local saved_episode_title_from_file="$TV_EPISODE_TITLE"
        local saved_season_from_file="$TV_SEASON"
        local saved_episode_from_file="$TV_EPISODE"
        local saved_episode_end_from_file="$TV_EPISODE_END"
        local saved_series_title_from_file="$TV_SERIES_TITLE"
        local saved_year_from_file="$TV_YEAR"
        
        local parent_folder=$(basename "$(dirname "$source_file")")
        parse_tv_episode "$parent_folder"
        
        # Prefer filename's title, but use parent's if filename had none OR if filename looks like release group gibberish
        # Detect release group patterns: short (<=20 chars), all lowercase, contains hyphens before show name
        local use_parent_title=false
        if [[ -z "$saved_series_title_from_file" ]]; then
            use_parent_title=true
        elif [[ "$saved_series_title_from_file" =~ ^[a-z]{2,4}-[a-z]+ ]]; then
            # Looks like release group prefix (e.g., "gua-mastershorror", "ntb-showname")
            should_debug high && print_info "[DEBUG] Filename title looks like release group ('$saved_series_title_from_file'), using parent folder title instead" >&2
            use_parent_title=true
        fi
        
        if [[ "$use_parent_title" == "false" ]]; then
            TV_SERIES_TITLE="$saved_series_title_from_file"
        fi
        # Prefer parent's year if filename didn't have one
        if [[ -z "$saved_year_from_file" && -n "$TV_YEAR" ]]; then
            # Keep the year from parent
            :
        else
            TV_YEAR="$saved_year_from_file"
        fi
        # ALWAYS restore season/episode from filename (parent folder season markers are unreliable)
        if [[ -n "$saved_season_from_file" ]]; then
            TV_SEASON="$saved_season_from_file"
        fi
        if [[ -n "$saved_episode_from_file" ]]; then
            TV_EPISODE="$saved_episode_from_file"
        fi
        if [[ -n "$saved_episode_end_from_file" ]]; then
            TV_EPISODE_END="$saved_episode_end_from_file"
        fi
        # Restore episode title from filename if parent didn't have it
        [[ -z "$TV_EPISODE_TITLE" && -n "$saved_episode_title_from_file" ]] && TV_EPISODE_TITLE="$saved_episode_title_from_file"
        
        should_debug high && print_info "[DEBUG] After parent parse - TV_EPISODE_TITLE='$TV_EPISODE_TITLE' (saved was '$saved_episode_title_from_file')" >&2
        
        # If still not found and parent looks like a season folder, try grandparent
        if [[ -z "$TV_SERIES_TITLE" ]] && [[ "$parent_folder" =~ ^[Ss]eason[[:space:]]?[0-9]+ ]]; then
            local grandparent_folder=$(basename "$(dirname "$(dirname "$source_file")")")
            # Just extract title and year from grandparent, keep season/episode/title from filename
            local saved_season="$TV_SEASON"
            local saved_episode="$TV_EPISODE"
            local saved_episode_end="$TV_EPISODE_END"
            local saved_absolute="$TV_ABSOLUTE"
            local saved_episode_title="$TV_EPISODE_TITLE"
            
            parse_tv_episode "$grandparent_folder"
            
            # Restore season/episode/title info from filename if grandparent didn't have it
            [[ -z "$TV_SEASON" && -n "$saved_season" ]] && TV_SEASON="$saved_season"
            [[ -z "$TV_EPISODE" && -n "$saved_episode" ]] && TV_EPISODE="$saved_episode"
            [[ -z "$TV_EPISODE_END" && -n "$saved_episode_end" ]] && TV_EPISODE_END="$saved_episode_end"
            [[ -z "$TV_ABSOLUTE" && -n "$saved_absolute" ]] && TV_ABSOLUTE="$saved_absolute"
            [[ -z "$TV_EPISODE_TITLE" && -n "$saved_episode_title" ]] && TV_EPISODE_TITLE="$saved_episode_title"
        fi
    fi
    
    should_debug high && print_info "[DEBUG] process_tv_episode: After all parsing - TV_EPISODE_TITLE='$TV_EPISODE_TITLE'" >&2
    
    # Extract quality and metadata from filename (reuse movie parsing logic)
    parse_filename "$source_file"
    
    # If quality source not found in filename, try parent folder and grandparent folder
    # This handles cases where folder has [BD] but individual episodes don't
    if [[ -z "$PARSED_FULL_QUALITY" ]] || [[ "$PARSED_FULL_QUALITY" =~ ^[0-9]+p$ ]]; then
        local parent_folder=$(basename "$(dirname "$source_file")")
        local grandparent_folder=$(basename "$(dirname "$(dirname "$source_file")")")
        
        # Save filename quality data
        local file_quality="$PARSED_FULL_QUALITY"
        local file_custom_format="$PARSED_CUSTOM_FORMAT"
        local file_hdr="$PARSED_HDR"
        
        # Try parent folder first
        parse_filename "$parent_folder" "folder"
        
        # If parent didn't have quality source, try grandparent
        if [[ -z "$PARSED_FULL_QUALITY" ]] || [[ "$PARSED_FULL_QUALITY" =~ ^[0-9]+p$ ]]; then
            parse_filename "$grandparent_folder" "folder"
        fi
        
        # Merge: use folder's quality source with filename's resolution
        if [[ -n "$PARSED_FULL_QUALITY" && "$PARSED_FULL_QUALITY" =~ ^([^-]+)-[0-9]+p$ ]]; then
            # Folder has source-resolution format, extract source
            local folder_source="${BASH_REMATCH[1]}"
            if [[ "$file_quality" =~ ^[0-9]+p$ ]]; then
                # Filename has resolution only, combine with folder source
                PARSED_FULL_QUALITY="${folder_source}-${file_quality}"
            fi
        elif [[ -n "$PARSED_FULL_QUALITY" && ! "$PARSED_FULL_QUALITY" =~ [0-9]+p && -n "$file_quality" ]]; then
            # Folder has source only, filename has resolution
            PARSED_FULL_QUALITY="${PARSED_FULL_QUALITY}-${file_quality}"
        fi
        
        # Prefer filename custom format over folder
        [[ -n "$file_custom_format" ]] && PARSED_CUSTOM_FORMAT="$file_custom_format"
        # Prefer filename HDR over folder
        [[ -n "$file_hdr" ]] && PARSED_HDR="$file_hdr"
        
        should_debug high && echo "[DEBUG] After folder merge - PARSED_FULL_QUALITY='$PARSED_FULL_QUALITY'" >&2
        
        # Re-parse filename to restore other metadata (codecs, channels, etc)
        local saved_quality="$PARSED_FULL_QUALITY"
        local saved_custom="$PARSED_CUSTOM_FORMAT"
        local saved_hdr="$PARSED_HDR"
        parse_filename "$source_file"
        PARSED_FULL_QUALITY="$saved_quality"
        [[ -n "$saved_custom" ]] && PARSED_CUSTOM_FORMAT="$saved_custom"
        [[ -n "$saved_hdr" ]] && PARSED_HDR="$saved_hdr"
    fi
    
    # If release group not found in filename, try parent folder
    if [[ -z "$PARSED_RELEASE_GROUP" ]]; then
        local parent_folder=$(basename "$(dirname "$source_file")")
        local parent_release_group=""
        
        # Try to extract release group from parent folder name
        if [[ "$parent_folder" =~ -([A-Za-z0-9]+)$ ]]; then
            parent_release_group="${BASH_REMATCH[1]}"
        elif [[ "$parent_folder" =~ \.(x264|x265|H\.?264|H\.?265|AVC|HEVC|XviD)\.([A-Za-z0-9]+)$ ]]; then
            parent_release_group="${BASH_REMATCH[2]}"
        elif [[ "$parent_folder" =~ (x264|x265|H\.?264|H\.?265|AVC|HEVC|XviD)[[:space:]]+([A-Za-z0-9]+)$ ]]; then
            parent_release_group="${BASH_REMATCH[2]}"
        fi
        
        # If still not found and parent is a season folder, try grandparent
        if [[ -z "$parent_release_group" ]] && [[ "$parent_folder" =~ ^[Ss](eason[[:space:]]?)?[0-9]{1,2}$ ]]; then
            local grandparent_folder=$(basename "$(dirname "$(dirname "$source_file")")")
            
            if [[ "$grandparent_folder" =~ -([A-Za-z0-9]+)$ ]]; then
                parent_release_group="${BASH_REMATCH[1]}"
            elif [[ "$grandparent_folder" =~ \.(x264|x265|H\.?264|H\.?265|AVC|HEVC|XviD)\.([A-Za-z0-9]+)$ ]]; then
                parent_release_group="${BASH_REMATCH[2]}"
            elif [[ "$grandparent_folder" =~ (x264|x265|H\.?264|H\.?265|AVC|HEVC|XviD)[[:space:]]+([A-Za-z0-9]+)$ ]]; then
                parent_release_group="${BASH_REMATCH[2]}"
            fi
        fi
        
        [[ -n "$parent_release_group" ]] && PARSED_RELEASE_GROUP="$parent_release_group"
        [[ -n "$PARSED_RELEASE_GROUP" ]] && should_debug high && echo "[DEBUG] Extracted release group from folder: '$PARSED_RELEASE_GROUP'" >&2
    fi
    
    # Extract MediaInfo from file
    MEDIAINFO_VIDEO_CODEC=""
    MEDIAINFO_AUDIO_CODEC=""
    MEDIAINFO_AUDIO_CHANNELS=""
    MEDIAINFO_HDR=""
    MEDIAINFO_RESOLUTION=""
    MEDIAINFO_BIT_DEPTH=""
    MEDIAINFO_AUDIO_LANGUAGE=""
    
    if get_mediainfo_from_file "$source_file"; then
        should_debug high && echo "[DEBUG] Mediainfo extraction succeeded - assigning to PARSED variables" >&2
        [[ -n "$MEDIAINFO_VIDEO_CODEC" ]] && PARSED_VIDEO_CODEC="$MEDIAINFO_VIDEO_CODEC"
        [[ -n "$MEDIAINFO_AUDIO_CODEC" ]] && PARSED_AUDIO_CODEC="$MEDIAINFO_AUDIO_CODEC"
        [[ -n "$MEDIAINFO_AUDIO_CHANNELS" ]] && PARSED_AUDIO_CHANNELS="$MEDIAINFO_AUDIO_CHANNELS"
        [[ -n "$MEDIAINFO_HDR" ]] && PARSED_HDR="$MEDIAINFO_HDR"
        [[ -n "$MEDIAINFO_BIT_DEPTH" ]] && PARSED_BIT_DEPTH="$MEDIAINFO_BIT_DEPTH"
        [[ -n "$MEDIAINFO_AUDIO_LANGUAGE" ]] && PARSED_AUDIO_LANGUAGE="$MEDIAINFO_AUDIO_LANGUAGE"
        should_debug high && echo "[DEBUG] After assignment - PARSED_AUDIO_CODEC: '$PARSED_AUDIO_CODEC' PARSED_AUDIO_CHANNELS: '$PARSED_AUDIO_CHANNELS' PARSED_BIT_DEPTH: '$PARSED_BIT_DEPTH' PARSED_AUDIO_LANGUAGE: '$PARSED_AUDIO_LANGUAGE'" >&2
        
        if [[ -n "$MEDIAINFO_RESOLUTION" ]]; then
            if [[ -z "$PARSED_FULL_QUALITY" ]]; then
                PARSED_FULL_QUALITY="$MEDIAINFO_RESOLUTION"
            elif [[ "$PARSED_FULL_QUALITY" =~ ^([^-]+)-[0-9]+p$ ]]; then
                # Quality has source-resolution format, replace resolution
                PARSED_FULL_QUALITY="${BASH_REMATCH[1]}-${MEDIAINFO_RESOLUTION}"
            elif [[ "$PARSED_FULL_QUALITY" =~ ^[0-9]+p$ ]]; then
                # Quality is just resolution, replace it
                PARSED_FULL_QUALITY="$MEDIAINFO_RESOLUTION"
            elif [[ ! "$PARSED_FULL_QUALITY" =~ [0-9]+p ]]; then
                # Quality is just source, append resolution
                PARSED_FULL_QUALITY="${PARSED_FULL_QUALITY}-${MEDIAINFO_RESOLUTION}"
            fi
        fi
    fi
    
    # Display parsed info
    if [[ "$auto_mode" != "y" ]]; then
        print_info "========================================="
        print_info "Detected TV Episode:"
        print_info "========================================="
        [[ -n "$TV_SERIES_TITLE" ]] && print_success "Series: $TV_SERIES_TITLE"
        [[ -n "$TV_YEAR" ]] && print_success "Year: $TV_YEAR"
        [[ -n "$TV_SEASON" ]] && print_success "Season: $TV_SEASON"
        [[ -n "$TV_EPISODE" ]] && print_success "Episode: $TV_EPISODE"
        [[ -n "$TV_EPISODE_END" ]] && print_success "Episode Range: E${TV_EPISODE}-E${TV_EPISODE_END}"
        [[ -n "$TV_EPISODE_TITLE" ]] && print_success "Episode Title: $TV_EPISODE_TITLE"
        [[ -n "$TV_ABSOLUTE" ]] && print_success "Absolute: $TV_ABSOLUTE"
        [[ -n "$PARSED_FULL_QUALITY" ]] && print_success "Quality: $PARSED_FULL_QUALITY"
        [[ -n "$PARSED_VIDEO_CODEC" ]] && print_success "Video: $PARSED_VIDEO_CODEC"
        [[ -n "$PARSED_AUDIO_CODEC" ]] && print_success "Audio: $PARSED_AUDIO_CODEC ${PARSED_AUDIO_CHANNELS:+$PARSED_AUDIO_CHANNELS}"
        [[ -n "$PARSED_HDR" ]] && print_success "HDR: $PARSED_HDR"
        [[ -n "$PARSED_RELEASE_GROUP" ]] && print_success "Group: $PARSED_RELEASE_GROUP"
        echo ""
    fi
    
    # Get/confirm series info
    local series_title="$TV_SERIES_TITLE"
    local series_year="$TV_YEAR"
    should_debug high && print_info "[DEBUG] process_tv_episode: series_title='$series_title' series_year='$series_year'" >&2
    
    if [[ -z "$series_title" ]]; then
        should_debug high && print_info "[DEBUG] process_tv_episode: series_title is empty" >&2
        if [[ "$auto_mode" == "y" ]]; then
            print_error "Cannot auto-process: series title not detected"
            release_file_lock "$source_file"
            return 1
        fi
        print_info "Series Title:"
        read -r series_title
    elif [[ "$auto_mode" != "y" ]]; then
        print_info "Series Title [$series_title]:"
        read -r input
        [[ -n "$input" ]] && series_title="$input"
    fi
    
    if [[ -z "$series_year" && "$auto_mode" != "y" ]]; then
        print_info "Series Year (optional):"
        read -r series_year
    fi
    
    # Always fetch metadata for folder naming and posters
    # (TV_RENAME_EPISODES only controls whether episode FILES are renamed)
    # Check session cache first to avoid redundant lookups
    # Build a safe cache key by replacing unsafe characters with underscores
    # IMPORTANT: Only use session cache if we have a year (to prevent matching wrong series with same name)
    local raw_cache_key="${series_title}_${series_year}"
    local cache_key=$(echo "$raw_cache_key" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9_]+/_/g' | sed -E 's/^_+|_+$//g')
    local session_imdb_var="SESSION_TV_IMDB_${cache_key}"
    local session_tmdb_var="SESSION_TV_TMDB_${cache_key}"
    local session_tvdb_var="SESSION_TV_TVDB_${cache_key}"
    should_debug high && print_info "[DEBUG] Checking session cache for: $cache_key" >&2
    local session_year_var="SESSION_TV_YEAR_${cache_key}"
    
    # Declare local variables for series IDs (used throughout this function)
    local TV_IMDB="" TV_TMDB="" TV_TVDB=""
    
    # Check session cache first (for same-process sequential - fastest, no file I/O)
    if [[ -n "${!session_imdb_var}" || -n "${!session_tmdb_var}" ]]; then
        # Already looked up this series in this session
        TV_IMDB="${!session_imdb_var}"
        TV_TMDB="${!session_tmdb_var}"
        TV_TVDB="${!session_tvdb_var}"
        TV_YEAR="${!session_year_var}"
        [[ -n "$TV_YEAR" ]] && series_year="$TV_YEAR"
        should_debug high && print_info "[DEBUG] Using session cache: IMDb=$TV_IMDB, TMDb=$TV_TMDB, TVDb=$TV_TVDB" >&2
    fi
    
    # If not in session cache, check the main TV cache file (authoritative source)
    if [[ -z "$TV_IMDB" && -z "$TV_TMDB" ]]; then
        should_debug high && print_info "[DEBUG] Checking TV cache file for: $series_title ($series_year)" >&2
        local CACHED_TV_DATA=$(get_cached_tvshow "$series_title" "$series_year")
    
    if [[ -n "$CACHED_TV_DATA" ]]; then
        should_debug high && print_info "[DEBUG] Found in cache file" >&2
        # Extract canonical title from cache and use it
        local cached_title=$(echo "$CACHED_TV_DATA" | cut -d'|' -f1)
        if [[ -n "$cached_title" ]]; then
            series_title="$cached_title"
            should_debug high && print_info "[DEBUG] Using canonical title from cache: $series_title" >&2
        fi
        TV_IMDB=$(extract_from_tv_cache "$CACHED_TV_DATA" "imdb")
        TV_TMDB=$(extract_from_tv_cache "$CACHED_TV_DATA" "tmdb")
        TV_TVDB=$(extract_from_tv_cache "$CACHED_TV_DATA" "tvdb")
        # Extract year from cache if we don't have it
        if [[ -z "$series_year" ]]; then
            series_year=$(echo "$CACHED_TV_DATA" | cut -d'|' -f2)
        fi
        # Set TV_YEAR to the cached year to prevent re-fetching
        TV_YEAR="$series_year"
        print_info "✓ Using cached TV metadata: IMDb=$TV_IMDB, TMDb=$TV_TMDB, TVDb=$TV_TVDB, Year=$series_year"
        
        # Check if year is missing from cache and fetch it
        local need_cache_update=false
        if [[ -z "$series_year" && -n "$TV_IMDB" ]]; then
            series_year=$(get_year_from_imdb_id "$TV_IMDB")
            if [[ -n "$series_year" ]]; then
                TV_YEAR="$series_year"
                need_cache_update=true
            fi
        fi
        
        # If IMDb ID is missing from cache, try to fetch it
        if [[ -z "$TV_IMDB" ]]; then
            if [[ -n "$TV_TMDB" ]]; then
                TV_IMDB=$(get_tv_imdb_from_tmdb "$TV_TMDB")
            fi
            
            # If still empty, search directly
            if [[ -z "$TV_IMDB" ]]; then
                TV_IMDB=$(search_imdb_tv "$series_title" "$series_year")
            fi
            
            # Update cache if we found it
            if [[ -n "$TV_IMDB" ]]; then
                print_success "✓ Found missing IMDb ID: $TV_IMDB"
                need_cache_update=true
            fi
        fi
        
        # Update cache if anything was missing
        if [[ "$need_cache_update" == "true" ]]; then
            save_tvshow_to_cache "$series_title" "$series_year" "$TV_IMDB" "$TV_TMDB" "$TV_TVDB"
        fi
    else
        # Not in cache - need to do online lookup
        # Use file-based locking to prevent duplicate API calls from parallel processes
        local lock_dir="/tmp/tv_lookup_locks"
        mkdir -p "$lock_dir" 2>/dev/null
        local lock_file="${lock_dir}/${cache_key}.lock"
        local got_lock=false
        local waited_for_lock=false
        local retry_count=0
        local max_retries=3
        
        # Try to acquire lock with retry loop for race conditions
        while [[ "$got_lock" == "false" && $retry_count -lt $max_retries ]]; do
            # Try to acquire lock (atomic operation)
            if mkdir "$lock_file" 2>/dev/null; then
                got_lock=true
                should_debug high && print_info "[DEBUG] Acquired lookup lock for: $cache_key" >&2
            else
                # Another process is doing the lookup - wait for it
                should_debug high && print_info "[DEBUG] Waiting for another process to complete lookup for: $cache_key" >&2
                echo -ne "\r${BLUE}⏳ Waiting for lookup: ${series_title}${NC}" >&2
                waited_for_lock=true
                local wait_count=0
                local max_wait=60  # Max 60 seconds
                while [[ -d "$lock_file" && $wait_count -lt $max_wait ]]; do
                    sleep 1
                    ((wait_count++))
                done
                
                # Lock released - check cache again (the other process should have populated it)
                if [[ $wait_count -lt $max_wait ]]; then
                    should_debug high && print_info "[DEBUG] Lock released, re-checking cache" >&2
                    # Small random delay to stagger parallel processes waking up simultaneously
                    sleep 0.$((RANDOM % 5 + 1))
                    
                    # First check if the lock-holder saved a TMDb ID mapping for us
                    local lock_result_file="${lock_dir}/${cache_key}.result"
                    if [[ -f "$lock_result_file" ]]; then
                        # Read the TMDb/IMDb IDs from the result file
                        local result_tmdb=$(sed -n '1p' "$lock_result_file" 2>/dev/null)
                        local result_imdb=$(sed -n '2p' "$lock_result_file" 2>/dev/null)
                        local result_tvdb=$(sed -n '3p' "$lock_result_file" 2>/dev/null)
                        local result_year=$(sed -n '4p' "$lock_result_file" 2>/dev/null)
                        if [[ -n "$result_tmdb" || -n "$result_imdb" ]]; then
                            should_debug high && print_info "[DEBUG] Found lookup result from lock-holder: TMDb=$result_tmdb IMDb=$result_imdb" >&2
                            TV_TMDB="$result_tmdb"
                            TV_IMDB="$result_imdb"
                            TV_TVDB="$result_tvdb"
                            [[ -n "$result_year" ]] && series_year="$result_year" && TV_YEAR="$result_year"
                            # Clear the waiting message
                            echo -ne "\r\033[K" >&2
                            print_info "✓ Using cached TV metadata (from parallel lookup): IMDb=$TV_IMDB, TMDb=$TV_TMDB, TVDb=$TV_TVDB"
                            break
                        fi
                    fi
                    
                    # Fall back to cache lookup by title
                    CACHED_TV_DATA=$(get_cached_tvshow "$series_title" "$series_year")
                    if [[ -n "$CACHED_TV_DATA" ]]; then
                        should_debug high && print_info "[DEBUG] Found in cache after waiting" >&2
                        # Extract canonical title from cache
                        local cached_title=$(echo "$CACHED_TV_DATA" | cut -d'|' -f1)
                        if [[ -n "$cached_title" ]]; then
                            series_title="$cached_title"
                            should_debug high && print_info "[DEBUG] Using canonical title from cache: $series_title" >&2
                        fi
                        TV_IMDB=$(extract_from_tv_cache "$CACHED_TV_DATA" "imdb")
                        TV_TMDB=$(extract_from_tv_cache "$CACHED_TV_DATA" "tmdb")
                        TV_TVDB=$(extract_from_tv_cache "$CACHED_TV_DATA" "tvdb")
                        if [[ -z "$series_year" ]]; then
                            series_year=$(echo "$CACHED_TV_DATA" | cut -d'|' -f2)
                        # Clear the waiting message
                        echo -ne "\r\033[K" >&2
                        fi
                        TV_YEAR="$series_year"
                        print_info "✓ Using cached TV metadata (after wait): IMDb=$TV_IMDB, TMDb=$TV_TMDB, TVDb=$TV_TVDB"
                        # Skip to session cache save - exit retry loop
                        break
                    else
                        # Still not in cache - another process might have grabbed the lock
                        # Try to get lock ourselves, if we fail, loop and wait again
                        if mkdir "$lock_file" 2>/dev/null; then
                            got_lock=true
                            should_debug high && print_info "[DEBUG] Acquired lookup lock after wait" >&2
                        else
                            # Another process grabbed it - increment retry and loop back to wait
                            ((retry_count++))
                            should_debug high && print_info "[DEBUG] Lock grabbed by another process, retrying ($retry_count/$max_retries)" >&2
                        fi
                    fi
                else
                    # Timeout - stale lock? Try to acquire anyway
                    rm -rf "$lock_file" 2>/dev/null
                    if mkdir "$lock_file" 2>/dev/null; then
                        got_lock=true
                        should_debug high && print_info "[DEBUG] Acquired lookup lock after timeout (stale lock removed)" >&2
                    fi
                fi
            fi
        done
        
        # Only do the lookup if we got the lock (and didn't found it in cache after waiting)
        if [[ "$got_lock" == "true" ]]; then
        
        # PRIORITY CHECK: If we have any ID hint from folder name, use it directly
        if [[ -n "$BATCH_SERIES_TMDB_HINT" || -n "$BATCH_SERIES_IMDB_HINT" || -n "$BATCH_SERIES_TVDB_HINT" ]]; then
            should_debug high && print_info "[DEBUG] Using ID hint(s) from folder name: TMDb='$BATCH_SERIES_TMDB_HINT' IMDb='$BATCH_SERIES_IMDB_HINT' TVDb='$BATCH_SERIES_TVDB_HINT'" >&2
            
            # Set the IDs we have from folder hints
            [[ -n "$BATCH_SERIES_TMDB_HINT" ]] && TV_TMDB="$BATCH_SERIES_TMDB_HINT"
            [[ -n "$BATCH_SERIES_IMDB_HINT" ]] && TV_IMDB="$BATCH_SERIES_IMDB_HINT"
            [[ -n "$BATCH_SERIES_TVDB_HINT" ]] && TV_TVDB="$BATCH_SERIES_TVDB_HINT"
            
            # Try to get additional IDs from the ones we have
            if [[ -n "$TV_TMDB" && -z "$TV_IMDB" ]]; then
                # Get IMDb ID from TMDb
                local found_imdb=$(get_tv_imdb_from_tmdb "$TV_TMDB")
                [[ -n "$found_imdb" ]] && TV_IMDB="$found_imdb"
            fi
            
            if [[ -n "$TV_IMDB" && -z "$TV_TMDB" ]]; then
                # Get TMDb ID from IMDb
                local found_tmdb=$(get_tmdb_from_imdb_tv "$TV_IMDB")
                [[ -n "$found_tmdb" ]] && TV_TMDB="$found_tmdb"
            fi
            
            # Get year if we don't have it
            if [[ -z "$series_year" ]]; then
                if [[ -n "$TV_TMDB" ]]; then
                    local found_year=$(get_tv_year_from_tmdb "$TV_TMDB")
                    [[ -n "$found_year" ]] && series_year="$found_year" && TV_YEAR="$series_year"
                elif [[ -n "$TV_IMDB" ]]; then
                    local found_year=$(get_year_from_imdb_id "$TV_IMDB")
                    [[ -n "$found_year" ]] && series_year="$found_year" && TV_YEAR="$series_year"
                fi
            fi
            
            # Save to cache and skip API searches
            save_tvshow_to_cache "$series_title" "$series_year" "$TV_IMDB" "$TV_TMDB" "$TV_TVDB"
            print_info "✓ Using ID(s) from folder name: TMDb=${TV_TMDB:-none}, IMDb=${TV_IMDB:-none}, TVDb=${TV_TVDB:-none}${series_year:+, Year=$series_year}"
        else
            # No hints - proceed with API searches
        
        # For anime naming format, try cleaning title for better database matches
        local search_title="$series_title"
        local original_title="$series_title"
        if [[ "$TV_NAMING_EPISODE" == "2" ]]; then
            # Strip release group tags like [Anime Time], [SubsPlease], etc.
            search_title=$(echo "$search_title" | sed -E 's/^\[[^]]+\][[:space:]]*//')
            # Strip common anime suffixes that prevent matches
            search_title=$(echo "$search_title" | sed -E 's/[[:space:]]+(OVA|Movie|Special|Season [0-9]+|Part [0-9]+|[0-9]nd Season|[0-9]rd Season|[0-9]th Season)$//')
            # Strip quality/format tags
            search_title=$(echo "$search_title" | sed -E 's/[[:space:]]+\[?[0-9]{3,4}p\]?$//')
            search_title=$(echo "$search_title" | sed -E 's/[[:space:]]+\[?(BD|BluRay|WEB|HDTV)\]?$//')
            
            if [[ "$search_title" != "$original_title" ]]; then
                should_debug high && print_info "[DEBUG] Anime mode: Cleaned title from '$original_title' to '$search_title'" >&2
            fi
        fi
        
        should_debug high && print_info "[DEBUG] Not in cache, starting online lookup for: $search_title ($series_year)" >&2
        
        # Show progress indicator for online lookup
        echo -ne "\r${BLUE}⏳ Looking up: ${search_title}${NC}" >&2
        
        # Check if TMDb API key is available
        if [[ -n "$TMDB_API_KEY" ]]; then
            # Search strategy: Check folder name first for better context, then TMDb search, then other fallbacks
            
            # Step 0: Pre-check folder name for better context (before generic search)
            # If folder has "Animated Series" or other helpful keywords, use it FIRST to avoid wrong matches
            local use_folder_title=""
            local use_folder_year=""
            
            # Check if folder name has helpful context like "Animated Series"
            if [[ -n "$source_file" && -e "$source_file" ]]; then
                local parent_folder=$(basename "$(dirname "$source_file")")
                local grandparent_folder=$(basename "$(dirname "$(dirname "$source_file")")")
                local check_folder=""
                
                # Determine which folder to check (skip season/episode folders)
                if [[ "$parent_folder" =~ ^[Ss](eason[[:space:]])?[[:space:]]?[0-9]{1,2} ]] || \
                   [[ "$parent_folder" =~ [Ss][0-9]{1,2}[^0-9]*[Ee][0-9]{1,3} ]] || \
                   [[ "$parent_folder" =~ [0-9]{1,2}x[0-9]{1,3} ]] || \
                   [[ "$parent_folder" =~ [Ee][Pp][0-9]{2,3} ]]; then
                    check_folder="$grandparent_folder"
                else
                    check_folder="$parent_folder"
                fi
                
                # If folder has "Animated Series" or "Cartoon", use it first (better context than generic title)
                if [[ "$check_folder" =~ [Aa]nimated.*[Ss]eries ]] || [[ "$check_folder" =~ [Cc]artoon ]]; then
                    should_debug high && print_info "[DEBUG] Step 0: Folder has helpful context, using folder name first" >&2
                    
                    # Extract year
                    if [[ "$check_folder" =~ \(([0-9]{4})(-[0-9]{4})?\) ]] || [[ "$check_folder" =~ \[([0-9]{4})(-[0-9]{4})?\] ]]; then
                        use_folder_year="${BASH_REMATCH[1]}"
                    fi
                    
                    # Clean folder name - remove year ranges, season info, quality tags, then extract just the main title
                    use_folder_title="$check_folder"
                    # Clean up dots/underscores to spaces FIRST so patterns match better
                    use_folder_title=$(echo "$use_folder_title" | sed 's/[._]/ /g' | sed 's/  */ /g' | sed 's/^ //;s/ $//')
                    # Remove year ranges in parentheses
                    use_folder_title=$(echo "$use_folder_title" | sed -E 's/[[:space:]]*\([0-9]{4}(-[0-9]{4})?\)[[:space:]]*/ /')
                    # Remove "Season X-Y" patterns and everything after
                    use_folder_title=$(echo "$use_folder_title" | sed -E 's/[[:space:]]+(Season|Seasons)[[:space:]]+[0-9]+([[:space:]]*-[[:space:]]*[0-9]+)?.*//')
                    # Remove "S01-S05" patterns and everything after
                    use_folder_title=$(echo "$use_folder_title" | sed -E 's/[[:space:]]+[Ss][0-9]{1,2}[[:space:]]*-[[:space:]]*[Ss][0-9]{1,2}.*//')
                    # Remove "Complete..." and everything after
                    use_folder_title=$(echo "$use_folder_title" | sed -E 's/[[:space:]]*[-—][[:space:]]*(The[[:space:]]+)?Complete.*//')
                    
                    # Smart parenthetical removal: Check if base title (before parens) is short
                    local base_title_temp=$(echo "$use_folder_title" | sed -E 's/[[:space:]]*\([^)]*\)[[:space:]]*$//')
                    if [[ ${#base_title_temp} -le 10 ]] && [[ "$use_folder_title" =~ \(.*[Aa]nimated[[:space:]][Ss]eries.*\) ]]; then
                        # Short title with "Animated Series" in parens - extract and append it
                        use_folder_title="$base_title_temp The Animated Series"
                    else
                        # Remove parenthetical format/quality/descriptive info (full removal safe for longer titles)
                        use_folder_title=$(echo "$use_folder_title" | sed -E 's/[[:space:]]*\([^)]*([Ff]ormat|MP4|MKV|AVI|[0-9]{3,4}p|x26[45]|HEVC|[Qq]uality|[Cc]omplete|[Ss]eries|[Cc]artoon|[Cc]ollection)[^)]*\)[[:space:]]*//')
                    fi
                    
                    # Remove quality/release tags and everything after
                    use_folder_title=$(echo "$use_folder_title" | sed -E 's/[[:space:]]+(720p|1080p|2160p|x264|x265|HEVC|H\.?264).*//')
                    # Clean up multiple spaces
                    use_folder_title=$(echo "$use_folder_title" | sed 's/  */ /g' | sed 's/^ //;s/ $//')
                    
                    # Final cleanup: If title doesn't end with "The Animated Series", remove redundant trailing text
                    if [[ ! "$use_folder_title" =~ [[:space:]]The[[:space:]]Animated[[:space:]]Series$ ]]; then
                        # Remove trailing "Animated Series", "TAS", "Cartoon", etc.
                        use_folder_title=$(echo "$use_folder_title" | sed -E 's/[[:space:]]+(The[[:space:]]+)?Animated[[:space:]]+(Series|Seres)$//')
                        use_folder_title=$(echo "$use_folder_title" | sed -E 's/[[:space:]]+T\.?A\.?S\.?$//')
                        use_folder_title=$(echo "$use_folder_title" | sed -E 's/[[:space:]]+Cartoon$//')
                    fi
                    use_folder_title=$(echo "$use_folder_title" | sed 's/  */ /g' | sed 's/^ //;s/ $//')
                    
                    should_debug high && print_info "[DEBUG] Step 0: Using folder title='$use_folder_title' year='$use_folder_year'" >&2
                fi
            fi
            
            # Step 1: Try TMDb search - use folder title if it has better context, otherwise use filename title
            should_debug high && print_info "[DEBUG] Step 1: TMDb title/year search" >&2
            if [[ -n "$use_folder_title" ]]; then
                # Use folder title (has better context)
                TV_TMDB=$(search_tmdb_tv "$use_folder_title" "${use_folder_year:-$series_year}" "$source_file")
                if [[ -n "$TV_TMDB" ]]; then
                    series_title="$use_folder_title"
                    [[ -n "$use_folder_year" && -z "$series_year" ]] && series_year="$use_folder_year"
                fi
            else
                # Use filename title (cleaned for anime if applicable)
                TV_TMDB=$(search_tmdb_tv "$search_title" "$series_year" "$source_file")
            fi
            should_debug high && print_info "[DEBUG] Step 1 result: TV_TMDB='$TV_TMDB'" >&2
            
            # Step 1b: If no results, try folder-based fallback
            if [[ -z "$TV_TMDB" ]]; then
                local parent_folder=$(basename "$(dirname "$source_file")")
                local grandparent_folder=$(basename "$(dirname "$(dirname "$source_file")")")
                local fallback_title=""
                local fallback_year=""
                
                # If parent is a season folder, Specials/Origins folder, or contains episode patterns, use grandparent
                # Match "Season ##", "S##", "Season ## (year)", "Season ## (year-year)", etc.
                # Match "Specials", "Specials (year)", "Specials (year-year)", "Specials (XXXX)"
                # Match "Origins", "Origins (Shorts)", etc.
                # Also skip if parent contains episode patterns like "s-01e-04" or "s01e04"
                local parent_base=$(echo "$parent_folder" | sed -E 's/[[:space:]]*\([^)]*\)[[:space:]]*$//')
                if [[ "$parent_folder" =~ ^[Ss](eason[[:space:]])?[[:space:]]?[0-9]{1,2} ]] || \
                   [[ "$parent_base" =~ ^[Ss]pecials?$ ]] || [[ "$parent_base" =~ ^[Oo]rigins?$ ]] || \
                   [[ "$parent_folder" =~ [Ss][0-9]{1,2}[^0-9]*[Ee][0-9]{1,3} ]] || \
                   [[ "$parent_folder" =~ [0-9]{1,2}x[0-9]{1,3} ]] || \
                   [[ "$parent_folder" =~ [Ee][Pp][0-9]{2,3} ]]; then
                    fallback_title="$grandparent_folder"
                else
                    fallback_title="$parent_folder"
                fi
                
                # Only try fallback if folder name is different from extracted title
                # Clean up fallback title - remove season/episode patterns, quality tags, etc.
                if [[ -n "$fallback_title" && "$fallback_title" != "." && "$fallback_title" != ".." ]]; then
                    # Extract year from fallback title if present
                    if [[ "$fallback_title" =~ \(([0-9]{4})(-[0-9]{4})?\) ]] || [[ "$fallback_title" =~ \[([0-9]{4})(-[0-9]{4})?\] ]]; then
                        fallback_year="${BASH_REMATCH[1]}"
                    fi
                    
                    # Clean up fallback title - same logic as use_folder_title
                    # Clean up dots/underscores to spaces FIRST
                    fallback_title=$(echo "$fallback_title" | sed 's/[._]/ /g' | sed 's/  */ /g' | sed 's/^ //;s/ $//')
                    # Remove year ranges in parentheses and brackets
                    fallback_title=$(echo "$fallback_title" | sed -E 's/[[:space:]]*\([0-9]{4}(-[0-9]{4})?\)[[:space:]]*/ /')
                    fallback_title=$(echo "$fallback_title" | sed -E 's/[[:space:]]*\[[0-9]{4}(-[0-9]{4})?\][[:space:]]*/ /')
                    # Remove "Season X-Y" patterns and everything after
                    fallback_title=$(echo "$fallback_title" | sed -E 's/[[:space:]]+(Season|Seasons)[[:space:]]+[0-9]+([[:space:]]*-[[:space:]]*[0-9]+)?.*//')
                    # Remove "S01-S05" patterns and everything after
                    fallback_title=$(echo "$fallback_title" | sed -E 's/[[:space:]]+[Ss][0-9]{1,2}[[:space:]]*-[[:space:]]*[Ss][0-9]{1,2}.*//')
                    # Remove standalone season markers: S01, S 01, etc. at end or followed by space/quality
                    fallback_title=$(echo "$fallback_title" | sed -E 's/[[:space:]]+[Ss][[:space:]]*[0-9]{1,2}([[:space:]]|$).*//')
                    # Remove "Complete..." and everything after
                    fallback_title=$(echo "$fallback_title" | sed -E 's/[[:space:]]*[-—][[:space:]]*(The[[:space:]]+)?Complete.*//')
                    # Remove parenthetical format/quality/descriptive info
                    fallback_title=$(echo "$fallback_title" | sed -E 's/[[:space:]]*\([^)]*([Ff]ormat|MP4|MKV|AVI|[Cc]ollection|[0-9]{3,4}p|x26[45]|HEVC|[Qq]uality|[Cc]omplete|[Ss]eries|[Cc]artoon)[^)]*\)[[:space:]]*//')
                    # Remove quality/release tags and everything after
                    fallback_title=$(echo "$fallback_title" | sed -E 's/[[:space:]]+(720p|1080p|2160p|4K|UHD|HDTV|WEB-?DL|WEB-?Rip|BluRay|BDRip|DVDRip|DVD|x264|x265|HEVC|H\.?264|H\.?265|AAC|AC3|DD5\.1|DTS|10bit|8bit|AMZN|NF|HULU|DSNP|HBO|ATVP|REPACK|PROPER).*//')
                    # Clean up multiple spaces
                    fallback_title=$(echo "$fallback_title" | sed 's/  */ /g' | sed 's/^ //;s/ $//')
                    # Extract just the main title
                    if [[ "$fallback_title" =~ ^(.+)[[:space:]]The[[:space:]]Animated[[:space:]]Series$ ]]; then
                        # Ends with "The Animated Series" - keep it as is
                        :
                    else
                        # Remove trailing "Animated Series", "TAS", "Cartoon", etc.
                        fallback_title=$(echo "$fallback_title" | sed -E 's/[[:space:]]+(The[[:space:]]+)?Animated[[:space:]]+(Series|Seres)$//')
                        fallback_title=$(echo "$fallback_title" | sed -E 's/[[:space:]]+T\.?A\.?S\.?$//')
                        fallback_title=$(echo "$fallback_title" | sed -E 's/[[:space:]]+Cartoon$//')
                    fi
                    fallback_title=$(echo "$fallback_title" | sed 's/  */ /g' | sed 's/^ //;s/ $//')
                    # Remove common abbreviations at end: TAS (The Animated Series), etc.
                    fallback_title=$(echo "$fallback_title" | sed -E 's/[[:space:]]+T\.?A\.?S\.?$//' | sed -E 's/[[:space:]]+TAS$//')
                    fallback_title=$(echo "$fallback_title" | sed 's/  */ /g' | sed 's/^ //;s/ $//')
                    
                    # Normalize both titles for comparison (lowercase, remove special chars)
                    local norm_series_title=$(echo "$series_title" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]//g')
                    local norm_fallback_title=$(echo "$fallback_title" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]//g')
                    
                    # Only search if fallback title is different and not empty
                    if [[ -n "$fallback_title" && "$norm_fallback_title" != "$norm_series_title" ]]; then
                        should_debug high && print_info "[DEBUG] Step 1b: Trying folder-based search with title='$fallback_title' year='$fallback_year'" >&2
                        print_info "⚠ Title '$series_title' not found, trying folder name: '$fallback_title'${fallback_year:+ ($fallback_year)}" >&2
                        
                        local folder_tmdb=$(search_tmdb_tv "$fallback_title" "${fallback_year:-$series_year}" "$source_file")
                        if [[ -n "$folder_tmdb" ]]; then
                            TV_TMDB="$folder_tmdb"
                            should_debug high && print_info "[DEBUG] Step 1b result: Found with folder name - TV_TMDB='$TV_TMDB'" >&2
                            # Update series title to the folder-based one for cache
                            series_title="$fallback_title"
                            [[ -n "$fallback_year" && -z "$series_year" ]] && series_year="$fallback_year"
                        fi
                    fi
                fi
            fi
            
            # Step 2: If no TMDb found, try runtime-aware search as fallback
            if [[ -z "$TV_TMDB" ]]; then
                should_debug high && print_info "[DEBUG] Step 2: TMDb runtime-aware search" >&2
                if [[ -n "$TV_SEASON" && -n "$TV_EPISODE" ]]; then
                    TV_TMDB=$(search_tmdb_tv_with_runtime "$search_title" "$series_year" "$source_file" "$TV_SEASON" "$TV_EPISODE")
                else
                    TV_TMDB=$(search_tmdb_tv_with_runtime "$search_title" "$series_year" "$source_file" "" "")
                fi
                should_debug high && print_info "[DEBUG] Step 2 result: TV_TMDB='$TV_TMDB'" >&2
            fi
            
            # Step 3: If TMDb found, get IMDb and TVDb from TMDb
            if [[ -n "$TV_TMDB" ]]; then
                should_debug high && print_info "[DEBUG] Step 3: Getting IMDb and TVDb from TMDb" >&2
                TV_IMDB=$(get_tv_imdb_from_tmdb "$TV_TMDB")
                TV_TVDB=$(get_tvdb_from_tmdb "$TV_TMDB")
                should_debug high && print_info "[DEBUG] Step 3 result: TV_IMDB='$TV_IMDB' TV_TVDB='$TV_TVDB'" >&2
            fi
        else
            [[ "$DEBUG_MODE" == "true" ]] && print_info "[DEBUG] TMDb API key not configured - skipping TMDb search" >&2
        fi
        
        # Step 4: If still no IMDb, try direct IMDb search
        if [[ -z "$TV_IMDB" ]]; then
            should_debug high && print_info "[DEBUG] Step 4: Direct IMDb search" >&2
            TV_IMDB=$(search_imdb_tv "$search_title" "$series_year")
            should_debug high && print_info "[DEBUG] Step 4 result: TV_IMDB='$TV_IMDB'" >&2
            
            # If we got IMDb but still no TMDb and have API key, use /find endpoint
            if [[ -n "$TV_IMDB" && -z "$TV_TMDB" && -n "$TMDB_API_KEY" && "$JSON_DB_MODE" != "json_only" ]]; then
                should_debug high && print_info "[DEBUG] Step 4b: Using /find endpoint with IMDb from search" >&2
                local find_url="${TMDB_API_BASE}/find/${TV_IMDB}?api_key=${TMDB_API_KEY}&external_source=imdb_id"
                local result=$(curl -s "$find_url" 2>/dev/null)
                TV_TMDB=$(echo "$result" | grep -oE '"id":[0-9]+' | head -1 | grep -oE '[0-9]+')
                should_debug high && print_info "[DEBUG] Step 4b result: TV_TMDB='$TV_TMDB'" >&2
                
                # If /find didn't work (TMDb doesn't have IMDb ID linked), try searching by title
                if [[ -z "$TV_TMDB" ]]; then
                    should_debug high && print_info "[DEBUG] Step 4c: /find failed, trying TMDb search by title (IMDb ID not linked in TMDb)" >&2
                    TV_TMDB=$(search_tmdb_tv "$search_title" "$series_year")
                    should_debug high && print_info "[DEBUG] Step 4c result: TV_TMDB='$TV_TMDB'" >&2
                fi
                
                # If TMDb found via /find or search, get TVDb from it
                if [[ -n "$TV_TMDB" && -z "$TV_TVDB" ]]; then
                    TV_TVDB=$(get_tvdb_from_tmdb "$TV_TMDB")
                fi
            fi
        fi
        
        # Step 5: If still no TVDb, try direct TVDb search
        if [[ -z "$TV_TVDB" ]]; then
            should_debug high && print_info "[DEBUG] Step 5: Direct TVDb search" >&2
            TV_TVDB=$(search_tvdb "$search_title" "$series_year")
            should_debug high && print_info "[DEBUG] Step 5 result: TV_TVDB='$TV_TVDB'" >&2
        fi
        
        [[ "$DEBUG_MODE" == "true" ]] && print_info "[DEBUG] Final results: TV_IMDB='$TV_IMDB' TV_TMDB='$TV_TMDB' TV_TVDB='$TV_TVDB'" >&2
        
        # Fetch canonical title/year from TMDb before saving to cache (if we have TMDb ID)
        local cache_title="$series_title"
        local cache_year="$series_year"
        if [[ -n "$TV_TMDB" && -n "$TMDB_API_KEY" ]]; then
            should_debug high && print_info "[DEBUG] Fetching canonical title/year from TMDb ID: $TV_TMDB" >&2
            api_delay
            local tv_url="${TMDB_API_BASE}/tv/${TV_TMDB}?api_key=${TMDB_API_KEY}"
            local tv_details=$(curl -s --connect-timeout 10 --max-time 30 "$tv_url" 2>/dev/null)
            
            if [[ -n "$tv_details" ]]; then
                local canonical_cache_title=$(extract_title_from_tv_details "$tv_details")
                if [[ -n "$canonical_cache_title" && ! "$canonical_cache_title" =~ ^(Wait and [Tt]ry [Aa]gain|Rate [Ll]imit|Throttled)$ ]]; then
                    cache_title="$canonical_cache_title"
                    # USE canonical title for processing, not just cache
                    series_title="$canonical_cache_title"
                    should_debug high && print_info "[DEBUG] Using canonical title: $series_title" >&2
                fi
                
                local canonical_cache_year=$(extract_year_from_tv_details "$tv_details")
                if [[ -n "$canonical_cache_year" ]]; then
                    cache_year="$canonical_cache_year"
                    # USE canonical year for processing, not just cache
                    series_year="$canonical_cache_year"
                    should_debug high && print_info "[DEBUG] Using canonical year: $series_year" >&2
                fi
            fi
        fi
        
        # If no TMDb but have IMDb, fetch canonical title/year from IMDb
        if [[ -z "$TV_TMDB" && -n "$TV_IMDB" ]]; then
            should_debug high && print_info "[DEBUG] Fetching canonical title/year from IMDb ID: $TV_IMDB" >&2
            local imdb_title=$(get_title_from_imdb_id "$TV_IMDB")
            if [[ -n "$imdb_title" ]]; then
                cache_title="$imdb_title"
                series_title="$imdb_title"
                should_debug high && print_info "[DEBUG] Using canonical title from IMDb: $series_title" >&2
            fi
            
            local imdb_year=$(get_year_from_imdb_id "$TV_IMDB")
            if [[ -n "$imdb_year" ]]; then
                cache_year="$imdb_year"
                series_year="$imdb_year"
                should_debug high && print_info "[DEBUG] Using canonical year from IMDb: $series_year" >&2
            fi
        fi
        
        # Save to cache if we have at least one ID (use canonical title/year)
        if [[ -n "$TV_IMDB" || -n "$TV_TMDB" || -n "$TV_TVDB" ]]; then
            save_tvshow_to_cache "$cache_title" "$cache_year" "$TV_IMDB" "$TV_TMDB" "$TV_TVDB"
            
            # Track shows with incomplete database IDs for summary reporting
            local missing_ids=""
            local missing_reason=""
            if [[ -z "$TV_IMDB" && -z "$TV_TMDB" && -z "$TV_TVDB" ]]; then
                missing_ids="IMDb, TMDb, TVDb"
                missing_reason="All database searches returned no results"
            elif [[ -z "$TV_IMDB" && -z "$TV_TMDB" ]]; then
                missing_ids="IMDb, TMDb"
                missing_reason="IMDb and TMDb searches returned no results"
            elif [[ -z "$TV_IMDB" && -z "$TV_TVDB" ]]; then
                missing_ids="IMDb, TVDb"
                missing_reason="IMDb and TVDb searches returned no results"
            elif [[ -z "$TV_TMDB" && -z "$TV_TVDB" ]]; then
                missing_ids="TMDb, TVDb"
                missing_reason="TMDb and TVDb searches returned no results"
            elif [[ -z "$TV_IMDB" ]]; then
                missing_ids="IMDb"
                missing_reason="IMDb search returned no results"
            elif [[ -z "$TV_TMDB" ]]; then
                missing_ids="TMDb"
                if [[ -n "$TV_IMDB" ]]; then
                    missing_reason="TMDb /find and search returned no results (IMDb ID $TV_IMDB not linked in TMDb database)"
                else
                    missing_reason="TMDb search returned no results"
                fi
            elif [[ -z "$TV_TVDB" ]]; then
                missing_ids="TVDb"
                missing_reason="TVDb search returned no results"
            fi
            
            if [[ -n "$missing_ids" ]]; then
                echo "$series_title|||$missing_ids|||$missing_reason" >> "${CACHE_DIR}/.missing_tv_ids_$$.tmp"
            fi
        fi
    fi
    
    # If year is still missing, try to fetch it (only if not already cached)
    if [[ -z "$series_year" ]]; then
        # Try IMDb ID first (fastest)
        if [[ -n "$TV_IMDB" ]]; then
            series_year=$(get_year_from_imdb_id "$TV_IMDB")
        fi
        
        # If that didn't work, search IMDb by name
        if [[ -z "$series_year" && -n "$series_title" ]]; then
            local year_and_id=$(search_imdb_tv_for_year "$series_title")
            if [[ -n "$year_and_id" ]]; then
                series_year="${year_and_id%%|*}"  # Extract year (before pipe)
                local found_imdb="${year_and_id##*|}"  # Extract IMDb ID (after pipe)
                # Use the IMDb ID if we don't already have one
                if [[ -z "$TV_IMDB" && -n "$found_imdb" && "$found_imdb" != "$series_year" ]]; then
                    TV_IMDB="$found_imdb"
                    print_success "✓ Also found IMDb ID: $TV_IMDB" >&2
                fi
            fi
        fi
        
        # Update TV_YEAR and re-cache if we found it
        if [[ -n "$series_year" ]]; then
            TV_YEAR="$series_year"
            print_success "✓ Found series year: $series_year" >&2
            # Update cache with the year and any IDs we have
            if [[ -n "$TV_IMDB" || -n "$TV_TMDB" || -n "$TV_TVDB" ]]; then
                print_info "Saved TV show to cache"
                save_tvshow_to_cache "$series_title" "$series_year" "$TV_IMDB" "$TV_TMDB" "$TV_TVDB"
            fi
        fi
    else
        # Year was found in cache or filename, no need to fetch or re-save
        TV_YEAR="$series_year"
    fi
    
        fi  # End of TMDb hint check - close the else branch for API searches
        
        # Save result file for parallel processes waiting on this lock
        if [[ -n "$lock_file" && -n "$lock_dir" ]]; then
            local lock_result_file="${lock_dir}/${cache_key}.result"
            printf '%s\n%s\n%s\n%s\n' "$TV_TMDB" "$TV_IMDB" "$TV_TVDB" "$TV_YEAR" > "$lock_result_file" 2>/dev/null
        fi
        
        # Release the lock now that lookup is complete
        [[ -n "$lock_file" ]] && rm -rf "$lock_file" 2>/dev/null
        should_debug high && print_info "[DEBUG] Released lookup lock for: $cache_key" >&2
        fi  # End of got_lock block
        
        # Store in session cache to avoid redundant lookups for subsequent episodes
        eval "${session_imdb_var}='${TV_IMDB}'"
        eval "${session_tmdb_var}='${TV_TMDB}'"
        eval "${session_tvdb_var}='${TV_TVDB}'"
        eval "${session_year_var}='${TV_YEAR}'"
        should_debug high && print_info "[DEBUG] Saved to session cache: $cache_key" >&2
        
        # Clear the progress line
        echo -ne "\r\033[K" >&2
    fi
    
    # Display TV show poster (only once per series) - works in both auto and interactive modes (if enabled)
    if [[ "$SHOW_SERIES_POSTERS" == "yes" ]]; then
        local series_key="${series_title}${series_year}"
        
        # Check if this is a new series or if we haven't shown the poster yet
        if [[ "$CURRENT_SERIES_NAME" != "$series_key" ]]; then
            # New series detected - reset cache
            CURRENT_SERIES_POSTER_URL=""
            CURRENT_SERIES_POSTER_SHOWN=false
            CURRENT_SERIES_NAME="$series_key"
        fi
        
        # Only fetch and display poster once per series
        if [[ "$CURRENT_SERIES_POSTER_SHOWN" != true ]]; then
            local poster_url=""
            local poster_source=""
            local cache_id="$TV_IMDB"
            local cached_poster_file=""
            
            # Check if poster is already cached on disk (avoid API call)
            if [[ -n "$cache_id" ]]; then
                local resized_file="$TV_POSTER_CACHE_DIR/${cache_id}_resized.jpg"
                local cached_file="$TV_POSTER_CACHE_DIR/${cache_id}.jpg"
                if [[ -f "$resized_file" && -s "$resized_file" ]]; then
                    cached_poster_file="$resized_file"
                    poster_url="cached://${cache_id}"
                    poster_source="disk cache"
                    [[ "$DEBUG_MODE" == "true" ]] && print_info "[DEBUG] Found cached poster: $resized_file" >&2
                elif [[ -f "$cached_file" && -s "$cached_file" ]]; then
                    cached_poster_file="$cached_file"
                    poster_url="cached://${cache_id}"
                    poster_source="disk cache"
                    [[ "$DEBUG_MODE" == "true" ]] && print_info "[DEBUG] Found cached poster: $cached_file" >&2
                fi
            fi
            
            # Only fetch from API if not cached
            if [[ -z "$poster_url" ]]; then
                # Try with TMDb ID if available (most accurate), otherwise use IMDb ID
                if [[ -n "$TV_TMDB" ]]; then
                    [[ "$DEBUG_MODE" == "true" ]] && print_info "[DEBUG] Fetching poster using TMDb ID: $TV_TMDB" >&2
                    poster_url=$(get_tv_poster "" "$TV_TMDB" || true)
                    [[ -n "$poster_url" ]] && poster_source="TMDb"
                elif [[ -n "$TV_IMDB" ]]; then
                    [[ "$DEBUG_MODE" == "true" ]] && print_info "[DEBUG] Fetching poster using IMDb ID: $TV_IMDB" >&2
                    poster_url=$(get_tv_poster "$TV_IMDB" "$TV_TMDB" || true)
                    [[ -n "$poster_url" ]] && poster_source="TMDb (via IMDb)"
                fi
            fi
            [[ "$DEBUG_MODE" == "true" ]] && print_info "[DEBUG] Poster URL: ${poster_url:-not found}" >&2
            
            # Cache the poster URL for subsequent episodes
            CURRENT_SERIES_POSTER_URL="$poster_url"
            
            # Display poster if found
            if [[ -n "$poster_url" ]]; then
                echo "" >&2
                echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}" >&2
                echo -e "${GREEN}📺 ${series_title}${series_year:+ ($series_year)}${NC}" >&2
                [[ -n "$TV_SEASON" && -n "$TV_EPISODE" ]] && echo -e "${CYAN}   Season ${TV_SEASON} Episode ${TV_EPISODE}${TV_EPISODE_TITLE:+: $TV_EPISODE_TITLE}${NC}" >&2
                echo -e "${DIM}   Poster from: ${poster_source} (fetched once, cached for series)${NC}" >&2
                echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}" >&2
                
                # cache_id already set above
                if [[ -n "$cache_id" ]]; then
                    if ! show_poster "$cache_id" "$poster_url" 30 "$TV_POSTER_CACHE_DIR"; then
                        echo -e "${YELLOW}(Poster display unavailable - install 'chafa' for terminal posters)${NC}" >&2
                    fi
                fi
                echo "" >&2
                
                # Mark poster as shown for this series
                CURRENT_SERIES_POSTER_SHOWN=true
            fi
        else
            # Poster already shown for this series, just show episode info without poster
            if [[ -n "$CURRENT_SERIES_POSTER_URL" ]]; then
                echo "" >&2
                echo -e "${DIM}📺 ${series_title}${series_year:+ ($series_year)} - Season ${TV_SEASON} Episode ${TV_EPISODE}${TV_EPISODE_TITLE:+: $TV_EPISODE_TITLE}${NC}" >&2
                echo -e "${DIM}   (Using cached poster from first episode)${NC}" >&2
                echo "" >&2
            fi
        fi
    fi
    
    # Allow manual entry/correction
    if [[ "$auto_mode" != "y" ]]; then
        if [[ -z "$TV_IMDB" && -z "$TV_TMDB" && -z "$TV_TVDB" ]]; then
            echo "" >&2
            echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}" >&2
            print_warning "⚠  Could not find IDs for TV show: $series_title${series_year:+ ($series_year)}" >&2
            echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}" >&2
            echo "" >&2
            echo -e "${YELLOW}Find IDs at:${NC}" >&2
            echo -e "  ${DIM}TMDb: https://www.themoviedb.org/tv/${NC}" >&2
            echo -e "  ${DIM}TVDb: https://www.thetvdb.com/${NC}" >&2
            echo -e "  ${DIM}IMDb: https://www.imdb.com/${NC}" >&2
            echo "" >&2
        fi
        
        print_info "IMDb ID [${TV_IMDB}]:"
        read -r input
        [[ -n "$input" ]] && TV_IMDB="$input"
        
        print_info "TMDb ID [${TV_TMDB}]:"
        read -r input
        [[ -n "$input" ]] && TV_TMDB="$input"
        
        print_info "TVDb ID [${TV_TVDB}]:"
        read -r input
        [[ -n "$input" ]] && TV_TVDB="$input"
        
        # Allow year entry if still missing
        if [[ -z "$series_year" ]]; then
            print_info "Series Year (for folder naming) [${series_year}]:"
            read -r input
            if [[ -n "$input" ]]; then
                series_year="$input"
                TV_YEAR="$series_year"
            fi
        fi
    else
        # Auto mode - fail if no IDs found (same behavior as movies)
        if [[ -z "$TV_IMDB" && -z "$TV_TMDB" && -z "$TV_TVDB" ]]; then
            echo "" >&2
            echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}" >&2
            print_error "⚠  Cannot auto-process: No IDs found for $series_title${series_year:+ ($series_year)}" >&2
            echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}" >&2
            echo "" >&2
            echo -e "${CYAN}To manually add this TV show to cache:${NC}" >&2
            echo "" >&2
            echo -e "  ${GREEN}1) Find IMDb ID:${NC} ${DIM}https://www.imdb.com/${NC}" >&2
            echo -e "     ${DIM}Search for \"${series_title}${series_year:+ $series_year}\" and copy tt####### from URL${NC}" >&2
            echo "" >&2
            echo -e "  ${GREEN}2) Find TMDb ID:${NC} ${DIM}https://www.themoviedb.org/tv/${NC}" >&2
            echo -e "     ${DIM}Search for \"${series_title}${series_year:+ $series_year}\" and copy number from URL${NC}" >&2
            echo "" >&2
            echo -e "  ${GREEN}3) Find TVDb ID:${NC} ${DIM}https://www.thetvdb.com/${NC}" >&2
            echo -e "     ${DIM}Search for \"${series_title}${series_year:+ $series_year}\" and copy number from URL${NC}" >&2
            echo "" >&2
            echo -e "  ${GREEN}4) Add to cache file:${NC}" >&2
            echo -e "     ${DIM}nano ${TV_CACHE_FILE}${NC}" >&2
            echo "" >&2
            echo -e "  ${YELLOW}Format:${NC}" >&2
            echo -e "     ${DIM}${series_title}|${series_year}|tt1234567|12345|67890|$(date +%s)${NC}" >&2
            echo "" >&2
            echo -e "${CYAN}Then re-run the script to process this episode.${NC}" >&2
            echo "" >&2
            release_file_lock "$source_file"
            return 1
        fi
    fi
    
    # Try to fetch episode title - always try TMDb first when available, fall back to filename
    # If we have IMDb but not TMDb, try to get TMDb ID first
    if [[ -z "$TV_TMDB" && -n "$TV_IMDB" && -n "$TV_SEASON" && -n "$TV_EPISODE" ]]; then
        should_debug high && print_info "[DEBUG] No TMDb ID but have IMDb ID - looking up TMDb ID for episode title fetch..." >&2
        # Try to get TMDb ID from IMDb ID
        local found_tmdb=$(get_tmdb_from_imdb_tv "$TV_IMDB")
        if [[ -n "$found_tmdb" ]]; then
            TV_TMDB="$found_tmdb"
            should_debug high && print_info "[DEBUG] Found TMDb ID from IMDb: $TV_TMDB" >&2
            # Update cache with TMDb ID
            save_tvshow_to_cache "$series_title" "$series_year" "$TV_IMDB" "$TV_TMDB" "$TV_TVDB"
        fi
    fi
    
    if [[ -n "$TV_TMDB" && -n "$TV_SEASON" && -n "$TV_EPISODE" ]]; then
        # Save the parsed title as fallback before attempting TMDb fetch
        local parsed_title="$TV_EPISODE_TITLE"
        
        # Determine cache category based on TV_CACHE_MODE
        local cache_category="tv"
        case "$TV_CACHE_MODE" in
            anime) cache_category="anime" ;;
            cartoons) cache_category="cartoon" ;;
        esac
        
        # Check episode cache first
        # Use canonical title from main cache for episode cache (avoids duplicates like "Series REPACK" vs "Series")
        local canonical_series_title="$series_title"
        if [[ -n "$TV_IMDB" ]]; then
            # Look up canonical title from main cache by IMDb ID
            local cache_line=$(grep "|${TV_IMDB}|" "$TV_CACHE_FILE" 2>/dev/null | head -1)
            if [[ -n "$cache_line" ]]; then
                local cached_title=$(echo "$cache_line" | cut -d'|' -f1)
                [[ -n "$cached_title" ]] && canonical_series_title="$cached_title"
            fi
        fi
        local episode_cache_file=$(get_episode_cache_file "$canonical_series_title" "$TV_IMDB" "$cache_category")
        local cached_episode=$(get_cached_episode "$episode_cache_file" "$TV_SEASON" "$TV_EPISODE")
        
        if [[ -n "$cached_episode" ]]; then
            # Extract episode title from cache
            TV_EPISODE_TITLE=$(extract_from_episode_cache "$cached_episode" "title")
            [[ "$DEBUG_MODE" == "true" ]] && print_success "[DEBUG] Using cached episode title: $TV_EPISODE_TITLE" >&2
        else
            # Not in cache - always try to fetch canonical title from TMDb API first
            should_debug high && print_info "[DEBUG] Fetching canonical episode title from TMDb (ID: $TV_TMDB, S${TV_SEASON}E${TV_EPISODE})..." >&2
            local tmdb_title=$(get_episode_title_from_tmdb "$TV_TMDB" "$TV_SEASON" "$TV_EPISODE")
            if [[ -n "$tmdb_title" ]]; then
                # Check if filename has multi-segment title (contains commas) but TMDb only has single segment
                # For shows like Animaniacs with multiple shorts per episode, prefer the full filename title
                if [[ "$parsed_title" =~ , && ! "$tmdb_title" =~ , ]]; then
                    # Filename has multiple segments (e.g., "Deduces Wild, Rest in Pieces, and UN Me")
                    # but TMDb only has one (e.g., "Deduces Wild") - use filename version
                    TV_EPISODE_TITLE="$parsed_title"
                    [[ "$DEBUG_MODE_TV" == "true" ]] && print_info "[DEBUG] Using multi-segment filename title instead of TMDb single-segment: $TV_EPISODE_TITLE" >&2
                else
                    # Use TMDb title (normal case)
                    TV_EPISODE_TITLE="$tmdb_title"
                    [[ "$DEBUG_MODE_TV" == "true" ]] && print_success "[DEBUG] Got canonical episode title from TMDb: $TV_EPISODE_TITLE" >&2
                fi
                
                # Save to episode cache
                save_episode_to_cache "$episode_cache_file" "$TV_SEASON" "$TV_EPISODE" "$TV_EPISODE_TITLE" "" "$TV_IMDB" "$TV_TMDB" "$TV_TVDB"
                should_debug high && print_info "[DEBUG] Saved episode to cache" >&2
            else
                [[ "$DEBUG_MODE_TV" == "true" ]] && print_warning "[DEBUG] TMDb returned empty title for S${TV_SEASON}E${TV_EPISODE}" >&2
                # Fallback to parsed title from filename if TMDb fetch failed
                if [[ -n "$parsed_title" ]]; then
                    TV_EPISODE_TITLE="$parsed_title"
                    should_debug high && print_info "[DEBUG] Using parsed title from filename as fallback: $TV_EPISODE_TITLE" >&2
                elif [[ "$auto_mode" != "y" ]]; then
                    print_warning "⚠ Could not fetch episode title from TMDb for S${TV_SEASON}E${TV_EPISODE} and no title found in filename"
                fi
            fi
        fi
    else
        [[ "$DEBUG_MODE" == "true" ]] && print_warning "[DEBUG] Cannot fetch episode title - missing: TV_TMDB='$TV_TMDB' TV_SEASON='$TV_SEASON' TV_EPISODE='$TV_EPISODE'" >&2
    fi
    
    # Allow episode title input/correction
    if [[ "$auto_mode" != "y" ]]; then
        print_info "Episode Title [${TV_EPISODE_TITLE}]:"
        read -r input
        [[ -n "$input" ]] && TV_EPISODE_TITLE="$input"
    fi
    
    # Get official series title and year from TMDb API (use this instead of parsed filename)
    # Use file-based cache to avoid redundant API calls for same series (works with parallel processing)
    if [[ -n "$TV_TMDB" ]]; then
        local canon_cache_file="${CACHE_DIR}/.canon_${TV_TMDB}.tmp"
        local cached_canon_title=""
        local cached_canon_year=""
        
        # Check file cache first (survives across parallel subshells)
        if [[ -f "$canon_cache_file" ]]; then
            cached_canon_title=$(sed -n '1p' "$canon_cache_file" 2>/dev/null)
            cached_canon_year=$(sed -n '2p' "$canon_cache_file" 2>/dev/null)
        fi
        
        if [[ -n "$cached_canon_title" ]]; then
            series_title="$cached_canon_title"
            should_debug high && print_info "[DEBUG] Using cached canonical title: $series_title" >&2
        else
            local tmdb_series_title=$(get_tmdb_tv_title "$TV_TMDB")
            if [[ -n "$tmdb_series_title" ]]; then
                series_title="$tmdb_series_title"
                should_debug high && print_info "[DEBUG] Using official title from TMDb: $series_title" >&2
            fi
        fi
        
        if [[ -n "$cached_canon_year" ]]; then
            series_year="$cached_canon_year"
            TV_YEAR="$series_year"
            should_debug high && print_info "[DEBUG] Using cached canonical year: $series_year" >&2
        else
            local tmdb_series_year=$(get_tv_year_from_tmdb "$TV_TMDB")
            if [[ -n "$tmdb_series_year" ]]; then
                series_year="$tmdb_series_year"
                TV_YEAR="$tmdb_series_year"
                should_debug high && print_info "[DEBUG] Using official year from TMDb: $series_year" >&2
            fi
        fi
        
        # Save to file cache if we fetched new values (atomic write)
        if [[ -z "$cached_canon_title" && -n "$series_title" ]] || [[ -z "$cached_canon_year" && -n "$series_year" ]]; then
            printf '%s\n%s\n' "$series_title" "$series_year" > "$canon_cache_file" 2>/dev/null
        fi
    fi
    
    # Build TV show directory structure
    local ext="${source_file##*.}"
    local clean_series=$(echo "$series_title" | sed 's/[:<>"|?*]//g' | sed 's/\//\-/g')
    # Remove any existing year from series title (with or without parentheses/brackets, with or without dashes)
    clean_series=$(echo "$clean_series" | sed -E 's/[[:space:]]*-?[[:space:]]*[\(\[]?[0-9]{4}(-[0-9]{4})?[\)\]]?[[:space:]]*$//' | sed 's/  */ /g' | sed 's/^ //;s/ $//')
    # Remove trailing dashes/separators after year removal
    clean_series=$(echo "$clean_series" | sed -E 's/[[:space:]]*[-—_]+[[:space:]]*$//')
    
    # Build series folder name based on selected TV naming scheme
    local series_folder
    case "$TV_NAMING_FOLDER" in
        0) series_folder="${clean_series}${series_year:+ ($series_year)}" ;;  # Standard
        1) # Plex (IMDb)
            series_folder="${clean_series}${series_year:+ ($series_year)}"
            [[ -n "$TV_IMDB" ]] && series_folder="${series_folder} {imdb-${TV_IMDB}}"
            ;;
        2) # Plex (TMDb)
            series_folder="${clean_series}${series_year:+ ($series_year)}"
            [[ -n "$TV_TMDB" ]] && series_folder="${series_folder} {tmdb-${TV_TMDB}}"
            ;;
        3) # Plex (TVDb)
            series_folder="${clean_series}${series_year:+ ($series_year)}"
            [[ -n "$TV_TVDB" ]] && series_folder="${series_folder} {tvdb-${TV_TVDB}}"
            ;;
        4) # Emby (IMDb)
            series_folder="${clean_series}${series_year:+ ($series_year)}"
            [[ -n "$TV_IMDB" ]] && series_folder="${series_folder} [imdb-${TV_IMDB}]"
            ;;
        5) # Emby (TMDb)
            series_folder="${clean_series}${series_year:+ ($series_year)}"
            [[ -n "$TV_TMDB" ]] && series_folder="${series_folder} [tmdb-${TV_TMDB}]"
            ;;
        6) # Emby (TVDb)
            series_folder="${clean_series}${series_year:+ ($series_year)}"
            [[ -n "$TV_TVDB" ]] && series_folder="${series_folder} [tvdb-${TV_TVDB}]"
            ;;
        7) # Jellyfin (TVDb)
            series_folder="${clean_series}${series_year:+ ($series_year)}"
            [[ -n "$TV_TVDB" ]] && series_folder="${series_folder} [tvdbid-${TV_TVDB}]"
            ;;
        8) # Jellyfin (IMDb)
            series_folder="${clean_series}${series_year:+ ($series_year)}"
            [[ -n "$TV_IMDB" ]] && series_folder="${series_folder} [imdb-${TV_IMDB}]"
            ;;
        9) # Jellyfin (TMDb)
            series_folder="${clean_series}${series_year:+ ($series_year)}"
            [[ -n "$TV_TMDB" ]] && series_folder="${series_folder} [tmdbid-${TV_TMDB}]"
            ;;
        *) series_folder="${clean_series}${series_year:+ ($series_year)}" ;;  # Default to Standard
    esac
    
    # Debug: Show metadata found with detailed reasons for missing IDs
    if [[ "$auto_mode" != "y" ]]; then
        if [[ -n "$TV_IMDB" ]]; then
            print_success "IMDb ID: $TV_IMDB"
        else
            print_warning "IMDb ID: Not found (IMDb search returned no results)"
        fi
        
        if [[ -n "$TV_TMDB" ]]; then
            print_success "TMDb ID: $TV_TMDB"
        else
            if [[ -n "$TV_IMDB" ]]; then
                print_warning "TMDb ID: Not found (TMDb /find and search returned no results, IMDb ID not linked in TMDb database)"
            else
                print_warning "TMDb ID: Not found (TMDb search returned no results)"
            fi
        fi
        
        if [[ -n "$TV_TVDB" ]]; then
            print_success "TVDb ID: $TV_TVDB"
        else
            print_warning "TVDb ID: Not found (TVDb search returned no results)"
        fi
    fi
    
    # Build season folder (zero-padded)
    local season_folder="Season $(printf "%02d" $TV_SEASON)"
    local tv_folder="${DESTINATION}/${series_folder}/${season_folder}"
    
    # Build episode filename based on selected TV naming scheme AND TV_RENAME_EPISODES preference
    local episode_filename
    
    # If user chose not to rename episodes, use original filename
    if [[ "$TV_RENAME_EPISODES" == "false" ]]; then
        # Extract just the base filename without path and extension
        local original_basename=$(basename "$source_file")
        episode_filename="${original_basename%.*}"
    else
        # User wants to rename episodes - build filename according to TV_NAMING_EPISODE scheme
        should_debug medium && echo "[DEBUG] TV_EPISODE_TITLE before cleaning: '$TV_EPISODE_TITLE'" >&2
        # Strip bracketed release tags and torrent IDs from episode title (e.g., [HKN][6332C099])
        # Remove patterns like [word][hexcode] or [word][numbers] at the end
        TV_EPISODE_TITLE=$(echo "$TV_EPISODE_TITLE" | sed -E 's/[[:space:]]*-?\[([A-Za-z0-9]+)\]\[([A-Fa-f0-9]+)\][[:space:]]*$//')
        # Also strip single bracketed codes at end (just in case)
        TV_EPISODE_TITLE=$(echo "$TV_EPISODE_TITLE" | sed -E 's/[[:space:]]*-?\[([A-Fa-f0-9]{6,})\][[:space:]]*$//')
        local clean_ep_title=$(echo "$TV_EPISODE_TITLE" | sed 's/[:<>"|?*]//g' | sed 's/\//\-/g' | cut -c 1-90)
        should_debug medium && echo "[DEBUG] clean_ep_title after sed/cut: '$clean_ep_title'" >&2
        # Convert episode title to title case
        clean_ep_title=$(echo "$clean_ep_title" | awk '{for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1)) tolower(substr($i,2))}1')
        should_debug medium && echo "[DEBUG] clean_ep_title after title case: '$clean_ep_title'" >&2
        
        # Format episode number(s)
        local ep_num=$(printf "S%02dE%02d" $TV_SEASON $TV_EPISODE)
        if [[ -n "$TV_EPISODE_END" ]]; then
            ep_num="${ep_num}-E$(printf "%02d" $TV_EPISODE_END)"
        fi
    
    # Base filename structure (TRaSH guides format)
    # Format: {Series TitleYear} - S##E## - {Episode Title}
    # All formats include series name and year in filename
    
    # Auto-detect if we should use standard format instead of anime format
    # Some anime shows have mixed formats (both absolute and season/episode numbering)
    local use_standard_format="false"
    if [[ "$TV_NAMING_EPISODE" == "2" ]]; then
        # Check if source filename has explicit season/episode pattern
        local source_basename=$(basename "$source_file")
        if [[ "$source_basename" =~ [Ss][0-9]{1,2}[Ee][0-9]{1,2}|[0-9]{1,2}x[0-9]{1,2} ]]; then
            # Source file explicitly uses S##E## or #x## format, use standard naming
            use_standard_format="true"
            should_debug low && echo "[DEBUG] Anime format override: Source has S##E## pattern, using standard format" >&2
        fi
    fi
    
    case "$TV_NAMING_EPISODE" in
        0)  # Standard format: Series (Year) - S##E## - Episode Title
            episode_filename="${clean_series}${series_year:+ ($series_year)} - ${ep_num}"
            [[ -n "$clean_ep_title" ]] && episode_filename="${episode_filename} - ${clean_ep_title}"
            ;;
        1)  # Daily format: Series (Year) - YYYY-MM-DD - Episode Title
            if [[ -n "$TV_AIR_DATE" ]]; then
                episode_filename="${clean_series}${series_year:+ ($series_year)} - ${TV_AIR_DATE}"
            else
                episode_filename="${clean_series}${series_year:+ ($series_year)} - ${ep_num}"
            fi
            [[ -n "$clean_ep_title" ]] && episode_filename="${episode_filename} - ${clean_ep_title}"
            ;;
        2)  # Anime format: Series (Year) - S##E## - ### - Episode Title
            if [[ "$use_standard_format" == "true" ]]; then
                # Use standard format for this episode (has explicit season/episode numbering)
                episode_filename="${clean_series}${series_year:+ ($series_year)} - ${ep_num}"
                [[ -n "$clean_ep_title" ]] && episode_filename="${episode_filename} - ${clean_ep_title}"
            else
                # Use anime format with absolute numbering
                episode_filename="${clean_series}${series_year:+ ($series_year)} - ${ep_num}"
                # Add absolute episode number for anime
                if [[ -n "$TV_ABSOLUTE" ]]; then
                    episode_filename="${episode_filename} - $(printf "%03d" $TV_ABSOLUTE)"
                fi
                [[ -n "$clean_ep_title" ]] && episode_filename="${episode_filename} - ${clean_ep_title}"
            fi
            ;;
        *)  # Fallback to standard
            episode_filename="${clean_series}${series_year:+ ($series_year)} - ${ep_num}"
            [[ -n "$clean_ep_title" ]] && episode_filename="${episode_filename} - ${clean_ep_title}"
            ;;
    esac
    
    # Add quality and metadata tags (TrashGuides format)
    # Standard/Daily: [Quality][HDR][Audio][Video]-Group
    # Anime: [Quality][HDR][BitDepth][Video][Audio][Language]-Group
    
    # Custom formats (if available)
    [[ -n "$PARSED_CUSTOM_FORMAT" ]] && episode_filename="${episode_filename} [${PARSED_CUSTOM_FORMAT}]"
    
    # Quality Full (source + resolution) - skip if already in custom format
    if [[ -z "$PARSED_CUSTOM_FORMAT" && -n "$PARSED_FULL_QUALITY" ]]; then
        episode_filename="${episode_filename} [${PARSED_FULL_QUALITY}]"
    fi
    
    # HDR/Dynamic Range (comes after quality for ALL formats)
    [[ -n "$PARSED_HDR" ]] && episode_filename="${episode_filename} [${PARSED_HDR}]"
    
    # Bit depth (anime only, after HDR, in separate bracket)
    if [[ "$TV_NAMING_EPISODE" == "2" ]]; then
        local bit_depth="$PARSED_BIT_DEPTH"
        if [[ -z "$bit_depth" ]]; then
            if [[ "$(basename "$source_file")" =~ 10bit|10-bit ]]; then
                bit_depth="10bit"
            elif [[ "$(basename "$source_file")" =~ 8bit|8-bit ]]; then
                bit_depth="8bit"
            fi
        fi
        [[ -n "$bit_depth" ]] && episode_filename="${episode_filename} [${bit_depth}]"
    fi
    
    # Video codec (after HDR for standard/daily, after bit depth for anime)
    [[ -n "$PARSED_VIDEO_CODEC" ]] && episode_filename="${episode_filename} [${PARSED_VIDEO_CODEC}]"
    
    # Audio codec and channels (after video for ALL formats)
    if [[ -n "$PARSED_AUDIO_CODEC" && -n "$PARSED_AUDIO_CHANNELS" ]]; then
        episode_filename="${episode_filename} [${PARSED_AUDIO_CODEC} ${PARSED_AUDIO_CHANNELS}]"
    elif [[ -n "$PARSED_AUDIO_CODEC" ]]; then
        episode_filename="${episode_filename} [${PARSED_AUDIO_CODEC}]"
    fi
    
    # Audio language (anime only, after audio codec)
    if [[ "$TV_NAMING_EPISODE" == "2" && -n "$PARSED_AUDIO_LANGUAGE" ]]; then
        episode_filename="${episode_filename} [${PARSED_AUDIO_LANGUAGE}]"
    fi
    
    # Release group (with dash separator)
    [[ -n "$PARSED_RELEASE_GROUP" ]] && episode_filename="${episode_filename}-${PARSED_RELEASE_GROUP}"
    
    fi  # End of TV_RENAME_EPISODES conditional
    
    local dest_file="${tv_folder}/${episode_filename}.${ext}"
    
    # Create directory structure
    mkdir -p "$tv_folder"
    
    # Get source inode for tracking
    local source_inode=$(stat -f "%i" "$source_file" 2>/dev/null || stat -c "%i" "$source_file" 2>/dev/null)
    
    # Check if this source file was already processed in this script run
    if [[ " $PROCESSED_FILES " =~ " $source_inode " ]]; then
        # File already processed (likely an extra with episode pattern) - silently skip
        release_file_lock "$source_file"
        return 0
    fi
    
    # Check for existing hardlinks in destination
    
    # First check if the exact destination file already exists and is hardlinked
    if [[ -f "$dest_file" ]]; then
        local dest_inode=$(stat -f "%i" "$dest_file" 2>/dev/null || stat -c "%i" "$dest_file" 2>/dev/null)
        if [[ "$source_inode" == "$dest_inode" ]]; then
            print_warning "Hardlink already exists: $(basename "$dest_file")"
            release_file_lock "$source_file"
            return 0
        else
            # File exists but is not hardlinked - skip to avoid overwriting
            print_warning "File already exists (not hardlinked): $(basename "$dest_file")"
            release_file_lock "$source_file"
            return 0
        fi
    fi
    
    # Check for other hardlinks with different names in same folder
    shopt -s nullglob
    for existing in "$tv_folder"/*."$ext"; do
        [[ -f "$existing" ]] || continue
        [[ "$existing" == "$dest_file" ]] && continue  # Skip the destination file we already checked
        local existing_inode=$(stat -f "%i" "$existing" 2>/dev/null || stat -c "%i" "$existing" 2>/dev/null)
        if [[ "$source_inode" == "$existing_inode" ]]; then
            print_warning "Hardlink already exists with different name: $(basename "$existing")"
            shopt -u nullglob
            release_file_lock "$source_file"
            return 0
        fi
    done
    shopt -u nullglob
    
    # Create hardlink, symlink, or copy (using same logic as movies)
    [[ "$DEBUG_MODE" == "true" ]] && print_info "[DEBUG] Creating link: USE_COPY=$USE_COPY, USE_SYMLINK=$USE_SYMLINK" >&2
    [[ "$DEBUG_MODE" == "true" ]] && print_info "[DEBUG] Source: $source_file" >&2
    [[ "$DEBUG_MODE" == "true" ]] && print_info "[DEBUG] Dest: $dest_file" >&2
    local link_success=false
    if $USE_COPY; then
        if cp "$source_file" "$dest_file" 2>/dev/null; then
            print_success "✓ Copied: $(basename "$dest_file")"
            link_success=true
        else
            print_error "Failed to copy file"
            release_file_lock "$source_file"
            return 1
        fi
    elif $USE_SYMLINK; then
        if ln -s "$source_file" "$dest_file" 2>/dev/null; then
            print_success "✓ Symlinked: $(basename "$dest_file")"
            link_success=true
        else
            print_error "Failed to create symlink"
            release_file_lock "$source_file"
            return 1
        fi
    else
        # Try hardlink with fallback on failure
        if ! ln "$source_file" "$dest_file" 2>/dev/null; then
            print_error "Hardlink failed (files may be on different volumes/filesystems)"
            
            # In auto mode, skip interactive prompts and just fail silently
            if [[ "$auto_mode" == "y" ]]; then
                print_warning "⚠ Skipping file in auto mode - hardlink not possible"
                return 1
            fi
            
            # Interactive mode: offer fallback options
            echo ""
            echo -e "${YELLOW}Choose action:${NC}"
            echo -e "  ${GREEN}1)${NC} Create symbolic link instead"
            echo -e "  ${GREEN}2)${NC} Copy file instead"
            echo -e "  ${GREEN}3)${NC} Skip this file"
            echo -e "  ${GREEN}4)${NC} Cancel all processing"
            echo ""
            
            while true; do
                read -p "$(echo -e ${CYAN}Select option [1-4]:${NC} )" fallback_choice
                case "$fallback_choice" in
                    1)
                        if ln -s "$source_file" "$dest_file" 2>/dev/null; then
                            print_success "✓ Symlinked: $(basename "$dest_file")"
                            link_success=true
                        else
                            print_error "Failed to create symlink"
                            release_file_lock "$source_file"
                            return 1
                        fi
                        break
                        ;;
                    2)
                        if cp "$source_file" "$dest_file" 2>/dev/null; then
                            print_success "✓ Copied: $(basename "$dest_file")"
                            link_success=true
                        else
                            print_error "Failed to copy file"
                            release_file_lock "$source_file"
                            return 1
                        fi
                        break
                        ;;
                    3)
                        print_warning "Skipped file"
                        release_file_lock "$source_file"
                        return 1
                        ;;
                    4)
                        print_error "Processing cancelled by user"
                        release_file_lock "$source_file"
                        exit 1
                        ;;
                    *)
                        print_error "Invalid option. Please choose 1, 2, 3, or 4."
                        ;;
                esac
            done
        else
            print_success "✓ Hardlinked: $(basename "$dest_file")"
            link_success=true
        fi
    fi
    
    # Mark this source file as processed if successfully linked
    if $link_success; then
        PROCESSED_FILES="$PROCESSED_FILES $source_inode"
        # Release lock after successful processing
        release_file_lock "$source_file"
    else
        # Release lock if processing failed
        release_file_lock "$source_file"
    fi
    
    # Helper function to check if two files are effectively identical (for copy mode)
    files_are_identical() {
        local file1="$1"
        local file2="$2"
        
        [[ ! -f "$file1" ]] || [[ ! -f "$file2" ]] && return 1
        
        # Compare file sizes
        local size1=$(stat -f "%z" "$file1" 2>/dev/null || stat -c "%s" "$file1" 2>/dev/null)
        local size2=$(stat -f "%z" "$file2" 2>/dev/null || stat -c "%s" "$file2" 2>/dev/null)
        
        [[ "$size1" == "$size2" ]] && return 0
        return 1
    }
    
    # If video file was successfully linked OR already exists, process subtitle files
    # Check if destination file exists (whether we just created it or it was already there)
    local should_process_subtitles=false
    if $link_success; then
        should_process_subtitles=true
    elif [[ -f "$dest_file" ]]; then
        # Check if existing file is hardlinked to source
        local dest_inode=$(stat -f "%i" "$dest_file" 2>/dev/null || stat -c "%i" "$dest_file" 2>/dev/null)
        if [[ "$source_inode" == "$dest_inode" ]]; then
            should_process_subtitles=true
        fi
    fi
    
    if $should_process_subtitles; then
        local source_dir=$(dirname "$source_file")
        local subtitle_count=0
        
        # Track processed subtitle files to avoid double-counting (Bash 3.2 compatible)
        local processed_subtitles=""
        
        # Get the source video filename without extension for matching subtitles
        local source_video_basename=$(basename "$source_file")
        local source_video_name="${source_video_basename%.*}"
        
        # Find and hardlink subtitle files that match the video filename
        while IFS= read -r -d '' subtitle_file; do
            should_debug low && echo "[DEBUG] Found same-dir subtitle: $(basename "$subtitle_file")" >&2
            # Skip if already processed (Bash 3.2 compatible)
            if [[ "$processed_subtitles" == *"|$subtitle_file|"* ]]; then
                continue
            fi
            processed_subtitles="$processed_subtitles|$subtitle_file|"
            
            local sub_basename=$(basename "$subtitle_file")
            local sub_name_no_ext="${sub_basename%.*}"
            
            # Filter out files that don't have a clear episode number pattern
            # Require S##E## or similar TV episode pattern, or Origins/Specials E## pattern in subtitle filename
            if ! [[ "$sub_basename" =~ [Ss][0-9]{1,2}[Ee][0-9]{1,3}|[Ss][0-9]{1,2}[[:space:]]+[Ee][0-9]{1,3}|[0-9]{1,2}x[0-9]{1,3}|[Oo]rigins[[:space:]]+[Ee][0-9]{1,3}|[Ss]pecials?[[:space:]]+[Ee][0-9]{1,3} ]]; then
                continue
            fi
            
            # Remove any language/type suffixes to get base subtitle name for matching
            # e.g., "Show.S01E01.en.srt" -> "Show.S01E01" for comparison with "Show.S01E01.mkv"
            local sub_base_for_match="$sub_name_no_ext"
            # Strip common subtitle suffixes: .en, .eng, .forced, .sdh, etc.
            sub_base_for_match=$(echo "$sub_base_for_match" | sed -E 's/\.(en|eng|es|spa|fr|fra|de|deu|ger|ja|jpn|ko|kor|zh|chi|pt|por|it|ita|ru|rus|ar|ara|hi|hin|[a-z]{2,3})$//i')
            sub_base_for_match=$(echo "$sub_base_for_match" | sed -E 's/\.(forced|sdh|cc|commentary|hearing.?impaired|hi)$//i')
            # Strip again in case there was lang.type pattern
            sub_base_for_match=$(echo "$sub_base_for_match" | sed -E 's/\.(en|eng|es|spa|fr|fra|de|deu|ger|ja|jpn|ko|kor|zh|chi|pt|por|it|ita|ru|rus|ar|ara|hi|hin|[a-z]{2,3})$//i')
            
            # Only process this subtitle if it matches the video filename
            if [[ "$sub_base_for_match" != "$source_video_name" ]]; then
                continue
            fi
            
            local sub_ext="${sub_basename##*.}"
            
            # Create new subtitle filename matching the episode file (without extension)
            local new_sub_name="${episode_filename}"
            
            # Preserve language code if present (e.g., .en.srt, .eng.srt, .ja.ass)
            if [[ $sub_basename =~ \.([a-z]{2,3})\.(srt|sub|idx|ass|ssa)$ ]]; then
                local lang_code="${BASH_REMATCH[1]}"
                new_sub_name="${new_sub_name}.${lang_code}.${sub_ext}"
            # Preserve subtitle type if present (e.g., .forced.srt, .commentary.srt)
            elif [[ $sub_basename =~ \.(forced|sdh|cc|commentary)\.(srt|sub|idx|ass|ssa)$ ]]; then
                local sub_type="${BASH_REMATCH[1]}"
                new_sub_name="${new_sub_name}.${sub_type}.${sub_ext}"
            # Preserve both language and type (e.g., .en.forced.srt, .ja.commentary.ass)
            elif [[ $sub_basename =~ \.([a-z]{2,3})\.(forced|sdh|cc|commentary)\.(srt|sub|idx|ass|ssa)$ ]]; then
                local lang_code="${BASH_REMATCH[1]}"
                local sub_type="${BASH_REMATCH[2]}"
                new_sub_name="${new_sub_name}.${lang_code}.${sub_type}.${sub_ext}"
            else
                new_sub_name="${new_sub_name}.${sub_ext}"
            fi
            
            local dest_subtitle="${tv_folder}/${new_sub_name}"
            
            # Check if subtitle already exists and is hardlinked
            if [[ -f "$dest_subtitle" ]]; then
                local source_inode=$(stat -f "%i" "$subtitle_file" 2>/dev/null || stat -c "%i" "$subtitle_file" 2>/dev/null)
                local dest_inode=$(stat -f "%i" "$dest_subtitle" 2>/dev/null || stat -c "%i" "$dest_subtitle" 2>/dev/null)
                
                if [[ "$source_inode" != "$dest_inode" ]]; then
                    rm "$dest_subtitle"
                    if $USE_COPY; then
                        cp "$subtitle_file" "$dest_subtitle"
                    elif $USE_SYMLINK; then
                        ln -s "$subtitle_file" "$dest_subtitle"
                    else
                        ln "$subtitle_file" "$dest_subtitle" 2>/dev/null || cp "$subtitle_file" "$dest_subtitle"
                    fi
                    ((subtitle_count++))
                    should_debug low && echo "[DEBUG] Same-dir subtitle linked: $(basename "$dest_subtitle") (count: $subtitle_count)" >&2
                fi
            else
                if $USE_COPY; then
                    cp "$subtitle_file" "$dest_subtitle"
                elif $USE_SYMLINK; then
                    ln -s "$subtitle_file" "$dest_subtitle"
                else
                    ln "$subtitle_file" "$dest_subtitle" 2>/dev/null || cp "$subtitle_file" "$dest_subtitle"
                fi
                ((subtitle_count++))
                should_debug low && echo "[DEBUG] Same-dir subtitle linked: $(basename "$dest_subtitle") (count: $subtitle_count)" >&2
            fi
        done < <(find "$source_dir" -maxdepth 1 -type f \( -iname "*.srt" -o -iname "*.sub" -o -iname "*.idx" -o -iname "*.ass" -o -iname "*.ssa" \) -print0)
        
        # Check for Subs folder in parent directory (season-level subs)
        local parent_dir=$(dirname "$source_dir")
        local season_subs_dir=""
        
        # Look for Subs folders with various naming patterns
        if [[ -d "$parent_dir/Subs" ]]; then
            season_subs_dir="$parent_dir/Subs"
        elif [[ -d "$parent_dir/Subtitles" ]]; then
            season_subs_dir="$parent_dir/Subtitles"
        elif [[ -d "$parent_dir/Subs-Multi Languages" ]]; then
            season_subs_dir="$parent_dir/Subs-Multi Languages"
        elif [[ -d "$parent_dir/Lang" ]]; then
            season_subs_dir="$parent_dir/Lang"
        elif [[ -d "$parent_dir/Language" ]]; then
            season_subs_dir="$parent_dir/Language"
        elif [[ -d "$parent_dir/Languages" ]]; then
            season_subs_dir="$parent_dir/Languages"
        elif [[ -d "$source_dir/Subs" ]]; then
            season_subs_dir="$source_dir/Subs"
        elif [[ -d "$source_dir/Subtitles" ]]; then
            season_subs_dir="$source_dir/Subtitles"
        elif [[ -d "$source_dir/Lang" ]]; then
            season_subs_dir="$source_dir/Lang"
        elif [[ -d "$source_dir/Language" ]]; then
            season_subs_dir="$source_dir/Language"
        elif [[ -d "$source_dir/Languages" ]]; then
            season_subs_dir="$source_dir/Languages"
        fi
        
        # Also check for subtitles in the identified Subs folder (if it exists)
        # BUT ONLY if there are no episode-specific subfolders (to avoid double-processing)
        if [[ -n "$season_subs_dir" && -d "$season_subs_dir" ]]; then
            # Check if there are episode-specific subfolders in the Subs directory
            local has_episode_subfolders=false
            if [[ -n "$TV_SEASON" ]] && [[ -n "$TV_EPISODE" ]]; then
                local season_padded=$(printf "%02d" "$TV_SEASON")
                local episode_padded=$(printf "%02d" "$TV_EPISODE")
                
                # Check if any episode-specific subfolders exist
                while IFS= read -r -d '' episode_subfolder; do
                    has_episode_subfolders=true
                    break
                done < <(find "$season_subs_dir" -mindepth 1 -maxdepth 1 -type d -print0 2>/dev/null)
            fi
            
            # Only process direct subtitle files if there are NO episode subfolders
            if [[ "$has_episode_subfolders" == "false" ]]; then
                should_debug low && echo "[DEBUG] Processing direct subtitle files in season subs directory (no episode subfolders found)" >&2
                while IFS= read -r -d '' subtitle_subfile; do
                # Skip if already processed (Bash 3.2 compatible)
                if [[ "$processed_subtitles" == *"|$subtitle_subfile|"* ]]; then
                    continue
                fi
                processed_subtitles="$processed_subtitles|$subtitle_subfile|"
                
                local sub_basename=$(basename "$subtitle_subfile")
                local sub_ext="${subtitle_subfile##*.}"
                
                # Try to detect language from filename (comprehensive YIFY subtitle language support)
                # Convert to lowercase for pattern matching (bash 3.2 compatible)
                local sub_basename_lower=$(echo "$sub_basename" | tr '[:upper:]' '[:lower:]')
                local lang_code=""
                
                # Pattern 1: Extract 2-4 letter language code before extension (case insensitive)
                # Matches: .eng.srt, .chi.srt, .ENG.srt, .pt-br.srt
                if [[ "$sub_basename_lower" =~ \.([a-z]{2,4}(-[a-z]{2})?)\.(srt|sub|idx|ass|ssa|vtt)$ ]]; then
                    lang_code="${BASH_REMATCH[1]}"
                # Pattern 2: Underscore before language code
                # Matches: filename_eng.srt, filename_chi.srt
                elif [[ "$sub_basename_lower" =~ _([a-z]{2,4}(-[a-z]{2})?)\.(srt|sub|idx|ass|ssa|vtt)$ ]]; then
                    lang_code="${BASH_REMATCH[1]}"
                # Pattern 3: Any text followed by dot and language code (case insensitive)
                # Matches: "English.eng.srt", "Traditional.chi.srt", "SDH.eng.HI.srt", "2_English.eng.srt"
                elif [[ "$sub_basename_lower" =~ [._-]([a-z]{2,4})\.([a-z]{2,4})\.(srt|sub|idx|ass|ssa|vtt)$ ]]; then
                    # Check if first match is a known descriptor (sdh, hi, cc, forced)
                    if [[ "${BASH_REMATCH[1]}" =~ ^(sdh|hi|cc|forced)$ ]]; then
                        lang_code="${BASH_REMATCH[2]}"  # Use second match as language
                    else
                        lang_code="${BASH_REMATCH[1]}"  # Use first match as language
                    fi
                # Pattern 4: Text.code.srt (Traditional.chi.srt, Simplified.chi.srt)
                elif [[ "$sub_basename_lower" =~ ^[a-z0-9_[:space:]]+\.([a-z]{2,4})\.(srt|sub|idx|ass|ssa|vtt)$ ]]; then
                    lang_code="${BASH_REMATCH[1]}"
                # Pattern 5: Match full language names only (no code present)
                elif [[ "$sub_basename_lower" =~ [._-](albanian)[._-] ]]; then lang_code="alb"
                elif [[ "$sub_basename_lower" =~ [._-](arabic|ara)[._-] ]]; then lang_code="ara"
                elif [[ "$sub_basename_lower" =~ [._-](armenian|arm)[._-] ]]; then lang_code="arm"
                elif [[ "$sub_basename_lower" =~ [._-](brazilian.portuguese|portuguese.brazilian|pt-br|por-br)[._-] ]]; then lang_code="pt-br"
                elif [[ "$sub_basename_lower" =~ [._-](european.portuguese|portuguese.european|pt-pt|por-pt)[._-] ]]; then lang_code="por"
                elif [[ "$sub_basename_lower" =~ [._-](british.english|english.uk|en-gb)[._-] ]]; then lang_code="eng"
                elif [[ "$sub_basename_lower" =~ [._-](us.english|american.english|en-us)[._-] ]]; then lang_code="eng"
                elif [[ "$sub_basename_lower" =~ [._-](canadian.french|french.canadian|fr-ca)[._-] ]]; then lang_code="fre"
                elif [[ "$sub_basename_lower" =~ [._-](european.french|french.european|fr-fr)[._-] ]]; then lang_code="fre"
                elif [[ "$sub_basename_lower" =~ [._-](swiss.german|austrian.german)[._-] ]]; then lang_code="ger"
                elif [[ "$sub_basename_lower" =~ [._-](bulgarian|bul)[._-] ]]; then lang_code="bul"
                elif [[ "$sub_basename_lower" =~ [._-](chinese.simplified|chi.simp|zh-cn)[._-] ]]; then lang_code="chi"
                elif [[ "$sub_basename_lower" =~ [._-](chinese.traditional|chi.trad|zh-tw)[._-] ]]; then lang_code="chi"
                elif [[ "$sub_basename_lower" =~ [._-](chinese|chi|zho)[._-] ]]; then lang_code="chi"
                elif [[ "$sub_basename_lower" =~ [._-](croatian|hrv)[._-] ]]; then lang_code="hrv"
                elif [[ "$sub_basename_lower" =~ [._-](czech|cze)[._-] ]]; then lang_code="cze"
                elif [[ "$sub_basename_lower" =~ [._-](danish|dan)[._-] ]]; then lang_code="dan"
                elif [[ "$sub_basename_lower" =~ [._-](dutch|dut|nld)[._-] ]]; then lang_code="dut"
                elif [[ "$sub_basename_lower" =~ [._-](english|eng)[._-] ]]; then lang_code="eng"
                elif [[ "$sub_basename_lower" =~ [._-](farsi|persian|fas)[._-] ]]; then lang_code="fas"
                elif [[ "$sub_basename_lower" =~ [._-](finnish|fin)[._-] ]]; then lang_code="fin"
                elif [[ "$sub_basename_lower" =~ [._-](french|fre|fra)[._-] ]]; then lang_code="fre"
                elif [[ "$sub_basename_lower" =~ [._-](german|ger|deu)[._-] ]]; then lang_code="ger"
                elif [[ "$sub_basename_lower" =~ [._-](greek|gre|ell)[._-] ]]; then lang_code="gre"
                elif [[ "$sub_basename_lower" =~ [._-](hebrew|heb)[._-] ]]; then lang_code="heb"
                elif [[ "$sub_basename_lower" =~ [._-](hindi|hin)[._-] ]]; then lang_code="hin"
                elif [[ "$sub_basename_lower" =~ [._-](hungarian|hun)[._-] ]]; then lang_code="hun"
                elif [[ "$sub_basename_lower" =~ [._-](indonesian|ind)[._-] ]]; then lang_code="ind"
                elif [[ "$sub_basename_lower" =~ [._-](italian|ita)[._-] ]]; then lang_code="ita"
                elif [[ "$sub_basename_lower" =~ [._-](japanese|jpn)[._-] ]]; then lang_code="jpn"
                elif [[ "$sub_basename_lower" =~ [._-](korean|kor)[._-] ]]; then lang_code="kor"
                elif [[ "$sub_basename_lower" =~ [._-](malay|may|msa)[._-] ]]; then lang_code="may"
                elif [[ "$sub_basename_lower" =~ [._-](norwegian|nor)[._-] ]]; then lang_code="nor"
                elif [[ "$sub_basename_lower" =~ [._-](polish|pol)[._-] ]]; then lang_code="pol"
                elif [[ "$sub_basename_lower" =~ [._-](portuguese|por)[._-] ]]; then lang_code="por"
                elif [[ "$sub_basename_lower" =~ [._-](romanian|rum)[._-] ]]; then lang_code="rum"
                elif [[ "$sub_basename_lower" =~ [._-](russian|rus)[._-] ]]; then lang_code="rus"
                elif [[ "$sub_basename_lower" =~ [._-](latin.american|latinoamericano|spanish.latin.america|spanish.latin|es-la)[._-] ]]; then lang_code="spa"
                elif [[ "$sub_basename_lower" =~ [._-](spanish.spain|castilian|es-es)[._-] ]]; then lang_code="spa"
                elif [[ "$sub_basename_lower" =~ [._-](spanish|spa|esp)[._-] ]]; then lang_code="spa"
                elif [[ "$sub_basename_lower" =~ [._-](swedish|swe)[._-] ]]; then lang_code="swe"
                elif [[ "$sub_basename_lower" =~ [._-](thai|tha)[._-] ]]; then lang_code="tha"
                elif [[ "$sub_basename_lower" =~ [._-](turkish|tur)[._-] ]]; then lang_code="tur"
                elif [[ "$sub_basename_lower" =~ [._-](vietnamese|vie)[._-] ]]; then lang_code="vie"
                # Default to eng if no language detected
                else
                    lang_code="eng"
                fi
                
                # Extract ALL descriptors present (regional, simplified, traditional, forced, sdh, hi, cc, etc.)
                local -a descriptors=()
                local has_regional=false
                
                # Regional descriptors (must come before general language patterns)
                # Check multi-word regions first to avoid partial matches
                
                # Spanish regions
                if [[ "$sub_basename_lower" =~ (latin[[:space:]._-]+american|latinoamericano|latam) ]]; then
                    descriptors+=("latinamerican")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (castilian|spain) ]]; then
                    descriptors+=("spain")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (mexican|mexico) ]]; then
                    descriptors+=("mexican")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (argentine|argentina) ]]; then
                    descriptors+=("argentine")
                    has_regional=true
                fi
                
                # Portuguese regions
                if [[ "$sub_basename_lower" =~ (brazilian|brazil) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("brazilian")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (european.portuguese|portugal) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("european")
                    has_regional=true
                fi
                
                # English regions (skip if already matched latin american to avoid "american" overlap)
                if [[ "$sub_basename_lower" =~ (british|uk) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("british")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ ^(american|us)[^a-z] ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("american")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (australian|australia) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("australian")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (canadian.english) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("canadian")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (new.zealand) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("newzealand")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (south.african) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("southafrican")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (irish|ireland) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("irish")
                    has_regional=true
                fi
                
                # French regions
                if [[ "$sub_basename_lower" =~ (canadian.french|quebec) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("canadian")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (belgian.french) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("belgian")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (swiss.french) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("swiss")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (african.french) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("african")
                    has_regional=true
                fi
                
                # German regions
                if [[ "$sub_basename_lower" =~ (swiss.german) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("swiss")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (austrian) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("austrian")
                    has_regional=true
                fi
                
                # Chinese regions
                if [[ "$sub_basename_lower" =~ (hong.kong|hongkong) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("hongkong")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (taiwan) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("taiwan")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (singapore) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("singapore")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (mainland|prc) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("mainland")
                    has_regional=true
                fi
                
                # Arabic regions
                if [[ "$sub_basename_lower" =~ (egyptian|egypt) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("egyptian")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (gulf) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("gulf")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (levantine) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("levantine")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (maghreb) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("maghreb")
                    has_regional=true
                fi
                
                # Dutch regions
                if [[ "$sub_basename_lower" =~ (flemish|belgian.dutch) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("flemish")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (netherlands) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("netherlands")
                    has_regional=true
                fi
                
                # Norwegian variants
                if [[ "$sub_basename_lower" =~ (bokmal) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("bokmal")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ (nynorsk) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("nynorsk")
                    has_regional=true
                fi
                
                # Serbian variants (skip if latin american already matched to avoid "latin" overlap)
                if [[ "$sub_basename_lower" =~ (cyrillic) ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("cyrillic")
                    has_regional=true
                elif [[ "$sub_basename_lower" =~ ^(latin)[^a-z] ]] && [[ "$has_regional" != true ]]; then
                    descriptors+=("latin")
                    has_regional=true
                fi
                
                # Language variant descriptors
                if [[ "$sub_basename_lower" =~ (simplified|simp) ]]; then
                    descriptors+=("simplified")
                fi
                if [[ "$sub_basename_lower" =~ (traditional|trad) ]]; then
                    descriptors+=("traditional")
                fi
                if [[ "$sub_basename_lower" =~ (cantonese) ]]; then
                    descriptors+=("cantonese")
                fi
                
                # Quality/format descriptors
                if [[ "$sub_basename_lower" =~ (forced) ]]; then
                    descriptors+=("forced")
                fi
                if [[ "$sub_basename_lower" =~ sdh ]]; then
                    descriptors+=("sdh")
                fi
                if [[ "$sub_basename_lower" =~ \bhi\b ]]; then
                    descriptors+=("hi")
                fi
                if [[ "$sub_basename_lower" =~ \bcc\b ]]; then
                    descriptors+=("cc")
                fi
                if [[ "$sub_basename_lower" =~ (commentary) ]]; then
                    descriptors+=("commentary")
                fi
                
                # Build destination subtitle name: episodename[.descriptor1][.descriptor2].langcode.ext
                local dest_subtitle_sub="${dest_file%.*}"
                
                # Add all descriptors in order
                for desc in "${descriptors[@]}"; do
                    dest_subtitle_sub="${dest_subtitle_sub}.${desc}"
                done
                
                # Add language code
                if [[ -n "$lang_code" ]]; then
                    dest_subtitle_sub="${dest_subtitle_sub}.${lang_code}"
                fi
                
                # Add extension
                dest_subtitle_sub="${dest_subtitle_sub}.${sub_ext}"
                
                if [[ -f "$dest_subtitle_sub" ]]; then
                    local source_inode=$(stat -f "%i" "$subtitle_subfile" 2>/dev/null || stat -c "%i" "$subtitle_subfile" 2>/dev/null)
                    local dest_inode=$(stat -f "%i" "$dest_subtitle_sub" 2>/dev/null || stat -c "%i" "$dest_subtitle_sub" 2>/dev/null)
                    
                    if [[ "$source_inode" != "$dest_inode" ]]; then
                        rm "$dest_subtitle_sub"
                        if $USE_COPY; then
                            cp "$subtitle_subfile" "$dest_subtitle_sub"
                        elif $USE_SYMLINK; then
                            ln -s "$subtitle_subfile" "$dest_subtitle_sub"
                        else
                            ln "$subtitle_subfile" "$dest_subtitle_sub" 2>/dev/null || cp "$subtitle_subfile" "$dest_subtitle_sub"
                        fi
                        ((subtitle_count++))
                    fi
                else
                    if $USE_COPY; then
                        cp "$subtitle_subfile" "$dest_subtitle_sub"
                    elif $USE_SYMLINK; then
                        ln -s "$subtitle_subfile" "$dest_subtitle_sub"
                    else
                        ln "$subtitle_subfile" "$dest_subtitle_sub" 2>/dev/null || cp "$subtitle_subfile" "$dest_subtitle_sub"
                    fi
                    ((subtitle_count++))
                fi
            done < <(find "$season_subs_dir" -type f \( -iname "*.srt" -o -iname "*.sub" -o -iname "*.idx" -o -iname "*.ass" -o -iname "*.ssa" \) -print0)
            else
                should_debug low && echo "[DEBUG] Skipping direct subtitle processing - episode subfolders found, will use episode-specific processing instead" >&2
            fi
        fi
        
        # Also check for episode-specific subtitle folders within the same-directory Subs folder
        # Handle structures like: same_dir/Subs/The.Show.S02E01.../2_English.srt  
        if [[ -n "$season_subs_dir" && -d "$season_subs_dir" ]]; then
            if [[ -n "$TV_SEASON" ]] && [[ -n "$TV_EPISODE" ]]; then
                # Track used language codes to handle duplicates (Bash 3.2 compatible)
                local used_languages=""
                local season_padded=$(printf "%02d" "$TV_SEASON")
                local episode_padded=$(printf "%02d" "$TV_EPISODE")
                
                should_debug low && echo "[DEBUG] Same-dir: Looking for episode folders matching S${season_padded}E${episode_padded} in: $season_subs_dir" >&2
                
                # Find folders containing this episode pattern within the Subs directory
                while IFS= read -r -d '' episode_subs_folder; do
                    # Extract season and episode from folder name for proper matching
                    local folder_basename=$(basename "$episode_subs_folder")
                    local folder_season="" folder_episode=""
                    if [[ "$folder_basename" =~ [Ss]([0-9]{1,2})[Ee]([0-9]{1,3}) ]]; then
                        # Remove leading zeros to avoid octal interpretation
                        folder_season=$((10#${BASH_REMATCH[1]}))
                        folder_episode=$((10#${BASH_REMATCH[2]}))
                        should_debug low && echo "[DEBUG] Same-dir: Regex match found - Raw: S${BASH_REMATCH[1]}E${BASH_REMATCH[2]}, Parsed: S${folder_season}E${folder_episode}" >&2
                    else
                        should_debug low && echo "[DEBUG] Same-dir: No S##E## pattern found in folder: '$folder_basename'" >&2
                    fi
                    
                    should_debug low && echo "[DEBUG] Same-dir: Subtitle folder check: '$folder_basename' -> S${folder_season}E${folder_episode}, Current: S${TV_SEASON}E${TV_EPISODE}" >&2
                    
                    # Only process if folder matches current episode being processed
                    if [[ "$folder_season" == "$TV_SEASON" && "$folder_episode" == "$TV_EPISODE" ]]; then
                        should_debug low && echo "[DEBUG] Same-dir: *** MATCH FOUND *** Processing subtitles from folder: $folder_basename" >&2
                        local folder_subtitle_count=0
                        while IFS= read -r -d '' sub_file; do
                            # Skip if already processed (Bash 3.2 compatible)
                            if [[ "$processed_subtitles" == *"|$sub_file|"* ]]; then
                                continue
                            fi
                            processed_subtitles="$processed_subtitles|$sub_file|"
                            
                            local sub_basename=$(basename "$sub_file")
                            local language=""
                        if [[ "$sub_basename" =~ \.([a-z]{2,3})\.(srt|sub|ass|ssa)$ ]]; then
                            language="${BASH_REMATCH[1]}"
                        elif [[ "$sub_basename" =~ _([A-Za-z]+)\. ]]; then
                            language="${BASH_REMATCH[1]}"
                            language=$(echo "$language" | tr '[:upper:]' '[:lower:]')
                            
                            case "$language" in
                                eng|english) language="en" ;;
                                spa|spanish) language="es" ;;
                                fre|french|fra) language="fr" ;;
                                ger|german|deu) language="de" ;;
                                ita|italian) language="it" ;;
                                por|portuguese) language="pt" ;;
                                dut|dutch|nld) language="nl" ;;
                                pol|polish) language="pl" ;;
                                rus|russian) language="ru" ;;
                                chi|chinese|zho) language="zh" ;;
                                jap|japanese|jpn) language="ja" ;;
                                kor|korean) language="ko" ;;
                                ara|arabic) language="ar" ;;
                                tur|turkish) language="tr" ;;
                                fin|finnish) language="fi" ;;
                                nor|norwegian) language="no" ;;
                                swe|swedish) language="sv" ;;
                                dan|danish) language="da" ;;
                                slo|slovak|slk) language="sk" ;;
                            esac
                        fi
                        
                        local sub_ext="${sub_file##*.}"
                        local dest_subtitle_ep
                        if [[ -n "$language" ]]; then
                            # Check if this language has been used before (Bash 3.2 compatible)
                            local lang_count=1
                            while [[ "$used_languages" == *"|${language}:${lang_count}|"* ]]; do
                                ((lang_count++))
                            done
                            
                            # Build filename with suffix if duplicate
                            if [[ $lang_count -eq 1 ]]; then
                                dest_subtitle_ep="${dest_file%.*}}.${language}.${sub_ext}"
                            else
                                dest_subtitle_ep="${dest_file%.*}}.${language}.${lang_count}.${sub_ext}"
                            fi
                            
                            # Mark this language instance as used
                            used_languages="${used_languages}|${language}:${lang_count}|"
                        else
                            dest_subtitle_ep="${dest_file%.*}}.${sub_basename}"
                        fi
                        
                        if [[ -f "$dest_subtitle_ep" ]]; then
                            local source_inode=$(stat -f "%i" "$sub_file" 2>/dev/null || stat -c "%i" "$sub_file" 2>/dev/null)
                            local dest_inode=$(stat -f "%i" "$dest_subtitle_ep" 2>/dev/null || stat -c "%i" "$dest_subtitle_ep" 2>/dev/null)
                            
                            if [[ "$source_inode" != "$dest_inode" ]]; then
                                rm "$dest_subtitle_ep"
                                if $USE_COPY; then
                                    cp "$sub_file" "$dest_subtitle_ep"
                                elif $USE_SYMLINK; then
                                    ln -s "$sub_file" "$dest_subtitle_ep"
                                else
                                    ln "$sub_file" "$dest_subtitle_ep" 2>/dev/null || cp "$sub_file" "$dest_subtitle_ep"
                                fi
                                ((subtitle_count++))
                            fi
                        else
                            if $USE_COPY; then
                                cp "$sub_file" "$dest_subtitle_ep"
                            elif $USE_SYMLINK; then
                                ln -s "$sub_file" "$dest_subtitle_ep"
                            else
                                ln "$sub_file" "$dest_subtitle_ep" 2>/dev/null || cp "$sub_file" "$dest_subtitle_ep"
                            fi
                            ((subtitle_count++))
                            ((folder_subtitle_count++))
                        fi
                    done < <(find "$episode_subs_folder" -type f \( -iname "*.srt" -o -iname "*.sub" -o -iname "*.idx" -o -iname "*.ass" -o -iname "*.ssa" \) -print0)
                    should_debug low && echo "[DEBUG] Same-dir: Processed $folder_subtitle_count subtitles from folder: $folder_basename" >&2
                    else
                        should_debug low && echo "[DEBUG] Skipping non-matching subtitle folder: $folder_basename" >&2
                    fi
                done < <(find "$season_subs_dir" -mindepth 1 -maxdepth 1 -type d -iname "*[Ss]${season_padded}[Ee]${episode_padded}*" -print0 | tee >(should_debug low && xargs -0 -I {} echo "[DEBUG] Same-dir: Found episode folder: {}" >&2))
            fi
        fi
        
        # Also check for episode-specific subtitle folders in parent Subs directory
        # Handle structures like: Subs/The.Show.S02E01.../2_English.srt
        local parent_dir=$(dirname "$source_dir")
        if [[ -d "$parent_dir/Subs" ]] || [[ -d "$parent_dir/Subtitles" ]]; then
            local subs_dir="$parent_dir/Subs"
            [[ ! -d "$subs_dir" ]] && subs_dir="$parent_dir/Subtitles"
            
            should_debug low && echo "[DEBUG] Parent-dir: Found subs directory: $subs_dir" >&2
            
            # Look for folders matching this episode (S##E##)
            if [[ -n "$TV_SEASON" ]] && [[ -n "$TV_EPISODE" ]]; then
                # Track used language codes for parent dir processing (Bash 3.2 compatible)
                local used_languages_parent=""
                local season_padded=$(printf "%02d" "$TV_SEASON")
                local episode_padded=$(printf "%02d" "$TV_EPISODE")
                
                should_debug low && echo "[DEBUG] Parent-dir: Looking for episode folders matching S${season_padded}E${episode_padded} in: $subs_dir" >&2
                
                # Find folders containing this episode pattern
                while IFS= read -r -d '' episode_subs_folder; do
                    # Extract season and episode from folder name for proper matching
                    local folder_basename=$(basename "$episode_subs_folder")
                    local folder_season="" folder_episode=""
                    if [[ "$folder_basename" =~ [Ss]([0-9]{1,2})[Ee]([0-9]{1,3}) ]]; then
                        # Remove leading zeros to avoid octal interpretation
                        folder_season=$((10#${BASH_REMATCH[1]}))
                        folder_episode=$((10#${BASH_REMATCH[2]}))
                        should_debug low && echo "[DEBUG] Parent-dir: Regex match found - Raw: S${BASH_REMATCH[1]}E${BASH_REMATCH[2]}, Parsed: S${folder_season}E${folder_episode}" >&2
                    else
                        should_debug low && echo "[DEBUG] Parent-dir: No S##E## pattern found in folder: '$folder_basename'" >&2
                    fi
                    
                    should_debug low && echo "[DEBUG] Parent-dir: Subtitle folder check: '$folder_basename' -> S${folder_season}E${folder_episode}, Current: S${TV_SEASON}E${TV_EPISODE}" >&2
                    
                    # Only process if folder matches current episode being processed
                    if [[ "$folder_season" == "$TV_SEASON" && "$folder_episode" == "$TV_EPISODE" ]]; then
                        should_debug low && echo "[DEBUG] Parent-dir: *** MATCH FOUND *** Processing subtitles from folder: $folder_basename" >&2
                        local folder_subtitle_count=0
                        while IFS= read -r -d '' sub_file; do
                            # Skip if already processed (Bash 3.2 compatible)
                            if [[ "$processed_subtitles" == *"|$sub_file|"* ]]; then
                                continue
                            fi
                            processed_subtitles="$processed_subtitles|$sub_file|"
                            
                            local sub_basename=$(basename "$sub_file")
                            
                            # Check if subtitle already has language code
                            local language=""
                        if [[ "$sub_basename" =~ \.([a-z]{2,3})\.(srt|sub|ass|ssa)$ ]]; then
                            language="${BASH_REMATCH[1]}"
                        elif [[ "$sub_basename" =~ _([A-Za-z]+)\. ]]; then
                            language="${BASH_REMATCH[1]}"
                            language=$(echo "$language" | tr '[:upper:]' '[:lower:]')
                            
                            case "$language" in
                                eng|english) language="en" ;;
                                spa|spanish) language="es" ;;
                                fre|french|fra) language="fr" ;;
                                ger|german|deu) language="de" ;;
                                ita|italian) language="it" ;;
                                por|portuguese) language="pt" ;;
                                dut|dutch|nld) language="nl" ;;
                                pol|polish) language="pl" ;;
                                rus|russian) language="ru" ;;
                                chi|chinese|zho) language="zh" ;;
                                jap|japanese|jpn) language="ja" ;;
                                kor|korean) language="ko" ;;
                                ara|arabic) language="ar" ;;
                                tur|turkish) language="tr" ;;
                                fin|finnish) language="fi" ;;
                                nor|norwegian) language="no" ;;
                                swe|swedish) language="sv" ;;
                                dan|danish) language="da" ;;
                                slo|slovak|slk) language="sk" ;;
                            esac
                        fi
                        
                        local sub_ext="${sub_file##*.}"
                        local dest_subtitle_ep
                        if [[ -n "$language" ]]; then
                            # Check if this language has been used before in parent dir (Bash 3.2 compatible)
                            local lang_count=1
                            while [[ "$used_languages_parent" == *"|${language}:${lang_count}|"* ]]; do
                                ((lang_count++))
                            done
                            
                            # Build filename with suffix if duplicate
                            if [[ $lang_count -eq 1 ]]; then
                                dest_subtitle_ep="${dest_file%.*}}.${language}.${sub_ext}"
                            else
                                dest_subtitle_ep="${dest_file%.*}}.${language}.${lang_count}.${sub_ext}"
                            fi
                            
                            # Mark this language instance as used
                            used_languages_parent="${used_languages_parent}|${language}:${lang_count}|"
                        else
                            dest_subtitle_ep="${dest_file%.*}}.${sub_basename}"
                        fi
                        
                        if [[ -f "$dest_subtitle_ep" ]]; then
                            local source_inode=$(stat -f "%i" "$sub_file" 2>/dev/null || stat -c "%i" "$sub_file" 2>/dev/null)
                            local dest_inode=$(stat -f "%i" "$dest_subtitle_ep" 2>/dev/null || stat -c "%i" "$dest_subtitle_ep" 2>/dev/null)
                            
                            if [[ "$source_inode" != "$dest_inode" ]]; then
                                rm "$dest_subtitle_ep"
                                if $USE_COPY; then
                                    cp "$sub_file" "$dest_subtitle_ep"
                                elif $USE_SYMLINK; then
                                    ln -s "$sub_file" "$dest_subtitle_ep"
                                else
                                    ln "$sub_file" "$dest_subtitle_ep" 2>/dev/null || cp "$sub_file" "$dest_subtitle_ep"
                                fi
                                ((subtitle_count++))
                            fi
                        else
                            if $USE_COPY; then
                                cp "$sub_file" "$dest_subtitle_ep"
                            elif $USE_SYMLINK; then
                                ln -s "$sub_file" "$dest_subtitle_ep"
                            else
                                ln "$sub_file" "$dest_subtitle_ep" 2>/dev/null || cp "$sub_file" "$dest_subtitle_ep"
                            fi
                            ((subtitle_count++))
                            ((folder_subtitle_count++))
                        fi
                    done < <(find "$episode_subs_folder" -type f \( -iname "*.srt" -o -iname "*.sub" -o -iname "*.idx" -o -iname "*.ass" -o -iname "*.ssa" \) -print0)
                    should_debug low && echo "[DEBUG] Parent-dir: Processed $folder_subtitle_count subtitles from folder: $folder_basename" >&2
                    else
                        should_debug low && echo "[DEBUG] Skipping non-matching parent subtitle folder: $folder_basename" >&2
                    fi
                done < <(find "$subs_dir" -mindepth 1 -maxdepth 1 -type d -iname "*[Ss]${season_padded}[Ee]${episode_padded}*" -print0 | tee >(should_debug low && xargs -0 -I {} echo "[DEBUG] Parent-dir: Found episode folder: {}" >&2))
            fi
        fi
        
        # Process season-level Subs folder for matching episode subtitles
        # BUT ONLY if there are no episode-specific subfolders
        if [[ -n "$season_subs_dir" && -n "$TV_SEASON" && -n "$TV_EPISODE" ]]; then
            # Check if there are episode-specific subfolders in the Subs directory  
            local has_episode_subfolders=false
            while IFS= read -r -d '' episode_subfolder; do
                has_episode_subfolders=true
                break
            done < <(find "$season_subs_dir" -mindepth 1 -maxdepth 1 -type d -print0 2>/dev/null)
            
            # Only process direct subtitle files if there are NO episode subfolders
            if [[ "$has_episode_subfolders" == "false" ]]; then
                should_debug low && echo "[DEBUG] Processing season-level subtitle files (no episode subfolders found)" >&2
                local season_padded=$(printf "%02d" "$TV_SEASON")
                local episode_padded=$(printf "%02d" "$TV_EPISODE")
                
                # Find subtitle files matching this episode pattern
                while IFS= read -r -d '' sub_file; do
                # Skip if already processed (Bash 3.2 compatible)
                if [[ "$processed_subtitles" == *"|$sub_file|"* ]]; then
                    continue
                fi
                processed_subtitles="$processed_subtitles|$sub_file|"
                
                local sub_basename=$(basename "$sub_file")
                
                # Check if filename matches this episode (S##E##, ##x##, or episode number)
                local matches_episode=0
                
                # Pattern 1: S##E## format
                if [[ "$sub_basename" =~ [Ss]${season_padded}[Ee]${episode_padded} ]] || \
                   [[ "$sub_basename" =~ [Ss]0*${TV_SEASON}[Ee]0*${TV_EPISODE} ]]; then
                    matches_episode=1
                # Pattern 2: ##x## format
                elif [[ "$sub_basename" =~ 0*${TV_SEASON}x0*${TV_EPISODE} ]]; then
                    matches_episode=1
                # Pattern 3: Just episode number with dots/spaces (e.g., "2_English.srt" for episode 2)
                elif [[ "$sub_basename" =~ ^0*${TV_EPISODE}[_\.\-\ ] ]]; then
                    matches_episode=1
                fi
                
                if [[ $matches_episode -eq 1 ]]; then
                    # Extract language code
                    local language=""
                    
                    # Check if subtitle already has language code (like .en.srt, .eng.srt)
                    if [[ "$sub_basename" =~ \.([a-z]{2,3})\.(srt|sub|ass|ssa)$ ]]; then
                        language="${BASH_REMATCH[1]}"
                    # Extract from patterns like "S02E01.English.srt", "2_English.srt", "2.en.srt"
                    elif [[ "$sub_basename" =~ [_\.\-]([A-Za-z]{2,3})\.(srt|sub|ass|ssa)$ ]]; then
                        language="${BASH_REMATCH[1]}"
                        language=$(echo "$language" | tr '[:upper:]' '[:lower:]')
                        
                        # Map common language codes
                        case "$language" in
                            eng|english) language="en" ;;
                            spa|spanish) language="es" ;;
                            fre|french|fra) language="fr" ;;
                            ger|german|deu) language="de" ;;
                            ita|italian) language="it" ;;
                            por|portuguese) language="pt" ;;
                            dut|dutch|nld) language="nl" ;;
                            pol|polish) language="pl" ;;
                            rus|russian) language="ru" ;;
                            chi|chinese|zho) language="zh" ;;
                            jap|japanese|jpn) language="ja" ;;
                            kor|korean) language="ko" ;;
                            ara|arabic) language="ar" ;;
                            tur|turkish) language="tr" ;;
                            fin|finnish) language="fi" ;;
                            nor|norwegian) language="no" ;;
                            swe|swedish) language="sv" ;;
                            dan|danish) language="da" ;;
                            slo|slovak|slk) language="sk" ;;
                        esac
                    # Extract from longer language names like "_English.srt"
                    elif [[ "$sub_basename" =~ _([A-Za-z]+)\.(srt|sub|ass|ssa)$ ]]; then
                        language="${BASH_REMATCH[1]}"
                        language=$(echo "$language" | tr '[:upper:]' '[:lower:]')
                        
                        case "$language" in
                            eng|english) language="en" ;;
                            spa|spanish) language="es" ;;
                            fre|french|fra) language="fr" ;;
                            ger|german|deu) language="de" ;;
                            ita|italian) language="it" ;;
                            por|portuguese) language="pt" ;;
                            dut|dutch|nld) language="nl" ;;
                            pol|polish) language="pl" ;;
                            rus|russian) language="ru" ;;
                            chi|chinese|zho) language="zh" ;;
                            jap|japanese|jpn) language="ja" ;;
                            kor|korean) language="ko" ;;
                            ara|arabic) language="ar" ;;
                            tur|turkish) language="tr" ;;
                            fin|finnish) language="fi" ;;
                            nor|norwegian) language="no" ;;
                            swe|swedish) language="sv" ;;
                            dan|danish) language="da" ;;
                            slo|slovak|slk) language="sk" ;;
                        esac
                    fi
                    
                    # Build destination subtitle name
                    local sub_ext="${sub_file##*.}"
                    local dest_subtitle_season
                    if [[ -n "$language" ]]; then
                        dest_subtitle_season="${dest_file%.*}.${language}.${sub_ext}"
                    else
                        # No language detected, use generic extension
                        dest_subtitle_season="${dest_file%.*}.${sub_ext}"
                    fi
                    
                    # Check if subtitle already exists
                    if [[ -f "$dest_subtitle_season" ]]; then
                        local source_inode=$(stat -f "%i" "$sub_file" 2>/dev/null || stat -c "%i" "$sub_file" 2>/dev/null)
                        local dest_inode=$(stat -f "%i" "$dest_subtitle_season" 2>/dev/null || stat -c "%i" "$dest_subtitle_season" 2>/dev/null)
                        
                        if [[ "$source_inode" != "$dest_inode" ]]; then
                            rm "$dest_subtitle_season"
                            if $USE_COPY; then
                                cp "$sub_file" "$dest_subtitle_season"
                            elif $USE_SYMLINK; then
                                ln -s "$sub_file" "$dest_subtitle_season"
                            else
                                ln "$sub_file" "$dest_subtitle_season" 2>/dev/null || cp "$sub_file" "$dest_subtitle_season"
                            fi
                            ((subtitle_count++))
                        fi
                    else
                        if $USE_COPY; then
                            cp "$sub_file" "$dest_subtitle_season"
                        elif $USE_SYMLINK; then
                            ln -s "$sub_file" "$dest_subtitle_season"
                        else
                            ln "$sub_file" "$dest_subtitle_season" 2>/dev/null || cp "$sub_file" "$dest_subtitle_season"
                        fi
                        ((subtitle_count++))
                    fi
                fi
            done < <(find "$season_subs_dir" -type f \( -iname "*.srt" -o -iname "*.sub" -o -iname "*.idx" -o -iname "*.ass" -o -iname "*.ssa" \) -print0)
            else
                should_debug low && echo "[DEBUG] Skipping season-level subtitle processing (episode subfolders found - using episode-specific processing instead)" >&2
            fi
        fi
        
        [[ $subtitle_count -gt 0 ]] && print_success "✓ Linked $subtitle_count subtitle file(s)"
    fi  # End of if $link_success block (subtitles are now complete)
        
        # ========================================================================
        # EXTRAS PROCESSING HAS BEEN MOVED TO SERIES-LEVEL (process_series_extras)
        # This eliminates 125x redundant scanning and enables full parallelization
        # The code below is kept for reference but is no longer executed
        # ========================================================================
        ### DISABLED: Extras are now processed once per series before episodes
        # Helper function to log skipped extras files
        # log_skipped_extra() {
        #     local file="$1"
        #     local reason="$2"
        #     # Append to temp file for aggregation (thread-safe with >>)
        #     if [[ -n "$EXTRAS_SKIPPED_FILE" ]]; then
        #         echo "${file}|${reason}" >> "$EXTRAS_SKIPPED_FILE"
        #     fi
        # }
        # 
        # # Helper function to log processed extras files
        # log_processed_extra() {
        #     local file="$1"
        #     # Append to temp file for aggregation (thread-safe with >>)
        #     if [[ -n "$EXTRAS_PROCESSED_FILE" ]]; then
        #         echo "$file" >> "$EXTRAS_PROCESSED_FILE"
        #     fi
        # }
        # 
        # # Hardlink extras/bonus content for TV shows (Plex/Emby/Jellyfin format)
        # # Extras can be at series level or season level
        # # Only process if user enabled extras linking
        # EXTRAS PROCESSING REMOVED - NOW HANDLED AT SERIES-LEVEL BEFORE EPISODE PROCESSING
        if false; then  # Disabled - extras now processed at series level
            local extras_count=0
            local -a extras_folders=("behind the scenes" "deleted scenes" "interviews" "scenes" "samples" "shorts" "featurettes" "clips" "other" "extras" "trailers")
        
        # Determine the base directory to search (go up to season or series folder)
        local search_base_dir="$source_dir"
        # If we're inside a season folder (folder named exactly "Season ##"), go to parent
        # But don't match if "Season ##" is just part of the series title
        local source_dir_basename=$(basename "$source_dir")
        if [[ "$source_dir_basename" =~ ^Season[[:space:]]?[0-9]+$ ]]; then
            search_base_dir=$(dirname "$source_dir")
        fi
        
        # Process existing extras folders at season/series level
        # Use maxdepth 1 to only search current directory, preventing sibling directory pollution
        for folder_name in "${extras_folders[@]}"; do
            # Skip generic "extras" and "other" folders - let loose processing categorize them properly
            if [[ "$folder_name" == "extras" ]] || [[ "$folder_name" == "other" ]]; then
                continue
            fi
            
            while IFS= read -r -d '' extras_dir; do
                local extras_dirname=$(basename "$extras_dir")
                
                # Build list of movie folders to skip (folders with year in parentheses)
                local -a movie_folders=()
                while IFS= read -r -d '' subfolder; do
                    local subfolder_name=$(basename "$subfolder")
                    # Detect movie folder: has year in parentheses like "Fight the Future (1998)"
                    if [[ "$subfolder_name" =~ \([0-9]{4}\) ]]; then
                        movie_folders+=("$subfolder_name")
                    fi
                done < <(find "$extras_dir" -mindepth 1 -maxdepth 1 -type d -print0)
                
                # Process nested non-extras folders (like "Bonus Discs/Framing Farmington/..." or "Behind the Scenes Clips")
                # For Jellyfin compatibility, categorize and place files in appropriate extras folders
                # Only process if the subfolder is NOT an extras type folder itself
                while IFS= read -r -d '' nested_folder; do
                    local nested_folder_name=$(basename "$nested_folder")
                    
                    # Skip movie folders
                    local is_movie_folder=false
                    for movie_folder in "${movie_folders[@]}"; do
                        if [[ "$nested_folder_name" == "$movie_folder" ]]; then
                            is_movie_folder=true
                            break
                        fi
                    done
                    if $is_movie_folder; then
                        continue
                    fi
                    
                    # Check if this folder name matches any extras type - if so, skip (will be handled separately)
                    local is_extras_type=false
                    for check_extras in "${extras_folders[@]}"; do
                        if [[ "$nested_folder_name" =~ ^${check_extras}$ ]]; then
                            is_extras_type=true
                            break
                        fi
                    done
                    
                    # Also skip Season folders (will be handled separately)
                    if [[ "$nested_folder_name" =~ ^[Ss]eason[[:space:]]?[0-9]+ ]] || [[ "$nested_folder_name" =~ ^[Ss][0-9]+$ ]]; then
                        is_extras_type=true
                    fi
                    
                    # Skip if it's an extras type or season folder
                    if $is_extras_type; then
                        continue
                    fi
                    
                    # Detect if extras_dir is inside a season folder (check parent structure)
                    local extras_parent_dir=$(dirname "$extras_dir")
                    local extras_parent_name=$(basename "$extras_parent_dir")
                    local detected_season=""
                    
                    # Check if parent folder is a season folder (handles S02, Season 2, etc.)
                    if [[ "$extras_parent_name" =~ ^[Ss]([0-9]{1,2})$ ]]; then
                        detected_season="${BASH_REMATCH[1]}"
                    elif [[ "$extras_parent_name" =~ [Ss]eason[[:space:]]?([0-9]{1,2}) ]]; then
                        detected_season="${BASH_REMATCH[1]}"
                    fi
                    
                    # This is a nested non-extras folder - recursively find all video files
                    # Categorize based on nested folder name AND filename
                    while IFS= read -r -d '' nested_file; do
                        local nested_basename=$(basename "$nested_file")
                        
                        # First, check if filename has a season/episode number
                        local file_season=""
                        if [[ "$nested_basename" =~ [Ss]([0-9]{1,2})[Ee][0-9]{1,2} ]]; then
                            file_season="${BASH_REMATCH[1]}"
                        elif [[ "$nested_basename" =~ ([0-9]{1,2})x[0-9]{1,2} ]]; then
                            file_season="${BASH_REMATCH[1]}"
                        elif [[ "$nested_basename" =~ [Ss]([0-9]{1,2})\.[0-9] ]]; then
                            file_season="${BASH_REMATCH[1]}"
                        elif [[ "$nested_basename" =~ [Ss]([0-9]{1,2})[Ee]xtra ]]; then
                            file_season="${BASH_REMATCH[1]}"
                        elif [[ "$nested_basename" =~ [Ss]([0-9]{1,2})([[:space:]]|\-|$) ]]; then
                            file_season="${BASH_REMATCH[1]}"
                        elif [[ "$nested_basename" =~ [Ss]eason[[:space:]]?([0-9]{1,2}) ]]; then
                            file_season="${BASH_REMATCH[1]}"
                        fi
                        
                        # Try to categorize based on filename first (more specific)
                        local categorized_type=""
                        local filename_lower=$(echo "$nested_basename" | tr '[:upper:]' '[:lower:]')
                        if [[ "$filename_lower" =~ deleted.?scene ]]; then
                            categorized_type="deleted scenes"
                        elif [[ "$filename_lower" =~ (behind.?the.?scene|bts|making.?of) ]]; then
                            categorized_type="behind the scenes"
                        elif [[ "$filename_lower" =~ interview ]]; then
                            categorized_type="interviews"
                        elif [[ "$filename_lower" =~ gag.?reel|blooper|outtake ]]; then
                            categorized_type="behind the scenes"
                        elif [[ "$filename_lower" =~ trailer ]]; then
                            categorized_type="trailers"
                        elif [[ "$filename_lower" =~ featurette ]]; then
                            categorized_type="featurettes"
                        elif [[ "$filename_lower" =~ sample ]]; then
                            categorized_type="samples"
                        elif [[ "$filename_lower" =~ short ]]; then
                            categorized_type="shorts"
                        elif [[ "$filename_lower" =~ scene|clip ]]; then
                            categorized_type="scenes"
                        fi
                        
                        # If not categorized by filename, try folder name
                        if [[ -z "$categorized_type" ]]; then
                            local nested_lower=$(echo "$nested_folder_name" | tr '[:upper:]' '[:lower:]')
                            if [[ "$nested_lower" =~ deleted.?scene ]]; then
                                categorized_type="deleted scenes"
                            elif [[ "$nested_lower" =~ (behind.?the.?scene|bts|making.?of) ]]; then
                                categorized_type="behind the scenes"
                            elif [[ "$nested_lower" =~ interview ]]; then
                                categorized_type="interviews"
                            elif [[ "$nested_lower" =~ gag.?reel|blooper|outtake ]]; then
                                categorized_type="behind the scenes"
                            elif [[ "$nested_lower" =~ trailer ]]; then
                                categorized_type="trailers"
                            elif [[ "$nested_lower" =~ featurette ]]; then
                                categorized_type="featurettes"
                            elif [[ "$nested_lower" =~ sample ]]; then
                                categorized_type="samples"
                            elif [[ "$nested_lower" =~ short ]]; then
                                categorized_type="shorts"
                            elif [[ "$nested_lower" =~ scene|clip ]]; then
                                categorized_type="scenes"
                            fi
                        fi
                        
                        # If still not categorized, use parent extras folder name
                        if [[ -z "$categorized_type" ]]; then
                            categorized_type="$extras_dirname"
                        fi
                        
                        # Determine destination season - use filename season if present, otherwise detected_season
                        local dest_nested_extras
                        local final_season=""
                        if [[ -n "$file_season" ]]; then
                            # Filename has season number - use that
                            final_season="$file_season"
                        elif [[ -n "$detected_season" ]]; then
                            # Extras folder is inside a season folder - use that
                            final_season="$detected_season"
                        fi
                        
                        if [[ -n "$final_season" ]]; then
                            # Place in season-specific folder
                            final_season=$((10#$final_season))  # Remove leading zeros
                            local season_num=$(printf "%02d" "$final_season")
                            dest_nested_extras="${DESTINATION}/${series_folder}/Season ${season_num}/$(echo "$categorized_type" | tr '[:upper:]' '[:lower:]')"
                        else
                            # Series-level extras
                            dest_nested_extras="${DESTINATION}/${series_folder}/$(echo "$categorized_type" | tr '[:upper:]' '[:lower:]')"
                        fi
                        
                        local dest_nested="${dest_nested_extras}/${nested_basename}"
                        
                        local nested_inode=$(stat -f "%i" "$nested_file" 2>/dev/null || stat -c "%i" "$nested_file" 2>/dev/null)
                        if [[ " $PROCESSED_FILES " =~ " $nested_inode " ]]; then
                            log_skipped_extra "$nested_file" "already_processed"
                            continue
                        fi
                        
                        # Only create folder when we have a file to process
                        mkdir -p "$dest_nested_extras"
                        
                        if [[ -f "$dest_nested" ]]; then
                            local dest_inode=$(stat -f "%i" "$dest_nested" 2>/dev/null || stat -c "%i" "$dest_nested" 2>/dev/null)
                            if [[ "$nested_inode" == "$dest_inode" ]]; then
                                PROCESSED_FILES="$PROCESSED_FILES $nested_inode"
                                log_skipped_extra "$nested_file" "already_exists"
                                continue
                            fi
                            # In copy mode, check if files are identical before replacing
                            if $USE_COPY && files_are_identical "$nested_file" "$dest_nested"; then
                                PROCESSED_FILES="$PROCESSED_FILES $nested_inode"
                                log_skipped_extra "$nested_file" "already_exists"
                                continue
                            fi
                            rm "$dest_nested"
                        fi
                        
                        if $USE_COPY; then
                            cp "$nested_file" "$dest_nested" 2>/dev/null
                        elif $USE_SYMLINK; then
                            ln -s "$nested_file" "$dest_nested"
                        else
                            ln "$nested_file" "$dest_nested" 2>/dev/null || cp "$nested_file" "$dest_nested" 2>/dev/null
                        fi
                        PROCESSED_FILES="$PROCESSED_FILES $nested_inode"
                        log_processed_extra "$nested_file"
                        ((extras_count++))
                    done < <(find "$nested_folder" -type f \( -iname "*.mkv" -o -iname "*.mp4" -o -iname "*.avi" -o -iname "*.m4v" -o -iname "*.mov" -o -iname "*.vob" -o -iname "*.wmv" -o -iname "*.flv" -o -iname "*.webm" -o -iname "*.ts" -o -iname "*.m2ts" -o -iname "*.mpg" -o -iname "*.mpeg" \) -print0)
                done < <(find "$extras_dir" -mindepth 1 -maxdepth 1 -type d -print0)
                
                # Check if this extras folder contains extras type subfolders
                # (like Featurettes/Behind The Scenes, Featurettes/Deleted Scenes, etc.)
                # For Jellyfin: flatten these into their respective extras type folders
                for sub_extras_type in "${extras_folders[@]}"; do
                    if [[ -d "$extras_dir/$sub_extras_type" ]]; then
                        # Recursively find all files in this extras type subfolder and flatten them
                        while IFS= read -r -d '' extras_subtype_file; do
                            local subtype_basename=$(basename "$extras_subtype_file")
                            
                            # Determine destination based on context
                            local dest_extras_subtype
                            if [[ -n "$TV_SEASON" ]]; then
                                # We're processing from a season-specific download, keep in that season
                                local season_num=$(printf "%02d" "$TV_SEASON")
                                dest_extras_subtype="${DESTINATION}/${series_folder}/Season ${season_num}/$(echo "$sub_extras_type" | tr '[:upper:]' '[:lower:]')"
                            else
                                # Series-level extras
                                dest_extras_subtype="${DESTINATION}/${series_folder}/$(echo "$sub_extras_type" | tr '[:upper:]' '[:lower:]')"
                            fi
                            
                            local dest_subtype="${dest_extras_subtype}/${subtype_basename}"
                            
                            local subtype_inode=$(stat -f "%i" "$extras_subtype_file" 2>/dev/null || stat -c "%i" "$extras_subtype_file" 2>/dev/null)
                            if [[ " $PROCESSED_FILES " =~ " $subtype_inode " ]]; then
                                log_skipped_extra "$extras_subtype_file" "already_processed"
                                continue
                            fi
                            
                            # Only create folder when we have a file to process
                            mkdir -p "$dest_extras_subtype"
                            
                            if [[ -f "$dest_subtype" ]]; then
                                local dest_inode=$(stat -f "%i" "$dest_subtype" 2>/dev/null || stat -c "%i" "$dest_subtype" 2>/dev/null)
                                if [[ "$subtype_inode" == "$dest_inode" ]]; then
                                    PROCESSED_FILES="$PROCESSED_FILES $subtype_inode"
                                    log_skipped_extra "$extras_subtype_file" "already_exists"
                                    continue
                                fi
                                # In copy mode, check if files are identical before replacing
                                if $USE_COPY && files_are_identical "$extras_subtype_file" "$dest_subtype"; then
                                    PROCESSED_FILES="$PROCESSED_FILES $subtype_inode"
                                    log_skipped_extra "$extras_subtype_file" "already_exists"
                                    continue
                                fi
                                rm "$dest_subtype"
                            fi
                            
                            if $USE_COPY; then
                                cp "$extras_subtype_file" "$dest_subtype" 2>/dev/null
                            elif $USE_SYMLINK; then
                                ln -s "$extras_subtype_file" "$dest_subtype"
                            else
                                ln "$extras_subtype_file" "$dest_subtype" 2>/dev/null || cp "$extras_subtype_file" "$dest_subtype"
                            fi
                            PROCESSED_FILES="$PROCESSED_FILES $subtype_inode"
                            log_processed_extra "$extras_subtype_file"
                            ((extras_count++))
                        done < <(find "$extras_dir/$sub_extras_type" -type f \( -iname "*.mkv" -o -iname "*.mp4" -o -iname "*.avi" -o -iname "*.m4v" -o -iname "*.mov" -o -iname "*.vob" -o -iname "*.wmv" -o -iname "*.flv" -o -iname "*.webm" -o -iname "*.ts" -o -iname "*.m2ts" -o -iname "*.mpg" -o -iname "*.mpeg" \) -print0)
                    fi
                done
                
                # First check if this extras folder contains Season subfolders
                # If so, process those files with their season numbers
                local has_season_folders=false
                while IFS= read -r -d '' season_folder; do
                    has_season_folders=true
                    local season_folder_name=$(basename "$season_folder")
                    
                    # Extract season number from folder name
                    local folder_season=""
                    if [[ "$season_folder_name" =~ [Ss]eason[[:space:]]?([0-9]{1,2}) ]] || [[ "$season_folder_name" =~ ^[Ss]([0-9]{1,2})$ ]]; then
                        folder_season="${BASH_REMATCH[1]}"
                        folder_season=$((10#$folder_season))  # Remove leading zeros
                        
                        # First check if there are extras subfolders (like Deleted Scenes) inside this Season folder
                        for sub_extras_type in "${extras_folders[@]}"; do
                            while IFS= read -r -d '' sub_extras_folder; do
                                while IFS= read -r -d '' sub_extra_file; do
                                    local sub_extra_basename=$(basename "$sub_extra_file")
                                    local season_num=$(printf "%02d" "$folder_season")
                                    local dest_season_extras="${DESTINATION}/${series_folder}/Season ${season_num}/$(echo "$sub_extras_type" | tr '[:upper:]' '[:lower:]')"
                                    local dest_sub_extra="${dest_season_extras}/${sub_extra_basename}"
                                    
                                    local sub_source_inode=$(stat -f "%i" "$sub_extra_file" 2>/dev/null || stat -c "%i" "$sub_extra_file" 2>/dev/null)
                                    if [[ " $PROCESSED_FILES " =~ " $sub_source_inode " ]]; then
                                        log_skipped_extra "$sub_extra_file" "already_processed"
                                        continue
                                    fi
                                    
                                    # Only create folder when we have a file to process
                                    mkdir -p "$dest_season_extras"
                                    
                                    if [[ -f "$dest_sub_extra" ]]; then
                                        local dest_inode=$(stat -f "%i" "$dest_sub_extra" 2>/dev/null || stat -c "%i" "$dest_sub_extra" 2>/dev/null)
                                        if [[ "$sub_source_inode" == "$dest_inode" ]]; then
                                            PROCESSED_FILES="$PROCESSED_FILES $sub_source_inode"
                                            log_skipped_extra "$sub_extra_file" "already_exists"
                                            continue
                                        fi
                                        # In copy mode, check if files are identical before replacing
                                        if $USE_COPY && files_are_identical "$sub_extra_file" "$dest_sub_extra"; then
                                            PROCESSED_FILES="$PROCESSED_FILES $sub_source_inode"
                                            log_skipped_extra "$sub_extra_file" "already_exists"
                                            continue
                                        fi
                                        rm "$dest_sub_extra"
                                    fi
                                    
                                    if $USE_COPY; then
                                        cp "$sub_extra_file" "$dest_sub_extra" 2>/dev/null
                                    elif $USE_SYMLINK; then
                                        ln -s "$sub_extra_file" "$dest_sub_extra"
                                    else
                                        ln "$sub_extra_file" "$dest_sub_extra" 2>/dev/null || cp "$sub_extra_file" "$dest_sub_extra" 2>/dev/null
                                    fi
                                    PROCESSED_FILES="$PROCESSED_FILES $sub_source_inode"
                                    log_processed_extra "$sub_extra_file"
                                    ((extras_count++))
                                done < <(find "$sub_extras_folder" -maxdepth 1 -type f \( -iname "*.mkv" -o -iname "*.mp4" -o -iname "*.avi" -o -iname "*.m4v" -o -iname "*.mov" -o -iname "*.vob" -o -iname "*.wmv" -o -iname "*.flv" -o -iname "*.webm" -o -iname "*.ts" -o -iname "*.m2ts" -o -iname "*.mpg" -o -iname "*.mpeg" -o -iname "*.srt" -o -iname "*.sub" -o -iname "*.idx" -o -iname "*.ass" -o -iname "*.ssa" \) -print0)
                            done < <(find "$season_folder" -mindepth 1 -maxdepth 1 -type d -iname "$sub_extras_type" -print0)
                        done
                        
                        # Process loose files in this season subfolder (not in extras subfolders)
                        while IFS= read -r -d '' season_extra_file; do
                            # Skip if this file is in an extras subfolder (already processed above)
                            local file_parent=$(dirname "$season_extra_file")
                            local file_parent_name=$(basename "$file_parent")
                            
                            # Check if parent is an extras folder
                            local is_in_extras_subfolder=false
                            for check_extras in "${extras_folders[@]}"; do
                                if [[ "$file_parent_name" == "$check_extras" ]]; then
                                    is_in_extras_subfolder=true
                                    break
                                fi
                            done
                            
                            if $is_in_extras_subfolder; then
                                continue
                            fi
                            
                            local season_extra_basename=$(basename "$season_extra_file")
                            local season_num=$(printf "%02d" "$folder_season")
                            
                            # Categorize loose files by keywords in filename
                            local categorized_type=""
                            local basename_lower=$(echo "$season_extra_basename" | tr '[:upper:]' '[:lower:]')
                            if [[ "$basename_lower" =~ deleted.?scene ]]; then
                                categorized_type="deleted scenes"
                            elif [[ "$basename_lower" =~ behind.?the.?scene ]]; then
                                categorized_type="behind the scenes"
                            elif [[ "$basename_lower" =~ interview ]]; then
                                categorized_type="interviews"
                            elif [[ "$basename_lower" =~ gag.?reel|blooper|outtake ]]; then
                                categorized_type="behind the scenes"
                            elif [[ "$basename_lower" =~ trailer ]]; then
                                categorized_type="trailers"
                            elif [[ "$basename_lower" =~ featurette ]]; then
                                categorized_type="featurettes"
                            elif [[ "$basename_lower" =~ sample ]]; then
                                categorized_type="samples"
                            elif [[ "$basename_lower" =~ short ]]; then
                                categorized_type="shorts"
                            elif [[ "$basename_lower" =~ scene|clip ]]; then
                                categorized_type="scenes"
                            fi
                            
                            # If not categorized, use the parent extras folder name (e.g., "Featurettes")
                            if [[ -z "$categorized_type" ]]; then
                                categorized_type="$extras_dirname"
                            fi
                            
                            local dest_season_extras="${DESTINATION}/${series_folder}/Season ${season_num}/$(echo "$categorized_type" | tr '[:upper:]' '[:lower:]')"
                            local dest_season_extra="${dest_season_extras}/${season_extra_basename}"
                            
                            # Get inode and check if already processed
                            local season_source_inode=$(stat -f "%i" "$season_extra_file" 2>/dev/null || stat -c "%i" "$season_extra_file" 2>/dev/null)
                            if [[ " $PROCESSED_FILES " =~ " $season_source_inode " ]]; then
                                log_skipped_extra "$season_extra_file" "already_processed"
                                continue
                            fi
                            
                            # Only create folder when we have a file to process
                            mkdir -p "$dest_season_extras"
                            
                            # Hardlink the file
                            if [[ -f "$dest_season_extra" ]]; then
                                local dest_inode=$(stat -f "%i" "$dest_season_extra" 2>/dev/null || stat -c "%i" "$dest_season_extra" 2>/dev/null)
                                if [[ "$season_source_inode" == "$dest_inode" ]]; then
                                    PROCESSED_FILES="$PROCESSED_FILES $season_source_inode"
                                    log_skipped_extra "$season_extra_file" "already_exists"
                                    continue
                                fi
                                # In copy mode, check if files are identical before replacing
                                if $USE_COPY && files_are_identical "$season_extra_file" "$dest_season_extra"; then
                                    PROCESSED_FILES="$PROCESSED_FILES $season_source_inode"
                                    log_skipped_extra "$season_extra_file" "already_exists"
                                    continue
                                fi
                                rm "$dest_season_extra"
                            fi
                            
                            if $USE_COPY; then
                                cp "$season_extra_file" "$dest_season_extra" 2>/dev/null
                            elif $USE_SYMLINK; then
                                ln -s "$season_extra_file" "$dest_season_extra"
                            else
                                ln "$season_extra_file" "$dest_season_extra" 2>/dev/null || cp "$season_extra_file" "$dest_season_extra" 2>/dev/null
                            fi
                            PROCESSED_FILES="$PROCESSED_FILES $season_source_inode"
                            log_processed_extra "$season_extra_file"
                            ((extras_count++))
                        done < <(find "$season_folder" -maxdepth 1 -type f \( -iname "*.mkv" -o -iname "*.mp4" -o -iname "*.avi" -o -iname "*.m4v" -o -iname "*.mov" -o -iname "*.vob" -o -iname "*.wmv" -o -iname "*.flv" -o -iname "*.webm" -o -iname "*.ts" -o -iname "*.m2ts" -o -iname "*.mpg" -o -iname "*.mpeg" -o -iname "*.srt" -o -iname "*.sub" -o -iname "*.idx" -o -iname "*.ass" -o -iname "*.ssa" \) -print0)
                        
                        # Process nested folders within this season folder (like "Easter Eggs", "Gag Reel", etc.)
                        # These are subdirectories that aren't standard extras type folders
                        # Remove maxdepth restriction to find all nested folders recursively
                        while IFS= read -r -d '' nested_season_folder; do
                            local nested_folder_name=$(basename "$nested_season_folder")
                            
                            # Skip if it's a standard extras type folder (already processed above)
                            local is_extras_type=false
                            for check_extras in "${extras_folders[@]}"; do
                                if [[ "$nested_folder_name" == "$check_extras" ]]; then
                                    is_extras_type=true
                                    break
                                fi
                            done
                            
                            if $is_extras_type; then
                                continue
                            fi
                            
                            # Process all files in this nested folder recursively (no maxdepth limit)
                            while IFS= read -r -d '' nested_file; do
                                local nested_basename=$(basename "$nested_file")
                                local season_num=$(printf "%02d" "$folder_season")
                                
                                # Try to categorize by filename
                                local categorized_type=""
                                local basename_lower=$(echo "$nested_basename" | tr '[:upper:]' '[:lower:]')
                                if [[ "$basename_lower" =~ deleted.?scene ]]; then
                                    categorized_type="deleted scenes"
                                elif [[ "$basename_lower" =~ behind.?the.?scene ]]; then
                                    categorized_type="behind the scenes"
                                elif [[ "$basename_lower" =~ interview ]]; then
                                    categorized_type="interviews"
                                elif [[ "$basename_lower" =~ gag.?reel|blooper|outtake ]]; then
                                    categorized_type="behind the scenes"
                                elif [[ "$basename_lower" =~ trailer ]]; then
                                    categorized_type="trailers"
                                elif [[ "$basename_lower" =~ featurette ]]; then
                                    categorized_type="featurettes"
                                elif [[ "$basename_lower" =~ sample ]]; then
                                    categorized_type="samples"
                                elif [[ "$basename_lower" =~ short ]]; then
                                    categorized_type="shorts"
                                elif [[ "$basename_lower" =~ scene|clip ]]; then
                                    categorized_type="scenes"
                                fi
                                
                                # If not categorized, use the parent extras folder name (e.g., "Featurettes")
                                if [[ -z "$categorized_type" ]]; then
                                    categorized_type="$extras_dirname"
                                fi
                                
                                local dest_nested_extras="${DESTINATION}/${series_folder}/Season ${season_num}/$(echo "$categorized_type" | tr '[:upper:]' '[:lower:]')"
                                local dest_nested_extra="${dest_nested_extras}/${nested_basename}"
                                
                                local nested_source_inode=$(stat -f "%i" "$nested_file" 2>/dev/null || stat -c "%i" "$nested_file" 2>/dev/null)
                                if [[ " $PROCESSED_FILES " =~ " $nested_source_inode " ]]; then
                                    log_skipped_extra "$nested_file" "already_processed"
                                    continue
                                fi
                                
                                # Only create folder when we have a file to process
                                mkdir -p "$dest_nested_extras"
                                
                                if [[ -f "$dest_nested_extra" ]]; then
                                    local dest_inode=$(stat -f "%i" "$dest_nested_extra" 2>/dev/null || stat -c "%i" "$dest_nested_extra" 2>/dev/null)
                                    if [[ "$nested_source_inode" == "$dest_inode" ]]; then
                                        PROCESSED_FILES="$PROCESSED_FILES $nested_source_inode"
                                        log_skipped_extra "$nested_file" "already_exists"
                                        continue
                                    fi
                                    # In copy mode, check if files are identical before replacing
                                    if $USE_COPY && files_are_identical "$nested_file" "$dest_nested_extra"; then
                                        PROCESSED_FILES="$PROCESSED_FILES $nested_source_inode"
                                        log_skipped_extra "$nested_file" "already_exists"
                                        continue
                                    fi
                                    rm "$dest_nested_extra"
                                fi
                                
                                if $USE_COPY; then
                                    cp "$nested_file" "$dest_nested_extra" 2>/dev/null
                                elif $USE_SYMLINK; then
                                    ln -s "$nested_file" "$dest_nested_extra"
                                else
                                    ln "$nested_file" "$dest_nested_extra" 2>/dev/null || cp "$nested_file" "$dest_nested_extra" 2>/dev/null
                                fi
                                PROCESSED_FILES="$PROCESSED_FILES $nested_source_inode"
                                log_processed_extra "$nested_file"
                                ((extras_count++))
                            done < <(find "$nested_season_folder" -type f \( -iname "*.mkv" -o -iname "*.mp4" -o -iname "*.avi" -o -iname "*.m4v" -o -iname "*.mov" -o -iname "*.vob" -o -iname "*.wmv" -o -iname "*.flv" -o -iname "*.webm" -o -iname "*.ts" -o -iname "*.m2ts" -o -iname "*.mpg" -o -iname "*.mpeg" -o -iname "*.srt" -o -iname "*.sub" -o -iname "*.idx" -o -iname "*.ass" -o -iname "*.ssa" \) -print0)
                        done < <(find "$season_folder" -mindepth 1 -type d -print0)
                    fi
                done < <(find "$extras_dir" -mindepth 1 -maxdepth 1 -type d \( -iname "Season*" -o -iname "S[0-9]*" \) -print0)
                
                # Process loose files in the extras folder (not in Season subfolders)
                # Hardlink video files and subtitles from extras directory
                
                # First, detect if extras_dir is inside a season folder (check parent structure)
                local extras_parent_dir=$(dirname "$extras_dir")
                local extras_parent_name=$(basename "$extras_parent_dir")
                local extras_detected_season=""
                
                # Check if parent folder is a season folder (handles S02, Season 2, etc.)
                if [[ "$extras_parent_name" =~ ^[Ss]([0-9]{1,2})$ ]]; then
                    extras_detected_season="${BASH_REMATCH[1]}"
                elif [[ "$extras_parent_name" =~ [Ss]eason[[:space:]]?([0-9]{1,2}) ]]; then
                    extras_detected_season="${BASH_REMATCH[1]}"
                fi
                
                while IFS= read -r -d '' extra_file; do
                    local extra_basename=$(basename "$extra_file")
                    local extra_parent=$(dirname "$extra_file")
                    local extra_parent_name=$(basename "$extra_parent")
                    
                    # Skip if this file is inside a Season subfolder (already processed above)
                    if [[ "$extra_parent_name" =~ ^[Ss]eason[[:space:]]?[0-9]+ ]] || [[ "$extra_parent_name" =~ ^[Ss][0-9]+$ ]]; then
                        continue
                    fi
                    
                    # Check if extra file has a season number in filename (S##E##, ##x##, S##, Season ##)
                    # Be strict: S## must be followed by E, space, dash, or end - not "Extra" or other letters
                    local extra_season=""
                    if [[ "$extra_basename" =~ [Ss]([0-9]{1,2})[Ee][0-9]{1,2} ]]; then
                        extra_season="${BASH_REMATCH[1]}"
                    elif [[ "$extra_basename" =~ ([0-9]{1,2})x[0-9]{1,2} ]]; then
                        extra_season="${BASH_REMATCH[1]}"
                    elif [[ "$extra_basename" =~ [Ss]([0-9]{1,2})\.[0-9] ]]; then
                        # Matches S05.2 format
                        extra_season="${BASH_REMATCH[1]}"
                    elif [[ "$extra_basename" =~ [Ss]([0-9]{1,2})[Ee]xtra ]]; then
                        extra_season="${BASH_REMATCH[1]}"
                    elif [[ "$extra_basename" =~ [Ss]([0-9]{1,2})([[:space:]]|\-|$) ]]; then
                        extra_season="${BASH_REMATCH[1]}"
                    elif [[ "$extra_basename" =~ [Ss]eason[[:space:]]?([0-9]{1,2}) ]]; then
                        extra_season="${BASH_REMATCH[1]}"
                    fi
                    
                    # If no season in filename, check parent directory name
                    if [[ -z "$extra_season" ]]; then
                        if [[ "$extra_parent_name" =~ [Ss]([0-9]{1,2})[Ee][0-9]{1,2} ]]; then
                            extra_season="${BASH_REMATCH[1]}"
                        elif [[ "$extra_parent_name" =~ ([0-9]{1,2})x[0-9]{1,2} ]]; then
                            extra_season="${BASH_REMATCH[1]}"
                        elif [[ "$extra_parent_name" =~ [Ss]([0-9]{1,2})\.[0-9] ]]; then
                            extra_season="${BASH_REMATCH[1]}"
                        elif [[ "$extra_parent_name" =~ [Ss]([0-9]{1,2})[Ee]xtra ]]; then
                            extra_season="${BASH_REMATCH[1]}"
                        elif [[ "$extra_parent_name" =~ [Ss]([0-9]{1,2})([[:space:]]|\-|$) ]]; then
                            extra_season="${BASH_REMATCH[1]}"
                        elif [[ "$extra_parent_name" =~ [Ss]eason[[:space:]]?([0-9]{1,2}) ]]; then
                            extra_season="${BASH_REMATCH[1]}"
                        fi
                    fi
                    
                    # Don't use TV_SEASON as fallback - extras without season go to series root
                    
                    # Categorize based on filename first (more specific), then fall back to extras folder name
                    local categorized_type=""
                    local basename_lower=$(echo "$extra_basename" | tr '[:upper:]' '[:lower:]')
                    if [[ "$basename_lower" =~ deleted.?scene ]]; then
                        categorized_type="deleted scenes"
                    elif [[ "$basename_lower" =~ (behind.?the.?scene|bts|making.?of) ]]; then
                        categorized_type="behind the scenes"
                    elif [[ "$basename_lower" =~ interview ]]; then
                        categorized_type="interviews"
                    elif [[ "$basename_lower" =~ gag.?reel|blooper|outtake ]]; then
                        categorized_type="behind the scenes"
                    elif [[ "$basename_lower" =~ trailer ]]; then
                        categorized_type="trailers"
                    elif [[ "$basename_lower" =~ featurette ]]; then
                        categorized_type="featurettes"
                    elif [[ "$basename_lower" =~ sample ]]; then
                        categorized_type="samples"
                    elif [[ "$basename_lower" =~ short ]]; then
                        categorized_type="shorts"
                    elif [[ "$basename_lower" =~ scene|clip ]]; then
                        categorized_type="scenes"
                    elif [[ "$basename_lower" =~ special ]]; then
                        # Check if it's a specials/S00 related extra
                        categorized_type="featurettes"
                        # Mark this as potentially Season 00
                        if [[ -z "$extra_season" ]]; then
                            extra_season="0"
                        fi
                    fi
                    
                    # If not categorized, use the parent extras folder name (e.g., "Featurettes")
                    if [[ -z "$categorized_type" ]]; then
                        categorized_type="$extras_dirname"
                    fi
                    
                    # Determine destination: prioritize filename season, then extras folder context, then series root
                    local dest_extras_dir
                    local final_season=""
                    if [[ -n "$extra_season" ]]; then
                        # Filename has season number - use that
                        final_season="$extra_season"
                    elif [[ -n "$extras_detected_season" ]]; then
                        # Extras folder is inside a season folder - use that
                        final_season="$extras_detected_season"
                    fi
                    
                    if [[ -n "$final_season" ]]; then
                        # Format season number with leading zero (force decimal to avoid octal issues)
                        final_season=$((10#$final_season))
                        local season_num=$(printf "%02d" "$final_season")
                        # Always place in season folder if we have a season number
                        dest_extras_dir="${DESTINATION}/${series_folder}/Season ${season_num}/$(echo "$categorized_type" | tr '[:upper:]' '[:lower:]')"
                    else
                        # No season number, place in series root
                        dest_extras_dir="${DESTINATION}/${series_folder}/$(echo "$categorized_type" | tr '[:upper:]' '[:lower:]')"
                    fi
                    
                    local dest_extra="${dest_extras_dir}/${extra_basename}"
                    
                    # Get inode for tracking
                    local source_inode=$(stat -f "%i" "$extra_file" 2>/dev/null || stat -c "%i" "$extra_file" 2>/dev/null)
                    
                    # Check if this file was already processed in this script run
                    if [[ " $PROCESSED_FILES " =~ " $source_inode " ]]; then
                        log_skipped_extra "$extra_file" "already_processed"
                        continue
                    fi
                    
                    # Only create folder when we have a file to process
                    mkdir -p "$dest_extras_dir"
                    
                    # Check if extra file already exists and is hardlinked (skip if already correct)
                    if [[ -f "$dest_extra" ]]; then
                        local dest_inode=$(stat -f "%i" "$dest_extra" 2>/dev/null || stat -c "%i" "$dest_extra" 2>/dev/null)
                        
                        # If already hardlinked to same source, skip (no need to increment counter)
                        if [[ "$source_inode" == "$dest_inode" ]]; then
                            PROCESSED_FILES="$PROCESSED_FILES $source_inode"
                            log_skipped_extra "$extra_file" "already_exists"
                            continue
                        fi
                        
                        # In copy mode, check if files are identical before replacing
                        if $USE_COPY && files_are_identical "$extra_file" "$dest_extra"; then
                            PROCESSED_FILES="$PROCESSED_FILES $source_inode"
                            log_skipped_extra "$extra_file" "already_exists"
                            continue
                        fi
                        
                        # Different file exists, replace it
                        rm "$dest_extra"
                        if $USE_COPY; then
                            cp "$extra_file" "$dest_extra" 2>/dev/null
                        elif $USE_SYMLINK; then
                            ln -s "$extra_file" "$dest_extra"
                        else
                            ln "$extra_file" "$dest_extra" 2>/dev/null || cp "$extra_file" "$dest_extra" 2>/dev/null
                        fi
                        PROCESSED_FILES="$PROCESSED_FILES $source_inode"
                        log_processed_extra "$extra_file"
                        ((extras_count++))
                    else
                        if $USE_COPY; then
                            cp "$extra_file" "$dest_extra" 2>/dev/null
                        elif $USE_SYMLINK; then
                            ln -s "$extra_file" "$dest_extra"
                        else
                            ln "$extra_file" "$dest_extra" 2>/dev/null || cp "$extra_file" "$dest_extra" 2>/dev/null
                        fi
                        PROCESSED_FILES="$PROCESSED_FILES $source_inode"
                        log_processed_extra "$extra_file"
                        ((extras_count++))
                    fi
                done < <(find "$extras_dir" -type f \( -iname "*.mkv" -o -iname "*.mp4" -o -iname "*.avi" -o -iname "*.m4v" -o -iname "*.mov" -o -iname "*.vob" -o -iname "*.wmv" -o -iname "*.flv" -o -iname "*.webm" -o -iname "*.ts" -o -iname "*.m2ts" -o -iname "*.mpg" -o -iname "*.mpeg" -o -iname "*.srt" -o -iname "*.sub" -o -iname "*.idx" -o -iname "*.ass" -o -iname "*.ssa" \) -print0)
            done < <(find "$search_base_dir" -maxdepth 1 -type d -iname "$folder_name" -print0)
        done
        
        # Process loose extras files (not in folders) - categorize by filename
        # Also search inside "extras", "bonus", and "other" folders with maxdepth 2
        # Use parallel processing with rolling queue for better performance
        
        # Create temp file for tracking processed inodes (thread-safe)
        local PROCESSED_INODES_FILE=$(mktemp "${TMPDIR:-/tmp}/processed_inodes.XXXXXX")
        
        # Export variables needed by background processes
        export DESTINATION
        export USE_COPY
        export USE_SYMLINK
        export EXTRAS_SKIPPED_FILE
        export EXTRAS_PROCESSED_FILE
        export PROCESSED_INODES_FILE
        
        # Function to process a single extra file (will be run in background)
        process_loose_extra() {
            local extra_file="$1"
            local search_base_dir="$2"
            local series_folder="$3"
            
            local extra_basename=$(basename "$extra_file")
            local extra_lower=$(echo "$extra_basename" | tr '[:upper:]' '[:lower:]')
            
            # Skip if this is NOT an extras file (has S##E## but no extras keywords)
            if [[ "$extra_basename" =~ [Ss][0-9]{1,2}[Ee][0-9]{1,2} ]] || [[ "$extra_basename" =~ [0-9]{1,2}x[0-9]{1,2} ]]; then
                # Has episode pattern - only process if it has extras keywords
                if ! [[ "$extra_lower" =~ (behind.?the.?scene|bts|making.?of|deleted.?scene|interview|featurette|trailer|bonus|short|sample|clip|extra|extended|alternate|unused|outtake|gag.?reel) ]]; then
                    return 0  # Skip - this is a regular episode file
                fi
                
                # Additional check: Extract series title from this file to verify it matches current series
                # This prevents episodes from OTHER shows being processed as extras
                local extra_file_series=$(basename "$extra_file")
                extra_file_series=$(echo "$extra_file_series" | sed -E 's/[[:space:]]*[-._]*[[:space:]]*[Ss][0-9]{1,2}[Ee][0-9]{1,2}.*//')
                extra_file_series=$(echo "$extra_file_series" | sed -E 's/[[:space:]]*[-._]*[[:space:]]*[0-9]{1,2}x[0-9]{1,2}.*//')
                extra_file_series=$(echo "$extra_file_series" | sed 's/[._]/ /g' | sed 's/  */ /g' | sed 's/^ //;s/ $//')
                
                # Get the current series title from the search_base_dir
                local current_series=$(basename "$search_base_dir")
                # Remove IDs and clean up
                current_series=$(echo "$current_series" | sed -E 's/[[:space:]]*\[(imdb|imdbid|tmdb|tmdbid|tvdb|tvdbid|tvmaze|tvmazeid)-[0-9]+\].*$//')
                current_series=$(echo "$current_series" | sed -E 's/[[:space:]]*\([0-9]{4}\)[[:space:]]*$//')  # Remove year
                current_series=$(echo "$current_series" | sed 's/[._]/ /g' | sed 's/  */ /g' | sed 's/^ //;s/ $//')
                
                # Convert both to lowercase for comparison
                local extra_series_lower=$(echo "$extra_file_series" | tr '[:upper:]' '[:lower:]')
                local current_series_lower=$(echo "$current_series" | tr '[:upper:]' '[:lower:]')
                
                # Skip if the series names don't match (prevents cross-show contamination)
                if [[ ! "$extra_series_lower" =~ $current_series_lower ]] && [[ ! "$current_series_lower" =~ $extra_series_lower ]]; then
                    return 0  # Skip - this episode belongs to a different TV show
                fi
            fi
            
            # Determine which extras folder this file belongs to based on filename
            # Check most specific patterns first to avoid false matches
            local target_folder=""
            if [[ "$extra_lower" =~ deleted.?scene ]]; then
                target_folder="deleted scenes"
            elif [[ "$extra_lower" =~ (behind.?the.?scenes|bts|making.?of) ]]; then
                target_folder="behind the scenes"
            elif [[ "$extra_lower" =~ interview ]]; then
                target_folder="interviews"
            elif [[ "$extra_lower" =~ featurette ]]; then
                target_folder="featurettes"
            elif [[ "$extra_lower" =~ trailer ]]; then
                target_folder="trailers"
            elif [[ "$extra_lower" =~ sample ]]; then
                target_folder="samples"
            elif [[ "$extra_lower" =~ short ]]; then
                target_folder="shorts"
            elif [[ "$extra_lower" =~ (extended|alternate.?scene|unused.?footage|outtake|gag.?reel|scene|clip) ]]; then
                target_folder="scenes"
            elif [[ "$extra_lower" =~ (extra|bonus) ]]; then
                target_folder="extras"
            else
                # Default catch-all
                target_folder="other"
            fi
            
            # Check if extra file has a season number in filename (S##E##, ##x##, S##, Season ##)
            # Be strict: S## must be followed by E, space, dash, or end - not "Extra" or other letters
            local extra_season=""
            local extra_parent=$(dirname "$extra_file")
            local extra_parent_name=$(basename "$extra_parent")
            
            if [[ "$extra_basename" =~ [Ss]([0-9]{1,2})[Ee][0-9]{1,2} ]]; then
                extra_season="${BASH_REMATCH[1]}"
            elif [[ "$extra_basename" =~ ([0-9]{1,2})x[0-9]{1,2} ]]; then
                extra_season="${BASH_REMATCH[1]}"
            elif [[ "$extra_basename" =~ [Ss]([0-9]{1,2})\.[0-9] ]]; then
                # Matches S05.2 format
                extra_season="${BASH_REMATCH[1]}"
            elif [[ "$extra_basename" =~ [Ss]([0-9]{1,2})[Ee]xtra ]]; then
                extra_season="${BASH_REMATCH[1]}"
            elif [[ "$extra_basename" =~ [Ss]([0-9]{1,2})([[:space:]]|\-|$) ]]; then
                extra_season="${BASH_REMATCH[1]}"
            elif [[ "$extra_basename" =~ [Ss]eason[[:space:]]?([0-9]{1,2}) ]]; then
                extra_season="${BASH_REMATCH[1]}"
            fi
            
            # If no season in filename, check parent directory name
            if [[ -z "$extra_season" ]]; then
                if [[ "$extra_parent_name" =~ [Ss]([0-9]{1,2})[Ee][0-9]{1,2} ]]; then
                    extra_season="${BASH_REMATCH[1]}"
                elif [[ "$extra_parent_name" =~ ([0-9]{1,2})x[0-9]{1,2} ]]; then
                    extra_season="${BASH_REMATCH[1]}"
                elif [[ "$extra_parent_name" =~ [Ss]([0-9]{1,2})\.[0-9] ]]; then
                    extra_season="${BASH_REMATCH[1]}"
                elif [[ "$extra_parent_name" =~ [Ss]([0-9]{1,2})[Ee]xtra ]]; then
                    extra_season="${BASH_REMATCH[1]}"
                elif [[ "$extra_parent_name" =~ [Ss]([0-9]{1,2})([[:space:]]|\-|$) ]]; then
                    extra_season="${BASH_REMATCH[1]}"
                elif [[ "$extra_parent_name" =~ [Ss]eason[[:space:]]?([0-9]{1,2}) ]]; then
                    extra_season="${BASH_REMATCH[1]}"
                fi
            fi
            
            # Don't use TV_SEASON fallback - extras without clear season go to series root
            
            # Determine destination: if extra has season number, place in that season folder
            local dest_extras_dir
            if [[ -n "$extra_season" ]]; then
                # Format season number with leading zero (force decimal to avoid octal issues)
                extra_season=$((10#$extra_season))
                local season_num=$(printf "%02d" "$extra_season")
                # Always place in season folder if we have a season number
                dest_extras_dir="${DESTINATION}/${series_folder}/Season ${season_num}/$(echo "$target_folder" | tr '[:upper:]' '[:lower:]')"
            else
                # No season number, place in series root
                dest_extras_dir="${DESTINATION}/${series_folder}/$(echo "$target_folder" | tr '[:upper:]' '[:lower:]')"
            fi
            
            local dest_extra="${dest_extras_dir}/${extra_basename}"
            
            # Get inode for tracking
            local source_inode=$(stat -f "%i" "$extra_file" 2>/dev/null || stat -c "%i" "$extra_file" 2>/dev/null)
            
            # Check if this file was already processed (thread-safe file check)
            if grep -q "^${source_inode}$" "$PROCESSED_INODES_FILE" 2>/dev/null; then
                log_skipped_extra "$extra_file" "already_processed"
                return 0
            fi
            
            # Create destination folder only if we're actually going to process this file
            mkdir -p "$dest_extras_dir"
            
            # Check if extra file already exists and is hardlinked (skip if already correct)
            if [[ -f "$dest_extra" ]]; then
                local dest_inode=$(stat -f "%i" "$dest_extra" 2>/dev/null || stat -c "%i" "$dest_extra" 2>/dev/null)
                
                # If already hardlinked to same source, skip (no need to increment counter)
                if [[ "$source_inode" == "$dest_inode" ]]; then
                    echo "$source_inode" >> "$PROCESSED_INODES_FILE"
                    log_skipped_extra "$extra_file" "already_exists"
                    return 0
                fi
                
                # In copy mode, check if files are identical before replacing
                if $USE_COPY && files_are_identical "$extra_file" "$dest_extra"; then
                    echo "$source_inode" >> "$PROCESSED_INODES_FILE"
                    log_skipped_extra "$extra_file" "already_exists"
                    return 0
                fi
                
                # Different file exists, replace it
                rm "$dest_extra"
                if $USE_COPY; then
                    cp "$extra_file" "$dest_extra" 2>/dev/null
                elif $USE_SYMLINK; then
                    ln -s "$extra_file" "$dest_extra"
                else
                    ln "$extra_file" "$dest_extra" 2>/dev/null || cp "$extra_file" "$dest_extra"
                fi
                echo "$source_inode" >> "$PROCESSED_INODES_FILE"
                log_processed_extra "$extra_file"
                return 1  # Return 1 to indicate file was processed
            else
                if $USE_COPY; then
                    cp "$extra_file" "$dest_extra" 2>/dev/null
                elif $USE_SYMLINK; then
                    ln -s "$extra_file" "$dest_extra"
                else
                    ln "$extra_file" "$dest_extra" 2>/dev/null || cp "$extra_file" "$dest_extra" 2>/dev/null
                fi
                echo "$source_inode" >> "$PROCESSED_INODES_FILE"
                log_processed_extra "$extra_file"
                return 1  # Return 1 to indicate file was processed
            fi
        }
        
        # Export the functions so they're available to background processes
        export -f process_loose_extra
        export -f log_skipped_extra
        export -f log_processed_extra
        export -f files_are_identical
        
        # Collect all loose extras files into an array
        local -a loose_extras_files=()
        while IFS= read -r -d '' extra_file; do
            loose_extras_files+=("$extra_file")
        done < <(find "$search_base_dir" -maxdepth 2 -type f \( -iname "*behind*the*scene*" -o -iname "*bts*" -o -iname "*making*of*" -o -iname "*deleted*scene*" -o -iname "*interview*" -o -iname "*featurette*" -o -iname "*trailer*" -o -iname "*bonus*" -o -iname "*short*" -o -iname "*sample*" -o -iname "*clip*" -o -iname "*extra*" -o -iname "*extended*" -o -iname "*alternate*" -o -iname "*unused*" -o -iname "*outtake*" -o -iname "*gag*reel*" \) \( -iname "*.mkv" -o -iname "*.mp4" -o -iname "*.avi" -o -iname "*.m4v" -o -iname "*.mov" -o -iname "*.vob" -o -iname "*.wmv" -o -iname "*.flv" -o -iname "*.webm" -o -iname "*.ts" -o -iname "*.m2ts" -o -iname "*.mpg" -o -iname "*.mpeg" \) -print0)
        
        # Process loose extras in parallel using rolling queue
        if [[ ${#loose_extras_files[@]} -gt 0 ]]; then
            local loose_extras_jobs=()
            local loose_extras_processed=0
            
            for extra_file in "${loose_extras_files[@]}"; do
                # Wait if we've hit the parallel job limit
                while [[ ${#loose_extras_jobs[@]} -ge ${PARALLEL_JOBS:-4} ]]; do
                    for i in "${!loose_extras_jobs[@]}"; do
                        if ! kill -0 "${loose_extras_jobs[$i]}" 2>/dev/null; then
                            # Job finished, check exit status
                            wait "${loose_extras_jobs[$i]}"
                            local job_status=$?
                            [[ $job_status -eq 1 ]] && ((extras_count++))
                            unset "loose_extras_jobs[$i]"
                        fi
                    done
                    loose_extras_jobs=("${loose_extras_jobs[@]}")  # Re-index array
                    [[ ${#loose_extras_jobs[@]} -ge ${PARALLEL_JOBS:-4} ]] && sleep 0.1
                done
                
                # Start processing this extra file in background
                process_loose_extra "$extra_file" "$search_base_dir" "$series_folder" &
                loose_extras_jobs+=($!)
            done
            
            # Wait for remaining jobs to complete
            for job_pid in "${loose_extras_jobs[@]}"; do
                wait "$job_pid"
                local job_status=$?
                [[ $job_status -eq 1 ]] && ((extras_count++))
            done
            
            # Cleanup: unexport functions and variables, remove temp file
            export -fn process_loose_extra 2>/dev/null || true
            export -fn log_skipped_extra 2>/dev/null || true
            export -fn log_processed_extra 2>/dev/null || true
            export -fn files_are_identical 2>/dev/null || true
            rm -f "$PROCESSED_INODES_FILE"
        fi
        
            [[ $extras_count -gt 0 ]] && print_success "✓ Linked $extras_count extras file(s)"
        elif [[ "$HARDLINK_EXTRAS" == "preserve" ]]; then
            # Preserve folder structure mode - only hardlink video files and SRT files
            local extras_count=0
            
            # Mirror the entire directory structure from search_base_dir, but only hardlink video and subtitle files
            while IFS= read -r -d '' source_file; do
                local source_inode=$(stat -f "%i" "$source_file" 2>/dev/null || stat -c "%i" "$source_file" 2>/dev/null)
                
                # Skip if already processed
                if [[ " $PROCESSED_FILES " =~ " $source_inode " ]]; then
                    log_skipped_extra "$source_file" "already_processed"
                    continue
                fi
                
                # Get the relative path from search_base_dir
                local rel_path="${source_file#$search_base_dir/}"
                
                # Create the destination path preserving folder structure
                local dest_file="${movie_dir}/${rel_path}"
                local dest_dir=$(dirname "$dest_file")
                
                # Create the directory structure if it doesn't exist
                mkdir -p "$dest_dir"
                
                # Check if destination already exists and is the same inode
                if [[ -f "$dest_file" ]]; then
                    local dest_inode=$(stat -f "%i" "$dest_file" 2>/dev/null || stat -c "%i" "$dest_file" 2>/dev/null)
                    if [[ "$source_inode" == "$dest_inode" ]]; then
                        PROCESSED_FILES="$PROCESSED_FILES $source_inode"
                        log_skipped_extra "$source_file" "already_exists"
                        continue
                    fi
                fi
                
                # Create hardlink
                if $USE_COPY; then
                    cp "$source_file" "$dest_file"
                elif $USE_SYMLINK; then
                    ln -s "$source_file" "$dest_file"
                else
                    ln "$source_file" "$dest_file" 2>/dev/null || cp "$source_file" "$dest_file"
                fi
                PROCESSED_FILES="$PROCESSED_FILES $source_inode"
                log_processed_extra "$source_file"
                ((extras_count++))
            done < <(find "$search_base_dir" -maxdepth 2 -type f \( -iname "*.mkv" -o -iname "*.mp4" -o -iname "*.avi" -o -iname "*.m4v" -o -iname "*.mov" -o -iname "*.vob" -o -iname "*.wmv" -o -iname "*.flv" -o -iname "*.webm" -o -iname "*.ts" -o -iname "*.m2ts" -o -iname "*.mpg" -o -iname "*.mpeg" -o -iname "*.srt" -o -iname "*.sub" -o -iname "*.idx" -o -iname "*.ass" -o -iname "*.ssa" -o -iname "*.vtt" \) -print0)
            
            [[ $extras_count -gt 0 ]] && print_success "✓ Linked $extras_count extras file(s) preserving original folder structure"
        fi  # End of disabled extras processing block
        ### END OF DISABLED EXTRAS PROCESSING CODE
        # ========================================================================
    
    return 0
}

# TV show naming scheme selection
select_tv_naming_scheme() {
    local start_step="${1:-1}"  # Optional parameter: which step to start at (default: 1)
    local scheme_file="${CACHE_DIR}/tv_naming_scheme.txt"
    
    # TV Show folder format options
    local -a tv_folder_opts=(
        "0|Standard - {Series TitleYear}"
        "1|Plex (IMDb) - {Series TitleYear} {imdb-IMDbId}"
        "2|Plex (TMDb) - {Series TitleYear} {tmdb-TMDbId}"
        "3|Plex (TVDb) - {Series TitleYear} {tvdb-TVDbId}"
        "4|Emby (IMDb) - {Series TitleYear} [imdb-IMDbId]"
        "5|Emby (TMDb) - {Series TitleYear} [tmdb-TMDbId]"
        "6|Emby (TVDb) - {Series TitleYear} [tvdb-TVDbId]"
        "7|Jellyfin (TVDb) - {Series TitleYear} [tvdbid-TVDbId]"
        "8|Jellyfin (IMDb) - {Series TitleYear} [imdb-ttIMDbId]"
        "9|Jellyfin (TMDb) - {Series TitleYear} [tmdbid-TMDbId]"
    )
    
    # TV Episode format options
    local -a tv_episode_opts=(
        "0|Standard - TRaSH - S##E## - Episode Title"
        "1|Daily - TRaSH - YYYY-MM-DD - Episode Title"
        "2|Anime - TRaSH - S##E## - ### - Episode Title"
    )
    
    # Link type options
    local -a link_type_opts=(
        "0|Hardlink (recommended)"
        "1|Symlink"
    )
    
    # Episode renaming options
    local -a tv_rename_opts=(
        "true|Renames episodes using the format chosen in previous menu (Standard/Daily/Anime)"
        "tmdb|Renames episodes using TMDb episode titles + TRaSH guides + format chosen in previous menu"
        "false|Ignores the previous menu choice and keeps original episode filenames"
    )
    
    # Poster display options
    local -a tv_poster_opts=(
        "yes|Display posters in terminal (requires chafa/imgcat)"
        "no|Skip poster display (faster processing)"
    )
    
    # Extras handling options
    local -a tv_extras_opts=(
        "false|Don't link extras/bonus content"
        "true|Link extras into categorized subfolders (deleted scenes, behind the scenes, etc.)"
        "preserve|Link with preserved folder structure (only video and subtitle files)"
    )
    
    # Cache options
    local tv_cache_files=(
        "tvshow|SHOWS TV CACHE.txt|Standard TV Shows"
        "anime|SHOWS ANIME CACHE.txt|Anime TV Shows"
        "cartoons|SHOWS CARTOONS CACHE.txt|Cartoon TV Shows"
    )
    
    # Load saved selections or use defaults
    TV_NAMING_FOLDER=0
    TV_NAMING_EPISODE=0
    TV_LINK_TYPE="hardlink"
    
    if [[ -f "$scheme_file" ]]; then
        source "$scheme_file"
    fi
    
    local saved_tv_rename="true"
    if [[ -f "$TV_RENAME_EPISODES_PREFS" ]]; then
        saved_tv_rename=$(cat "$TV_RENAME_EPISODES_PREFS")
    fi
    
    local saved_tv_poster="yes"
    if [[ -f "$TV_POSTER_PREFS" ]]; then
        saved_tv_poster=$(cat "$TV_POSTER_PREFS")
    fi
    
    local saved_tv_extras="false"
    if [[ -f "$TV_EXTRAS_MODE_PREFS" ]]; then
        saved_tv_extras=$(cat "$TV_EXTRAS_MODE_PREFS")
    elif [[ -n "$HARDLINK_EXTRAS" ]]; then
        saved_tv_extras="$HARDLINK_EXTRAS"
    fi
    
    local tv_cache_file="$CACHE_DIR/tv_cache_mode.txt"
    local saved_tv_cache="tvshow"
    if [[ -f "$tv_cache_file" ]]; then
        saved_tv_cache=$(cat "$tv_cache_file")
    fi
    
    # Step-based navigation: 1=folder, 2=episode, 3=renaming, 4=link, 5=poster, 6=extras, 7=cache
    local current_step="$start_step"  # Use provided start step
    local folder_choice="$TV_NAMING_FOLDER"
    local episode_choice="$TV_NAMING_EPISODE"
    local rename_choice="$saved_tv_rename"
    local link_choice
    [[ "$TV_LINK_TYPE" == "symlink" ]] && link_choice=1 || link_choice=0
    local poster_choice="$saved_tv_poster"
    local extras_choice="$saved_tv_extras"
    local cache_choice="$saved_tv_cache"
    
    while true; do
        case $current_step in
            1)  # Folder format
                if arrow_select_menu "TV SERIES FOLDER FORMAT" "$folder_choice" "folder_choice" "${tv_folder_opts[@]}"; then
                    TV_NAMING_FOLDER="$folder_choice"
                    current_step=2
                else
                    return 1  # Back from first step = exit
                fi
                ;;
                
            2)  # Episode format
                if arrow_select_menu "TV EPISODE FORMAT|Choose the naming pattern for renamed episodes" "$episode_choice" "episode_choice" "${tv_episode_opts[@]}"; then
                    TV_NAMING_EPISODE="$episode_choice"
                    current_step=3
                else
                    current_step=1  # Back to folder
                fi
                ;;
                
            3)  # Episode renaming
                # Determine current selection: prioritize saved preference, then current runtime state
                if [[ "$saved_tv_rename" == "tmdb" ]]; then
                    rename_choice="tmdb"
                elif [[ "$TV_FETCH_TMDB_TITLES" == "true" ]]; then
                    rename_choice="tmdb"
                elif [[ "$saved_tv_rename" == "false" ]]; then
                    rename_choice="false"
                elif [[ "$TV_RENAME_EPISODES" == "false" ]]; then
                    rename_choice="false"
                else
                    rename_choice="true"
                fi
                
                if arrow_select_menu "TV EPISODE RENAMING|Keep original filenames or rename to selected format" "$rename_choice" "rename_choice" "${tv_rename_opts[@]}"; then
                    # Handle tmdb option
                    if [[ "$rename_choice" == "tmdb" ]]; then
                        # Check if TMDb API key is configured
                        if [[ -z "$TMDB_API_KEY" ]]; then
                            print_warning "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                            print_warning "TMDb API key not configured!"
                            print_warning "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                            echo ""
                            print_info "The 'TMDb episode titles' option requires a TMDb API key."
                            print_info "Without it, episodes will be named without titles (just S##E##)."
                            echo ""
                            print_info "To get a free TMDb API key:"
                            print_info "  1. Create account at: https://www.themoviedb.org"
                            print_info "  2. Go to: Settings → API → Request API Key"
                            print_info "  3. Enter it in this script's Settings menu"
                            echo ""
                            read -p "Press ENTER to continue anyway, or Ctrl+C to exit..."
                        fi
                        TV_RENAME_EPISODES="true"
                        TV_FETCH_TMDB_TITLES="true"
                    else
                        TV_RENAME_EPISODES="$rename_choice"
                        TV_FETCH_TMDB_TITLES="false"
                    fi
                    echo "$rename_choice" > "$TV_RENAME_EPISODES_PREFS"
                    current_step=4
                else
                    current_step=2  # Back to episode format
                fi
                ;;
                
            4)  # Link type
                if arrow_select_menu "TV LINK TYPE" "$link_choice" "link_choice" "${link_type_opts[@]}"; then
                    [[ "$link_choice" == "0" ]] && TV_LINK_TYPE="hardlink" || TV_LINK_TYPE="symlink"
                    current_step=5
                else
                    current_step=3  # Back to renaming
                fi
                ;;
                
            5)  # Poster display
                if arrow_select_menu "SERIES POSTER DISPLAY" "$poster_choice" "poster_choice" "${tv_poster_opts[@]}"; then
                    echo "$poster_choice" > "$TV_POSTER_PREFS"
                    SHOW_SERIES_POSTERS="$poster_choice"
                    current_step=6
                else
                    current_step=4  # Back to link type
                fi
                ;;
                
            6)  # Extras handling
                if arrow_select_menu "SERIES EXTRAS HANDLING" "$extras_choice" "extras_choice" "${tv_extras_opts[@]}"; then
                    HARDLINK_EXTRAS="$extras_choice"
                    echo "$extras_choice" > "$TV_EXTRAS_MODE_PREFS"
                    current_step=7
                else
                    current_step=5  # Back to poster
                fi
                ;;
                
            7)  # Cache selection
                # Build cache options
                local -a tv_cache_opts=()
                for cache_entry in "${tv_cache_files[@]}"; do
                    local mode=$(echo "$cache_entry" | cut -d'|' -f1)
                    local display=$(echo "$cache_entry" | cut -d'|' -f3)
                    tv_cache_opts+=("$mode|$display")
                done
                tv_cache_opts+=("manage|📋 Manage Series Caches (Clear/Reset)")
                tv_cache_opts+=("manage_episodes|📺 Manage Episode Caches (Clear/Reset)")
                
                if arrow_select_menu "SERIES CACHE SELECTION" "$cache_choice" "cache_choice" "${tv_cache_opts[@]}"; then
                    if [[ "$cache_choice" == "manage" ]]; then
                        manage_series_caches
                        continue  # Stay on cache step
                    elif [[ "$cache_choice" == "manage_episodes" ]]; then
                        manage_episode_caches
                        continue  # Stay on cache step
                    fi
                    echo "$cache_choice" > "$tv_cache_file"
                    TV_CACHE_MODE="$cache_choice"
                    SESSION_TV_CACHE_MODE="$cache_choice"
                    break  # All steps complete, exit loop
                else
                    current_step=6  # Back to extras
                fi
                ;;
        esac
    done
    
    # Save all selections
    cat > "$scheme_file" <<EOF
TV_NAMING_FOLDER=$TV_NAMING_FOLDER
TV_NAMING_EPISODE=$TV_NAMING_EPISODE
TV_LINK_TYPE="$TV_LINK_TYPE"
EOF
    
    # Save TV_LINK_TYPE separately for Quick TV Shows compatibility
    echo "$TV_LINK_TYPE" > "${CACHE_DIR}/tv_link_type.txt"
    
    return 0
}

# Interactive TV show mode
interactive_tv_mode() {
    # Note: Dependencies already checked in main interactive_mode
    
    # Check if this is a quick mode call (settings already loaded)
    local skip_settings="${1:-false}"
    
    if [[ "$skip_settings" != "true" ]]; then
        clear
        echo ""
        print_info "========================================="
        print_info "TV Show Hardlink/Symlink Manager"
        print_info "========================================="
        echo ""
        
        # Menu navigation loop
        local naming_start_step=1  # Start at first step initially
        while true; do
            # Select TV naming scheme (includes folder, episode, renaming, link type, poster, extras, cache)
            # Pass start step - will be 7 (cache) when returning from mediainfo back button
            if ! select_tv_naming_scheme "$naming_start_step"; then
                # User backed out from naming scheme, return to mode selection
                return 1
            fi
            
            # Reset to step 1 for next iteration (in case they complete and come back)
            naming_start_step=1
        
            # Load TV extras preference (separate from movie extras)
            if [[ -f "$TV_EXTRAS_MODE_PREFS" ]]; then
                HARDLINK_EXTRAS=$(cat "$TV_EXTRAS_MODE_PREFS")
            else
                HARDLINK_EXTRAS="false"  # Default to not linking extras for TV
            fi
            
            # Set TV cache file based on cache mode (selected inside naming scheme)
            local tv_cache_file="$CACHE_DIR/tv_cache_mode.txt"
            # Check session variable first (for multi-instance support), fallback to disk file
            if [[ -n "${SESSION_TV_CACHE_MODE:-}" ]]; then
                TV_CACHE_MODE="$SESSION_TV_CACHE_MODE"
            elif [[ -f "$tv_cache_file" ]]; then
                TV_CACHE_MODE=$(cat "$tv_cache_file")
            else
                TV_CACHE_MODE="tvshow"
            fi
            
            case "$TV_CACHE_MODE" in
                anime)
                    TV_CACHE_FILE="$ANIME_CACHE_FILE"
                    ;;
                cartoons)
                    TV_CACHE_FILE="$CARTOON_TV_CACHE_FILE"
                    ;;
                *)
                    TV_CACHE_FILE="$CACHE_DIR/SHOWS TV CACHE.txt"
                    ;;
            esac
            
            # Set lock directory based on TV cache selection
            PROCESSING_LOCKS_DIR="/tmp/movie_simulator_locks_tv_${TV_CACHE_MODE}"
            mkdir -p "$PROCESSING_LOCKS_DIR" 2>/dev/null
            
            # Set USE_SYMLINK and USE_COPY flags based on TV_LINK_TYPE (for consistent behavior with movies)
            if [[ "$TV_LINK_TYPE" == "symlink" ]]; then
                USE_SYMLINK=true
                USE_COPY=false
            else
                USE_SYMLINK=false
                USE_COPY=false
            fi
            
            # Select MediaInfo tool
            if select_mediainfo_tool; then
                # All selections completed successfully
                break
            fi
            # If MediaInfo tool selection returned 1 (back pressed), loop back to naming scheme at step 7 (cache)
            naming_start_step=7
        done
    else
        # Quick mode - settings already loaded, just set up cache and locks
        
        # Load TV extras preference (separate from movie extras)
        if [[ -f "$TV_EXTRAS_MODE_PREFS" ]]; then
            HARDLINK_EXTRAS=$(cat "$TV_EXTRAS_MODE_PREFS")
        else
            HARDLINK_EXTRAS="false"  # Default to not linking extras for TV
        fi
        
        # TV cache already selected in Quick TV mode, just set the file path
        local tv_cache_file="$CACHE_DIR/tv_cache_mode.txt"
        if [[ -n "${SESSION_TV_CACHE_MODE:-}" ]]; then
            TV_CACHE_MODE="$SESSION_TV_CACHE_MODE"
        elif [[ -f "$tv_cache_file" ]]; then
            TV_CACHE_MODE=$(cat "$tv_cache_file")
        else
            TV_CACHE_MODE="tvshow"
        fi
        
        case "$TV_CACHE_MODE" in
            anime)
                TV_CACHE_FILE="$ANIME_CACHE_FILE"
                ;;
            cartoons)
                TV_CACHE_FILE="$CARTOON_TV_CACHE_FILE"
                ;;
            *)
                TV_CACHE_FILE="$CACHE_DIR/SHOWS TV CACHE.txt"
                ;;
        esac
        
        # Set lock directory based on TV cache selection
        PROCESSING_LOCKS_DIR="/tmp/movie_simulator_locks_tv_${TV_CACHE_MODE}"
        mkdir -p "$PROCESSING_LOCKS_DIR" 2>/dev/null
        
        # Set USE_SYMLINK and USE_COPY flags based on TV_LINK_TYPE
        if [[ "$TV_LINK_TYPE" == "symlink" ]]; then
            USE_SYMLINK=true
            USE_COPY=false
        else
            USE_SYMLINK=false
            USE_COPY=false
        fi
    fi
    
    stty echo 2>/dev/null
    print_info "Drag and drop TV episode source(s) - multiple files/folders (ENTER/RETURN):"
    read -r SOURCE_INPUT || exit 0
    
    print_info "Drag and drop destination folder for TV shows (ENTER/RETURN):"
    read -r DESTINATION || exit 0
    stty -echo 2>/dev/null
    DESTINATION=$(echo "$DESTINATION" | sed "s/^['\"]//;s/['\"]$//;s/\\\\ / /g;s/\\\\$//;s/[[:space:]]*$//")
    
    if [[ ! -d "$DESTINATION" ]]; then
        print_error "Destination must be a directory"
        exit 1
    fi
    
    # Parse multiple sources
    local -a SOURCES=()
    SOURCE_INPUT="${SOURCE_INPUT#"${SOURCE_INPUT%%[![:space:]]*}"}"
    SOURCE_INPUT="${SOURCE_INPUT%"${SOURCE_INPUT##*[![:space:]]}"}"
    
    # Check if input looks like a single pasted path (not drag-and-drop with quotes/escapes)
    # Drag-and-drop typically has quotes or backslash-escaped spaces
    if [[ ! "$SOURCE_INPUT" =~ [\'\"] ]] && [[ ! "$SOURCE_INPUT" =~ \\ ]]; then
        # Single pasted path - treat entire input as one path
        SOURCES+=("$SOURCE_INPUT")
    else
        # Drag-and-drop format - use eval to parse quotes and escapes
        eval "local -a temp_sources=($SOURCE_INPUT)"
        
        for source in "${temp_sources[@]}"; do
            [[ -z "$source" ]] && continue
            source="${source#\"}"
            source="${source%\"}"
            source="${source#\'}"
            source="${source%\'}"
            [[ -n "$source" ]] && SOURCES+=("$source")
        done
    fi
    
    if [[ ${#SOURCES[@]} -eq 0 ]]; then
        print_error "No sources provided"
        exit 1
    fi
    
    print_success "Found ${#SOURCES[@]} source(s) to process"
    echo ""
    
    stty echo 2>/dev/null
    print_info "Process all episodes automatically? (y/n):"
    read -r AUTO_MODE
    echo ""
    
    local total_success=0
    local total_failed=0
    local total_skipped=0
    local total_files_found=0
    local total_excluded_by_detection=0
    local total_extras_processed=0
    local total_extras_skipped=0
    local total_ia_skipped=0
    local -a FAILED_EPISODES=()
    local -a SKIPPED_EXTRAS=()  # Track skipped extras with reasons
    local -a IA_SKIPPED=()  # Track .ia files skipped
    
    # Track overall statistics across all sources
    local overall_start_time=$SECONDS
    local overall_size=0
    local overall_cache_before=0
    [[ -f "$TV_CACHE_FILE" ]] && overall_cache_before=$(awk 'NF' "$TV_CACHE_FILE" 2>/dev/null | wc -l | tr -d ' ' || echo 0)
    
    # Initialize API counter file ONCE for entire session (parallel processes append to this)
    export API_COUNTER_FILE="${CACHE_DIR}/.api_counter_$$.tmp"
    > "$API_COUNTER_FILE"  # Create empty file
    
    # Initialize extras tracking files for parallel processing
    export EXTRAS_PROCESSED_FILE="${CACHE_DIR}/.extras_processed_$$.tmp"
    export EXTRAS_SKIPPED_FILE="${CACHE_DIR}/.extras_skipped_$$.tmp"
    export IA_SKIPPED_FILE="${CACHE_DIR}/.ia_skipped_$$.tmp"
    > "$EXTRAS_PROCESSED_FILE"  # Create empty files
    > "$EXTRAS_SKIPPED_FILE"
    > "$IA_SKIPPED_FILE"
    
    # Use index-based loop so we can add sources dynamically (container folder expansion)
    local source_index=0
    while [[ $source_index -lt ${#SOURCES[@]} ]]; do
        SOURCE="${SOURCES[$source_index]}"
        ((source_index++))
        
        if [[ ! -e "$SOURCE" ]]; then
            print_error "Source not found: $SOURCE"
            ((total_failed++))
            FAILED_EPISODES+=("$SOURCE (not found)")
            continue
        fi
        
        print_info "========================================="
        print_info "Processing: $SOURCE"
        print_info "========================================="
        echo ""
        
        # Check if this is a download container folder
        # If so, process each subfolder as a separate series instead
        if [[ -d "$SOURCE" ]]; then
            local source_folder_name=$(basename "$SOURCE")
            
            # Check if this is an extras-type folder name
            local lower_folder_name=$(echo "$source_folder_name" | tr '[:upper:]' '[:lower:]')
            local is_extras_folder=false
            if [[ "$lower_folder_name" == "featurettes" ]] || \
               [[ "$lower_folder_name" == "extras" ]] || \
               [[ "$lower_folder_name" == "behind the scenes" ]] || \
               [[ "$lower_folder_name" == "deleted scenes" ]] || \
               [[ "$lower_folder_name" == "interviews" ]] || \
               [[ "$lower_folder_name" == "specials" ]] || \
               [[ "$lower_folder_name" == "bonus" ]] || \
               [[ "$lower_folder_name" == "bonus features" ]]; then
                is_extras_folder=true
            fi
            
            # If it's an extras folder, check if it contains proper episodes (S##E##)
            # If yes, process normally. If no, skip it.
            if [[ "$is_extras_folder" == "true" ]]; then
                local episode_files=$(find "$SOURCE" -type f \( -iname "*S[0-9][0-9]E[0-9][0-9]*" -o -iname "*s[0-9][0-9]e[0-9][0-9]*" \) 2>/dev/null | head -1)
                if [[ -n "$episode_files" ]]; then
                    should_debug high && print_info "[DEBUG] Extras folder '$source_folder_name' contains episodes - processing normally" >&2
                    # Has proper episodes - continue with normal processing (don't skip, don't treat as container)
                else
                    should_debug high && print_info "[DEBUG] Skipping extras folder without episodes: $source_folder_name" >&2
                    print_info "⚠ Skipping extras folder: $source_folder_name (no episodes found, use HARDLINK_EXTRAS=true to include)"
                    echo ""
                    continue
                fi
            fi
            
            # Quick check: if folder has subfolders but no videos at root, might need expansion
            # BUT: if subfolders are "Season X" folders, this is a show folder - don't expand
            local root_video_count=$(find "$SOURCE" -maxdepth 1 -type f \( -iname "*.mkv" -o -iname "*.mp4" -o -iname "*.avi" -o -iname "*.m4v" \) 2>/dev/null | wc -l | tr -d ' ')
            local subfolder_count=$(find "$SOURCE" -maxdepth 1 -mindepth 1 -type d 2>/dev/null | wc -l | tr -d ' ')
            
            if [[ $root_video_count -eq 0 ]] && [[ $subfolder_count -gt 0 ]]; then
                # Check if any subfolder looks like a Season folder
                local has_season_folders=false
                while IFS= read -r -d '' subfolder; do
                    local subfolder_name=$(basename "$subfolder")
                    # Check for Season patterns: "Season 1", "S01", "Season 1 (2018)", etc.
                    if [[ "$subfolder_name" =~ ^[Ss]eason[[:space:]]*[0-9] ]] || \
                       [[ "$subfolder_name" =~ ^[Ss][0-9]{1,2}($|[^0-9]) ]]; then
                        has_season_folders=true
                        break
                    fi
                done < <(find "$SOURCE" -maxdepth 1 -mindepth 1 -type d -print0 2>/dev/null)
                
                # Only expand if this is NOT a show folder (no season subfolders)
                if [[ "$has_season_folders" == "false" ]]; then
                    # This is a container of shows - expand subfolders
                    print_info "📁 Expanding folder: '$source_folder_name' ($subfolder_count subfolders)"
                    echo ""
                    
                    # Get sorted list of subfolders (excluding extras folders)
                    local -a subfolders=()
                    while IFS= read -r -d '' subfolder; do
                        local subfolder_basename=$(basename "$subfolder")
                        local lower_subfolder=$(echo "$subfolder_basename" | tr '[:upper:]' '[:lower:]')
                        # Skip extras-type folders
                        if [[ "$lower_subfolder" != "featurettes" ]] && \
                           [[ "$lower_subfolder" != "extras" ]] && \
                           [[ "$lower_subfolder" != "behind the scenes" ]] && \
                           [[ "$lower_subfolder" != "deleted scenes" ]] && \
                           [[ "$lower_subfolder" != "interviews" ]] && \
                           [[ "$lower_subfolder" != "bonus" ]] && \
                           [[ "$lower_subfolder" != "bonus features" ]]; then
                            subfolders+=("$subfolder")
                        fi
                    done < <(find "$SOURCE" -maxdepth 1 -mindepth 1 -type d -print0 2>/dev/null | sort -z)
                    
                    # Insert subfolders at current position
                    local insert_pos=$((source_index))
                    local -a new_sources=()
                    
                    for ((i=0; i<insert_pos; i++)); do
                        new_sources+=("${SOURCES[$i]}")
                    done
                    
                    for subfolder in "${subfolders[@]}"; do
                        new_sources+=("$subfolder")
                    done
                    
                    for ((i=insert_pos; i<${#SOURCES[@]}; i++)); do
                        new_sources+=("${SOURCES[$i]}")
                    done
                    
                    SOURCES=("${new_sources[@]}")
                    continue
                fi
                # else: has season folders, process as a show folder (don't expand)
            fi
        fi
        
        # Check if this is a season batch folder (folder with season but no episode markers in files)
        local is_season_batch=false
        
        if [[ -d "$SOURCE" ]]; then
            local folder_name=$(basename "$SOURCE")
            
            # Skip season batch detection for multi-season folders (Season 1-5, Season 1 to 5, etc.)
            local is_multi_season=false
            if [[ "$folder_name" =~ [Ss]eason[[:space:]]?[0-9]+[[:space:]]?[-–][[:space:]]?[0-9]+ ]] || \
               [[ "$folder_name" =~ [Ss]eason[[:space:]]?[0-9]+[[:space:]]+(to|thru|through)[[:space:]]+[0-9]+ ]] || \
               [[ "$folder_name" =~ [Ss][0-9]{1,2}[[:space:]]?[-–][[:space:]]?[Ss]?[0-9]{1,2} ]] || \
               [[ "$folder_name" =~ [Ss]easons?[[:space:]]?[0-9]+[[:space:]]?(&|and)[[:space:]]?[0-9]+ ]]; then
                is_multi_season=true
            fi
            
            # Check if folder name has SINGLE season indicator (S02, Season 2, etc.) - NOT multi-season
            if [[ "$is_multi_season" == "false" ]]; then
                if [[ "$folder_name" =~ [Ss]([0-9]{1,2})[^Ee0-9] ]] || [[ "$folder_name" =~ [Ss]eason[[:space:]]?([0-9]{1,2}) ]]; then
                    # Count files with episode markers
                    local episode_count=$(find "$SOURCE" -maxdepth 1 -type f \( -iname "*S[0-9][0-9]E[0-9][0-9]*" -o -iname "*s[0-9][0-9]e[0-9][0-9]*" -o -iname "*[0-9]x[0-9][0-9]*" \) | wc -l | tr -d ' ')
                    
                    # If no files have episode markers, treat as batch
                    if [[ $episode_count -eq 0 ]]; then
                        is_season_batch=true
                        print_info "Detected: Season batch folder (no episode markers in filenames)"
                        echo ""
                    fi
                fi
            fi
        fi
        
        # If it's a season batch, process differently
        if $is_season_batch; then
            if process_season_batch "$SOURCE" "$AUTO_MODE"; then
                ((total_success++))
            else
                ((total_failed++))
                FAILED_EPISODES+=("$SOURCE (season batch failed)")
            fi
            continue
        fi
        
        # Normal episode processing (files have S##E## patterns)
        local -a TV_FILES=()
        local files_found_total=0
        local files_excluded_by_is_tv_episode=0
        
        if [[ -d "$SOURCE" ]]; then
            # Build find command with optional extras folder exclusions
            local find_cmd="find \"$SOURCE\""
            
            # If extras linking is disabled, exclude extras folders from scan (case-insensitive)
            if [[ "$HARDLINK_EXTRAS" == "false" ]]; then
                find_cmd+=" \\( -ipath \"*/behind the scenes\" -o"
                find_cmd+=" -ipath \"*/behind the scenes/*\" -o"
                find_cmd+=" -ipath \"*/deleted scenes\" -o"
                find_cmd+=" -ipath \"*/deleted scenes/*\" -o"
                find_cmd+=" -ipath \"*/interviews\" -o"
                find_cmd+=" -ipath \"*/interviews/*\" -o"
                find_cmd+=" -ipath \"*/scenes\" -o"
                find_cmd+=" -ipath \"*/scenes/*\" -o"
                find_cmd+=" -ipath \"*/samples\" -o"
                find_cmd+=" -ipath \"*/samples/*\" -o"
                find_cmd+=" -ipath \"*/shorts\" -o"
                find_cmd+=" -ipath \"*/shorts/*\" -o"
                find_cmd+=" -ipath \"*/featurettes\" -o"
                find_cmd+=" -ipath \"*/featurettes/*\" -o"
                find_cmd+=" -ipath \"*/clips\" -o"
                find_cmd+=" -ipath \"*/clips/*\" -o"
                find_cmd+=" -ipath \"*/other\" -o"
                find_cmd+=" -ipath \"*/other/*\" -o"
                find_cmd+=" -ipath \"*/extras\" -o"
                find_cmd+=" -ipath \"*/extras/*\" -o"
                find_cmd+=" -ipath \"*/trailers\" -o"
                find_cmd+=" -ipath \"*/trailers/*\" \\) -prune -o"
            fi
            
            find_cmd+=" -type f \\( -iname \"*.mkv\" -o -iname \"*.mp4\" -o -iname \"*.avi\" -o -iname \"*.m4v\" \\) -print0"
            
            while IFS= read -r -d '' file; do
                ((files_found_total++))
                if is_tv_episode "$file"; then
                    TV_FILES+=("$file")
                else
                    ((files_excluded_by_is_tv_episode++))
                    should_debug low && echo "[DEBUG] Excluded by is_tv_episode: $(basename "$file")" >&2
                fi
            done < <(eval "$find_cmd")
        elif [[ -f "$SOURCE" ]] && is_tv_episode "$SOURCE"; then
            files_found_total=1
            TV_FILES+=("$SOURCE")
        elif [[ -f "$SOURCE" ]]; then
            files_found_total=1
            files_excluded_by_is_tv_episode=1
            should_debug low && echo "[DEBUG] Single file excluded by is_tv_episode: $(basename "$SOURCE")" >&2
        fi
        
        if [[ ${#TV_FILES[@]} -eq 0 ]]; then
            if [[ $files_excluded_by_is_tv_episode -gt 0 ]]; then
                print_warning "No TV episodes found in: $SOURCE ($files_excluded_by_is_tv_episode files excluded by episode detection)"
            else
                print_warning "No TV episodes found in: $SOURCE"
            fi
            continue
        fi
        
        if [[ $files_excluded_by_is_tv_episode -gt 0 ]]; then
            print_success "Found ${#TV_FILES[@]} TV episode(s) ($files_excluded_by_is_tv_episode excluded by episode detection)"
        else
            print_success "Found ${#TV_FILES[@]} TV episode(s)"
        fi
        echo ""
        
        # Sort files alphabetically
        IFS=$'\n' TV_FILES=($(sort <<<"${TV_FILES[*]}"))
        unset IFS
        
        # Load TV Extension Duplicate Mode setting for this batch (reload each time to ensure correctness)
        TV_EXTENSION_DUP_MODE=""
        if [[ -f "${CACHE_DIR}/tv_extension_dup_mode.txt" ]]; then
            TV_EXTENSION_DUP_MODE=$(cat "${CACHE_DIR}/tv_extension_dup_mode.txt" 2>/dev/null | tr -d '\n\r' | tr -d '[:space:]')
        fi
        # Validate and default to "off" if invalid
        if [[ "$TV_EXTENSION_DUP_MODE" != "off" && "$TV_EXTENSION_DUP_MODE" != "resolution" && "$TV_EXTENSION_DUP_MODE" != "bitrate" ]]; then
            TV_EXTENSION_DUP_MODE="off"
        fi
        echo "[INFO] TV Extension Duplicate Mode: $TV_EXTENSION_DUP_MODE"
        should_debug low && echo "[DEBUG] TV_EXTENSION_DUP_MODE loaded for batch: '$TV_EXTENSION_DUP_MODE' (from ${CACHE_DIR}/tv_extension_dup_mode.txt)" >&2
        
        # Pre-batch TV duplicate filtering (if enabled and not OFF)
        # This filters files with SAME basename but DIFFERENT extensions before processing
        if [[ "$TV_EXTENSION_DUP_MODE" != "off" ]]; then
            should_debug low && echo "[DEBUG] Pre-batch TV duplicate detection mode: $TV_EXTENSION_DUP_MODE" >&2
            echo "[INFO] Analyzing ${#TV_FILES[@]} files for duplicates (this may take a moment)..."
            
            # Bash 3.2 doesn't support associative arrays, so use temp files for tracking
            local temp_metadata=$(mktemp)
            local temp_seen_keys=$(mktemp)
            local temp_keep_files=$(mktemp)
            
            # Build metadata file: base_key|file_path|metric1|metric2
            local file_count=0
            local total_files=${#TV_FILES[@]}
            for tv_file in "${TV_FILES[@]}"; do
                ((file_count++))
                printf "\r[INFO] Scanning file %d/%d..." "$file_count" "$total_files"
                
                local base_name="${tv_file%.*}"
                local base_key=$(echo "$base_name" | sed 's/[^a-zA-Z0-9/_-]/_/g')
                
                if [[ "$TV_EXTENSION_DUP_MODE" == "resolution" ]]; then
                    # Resolution mode: resolution first, bitrate as tiebreaker
                    local resolution=$(get_resolution "$tv_file")
                    local resolution_number=$(resolution_to_number "$resolution")
                    local bitrate=$(get_video_bitrate "$tv_file")
                    echo "${base_key}|${tv_file}|${resolution_number}|${bitrate}" >> "$temp_metadata"
                else
                    # Bitrate or AUTO mode: bitrate first, resolution as tiebreaker
                    local bitrate=$(get_video_bitrate "$tv_file")
                    local resolution=$(get_resolution "$tv_file")
                    local resolution_number=$(resolution_to_number "$resolution")
                    echo "${base_key}|${tv_file}|${bitrate}|${resolution_number}" >> "$temp_metadata"
                fi
            done
            printf "\n"  # Clear the progress line
            
            # Sort by base_key, then by metric1 (resolution or bitrate) descending, then metric2 descending
            local sorted_metadata=$(sort -t'|' -k1,1 -k3,3rn -k4,4rn "$temp_metadata")
            
            # Keep only the first (best) file for each base_key
            while IFS='|' read -r base_key file_path metric1 metric2; do
                if ! grep -Fxq "$base_key" "$temp_seen_keys" 2>/dev/null; then
                    # First occurrence of this base_key - keep it
                    echo "$base_key" >> "$temp_seen_keys"
                    echo "$file_path" >> "$temp_keep_files"
                    should_debug high && echo "[DEBUG] Pre-batch: Keeping $(basename "$file_path") for base_key '$(basename "$base_key")'" >&2
                else
                    # Duplicate - skip it
                    should_debug low && echo "[DEBUG] Pre-batch: Skipping duplicate $(basename "$file_path") for base_key '$(basename "$base_key")'" >&2
                fi
            done <<< "$sorted_metadata"
            
            # Read kept files into array
            local -a FILTERED_TV_FILES=()
            while IFS= read -r file_path; do
                FILTERED_TV_FILES+=("$file_path")
            done < "$temp_keep_files"
            
            # Sort filtered files
            IFS=$'\n' FILTERED_TV_FILES=($(sort <<<"${FILTERED_TV_FILES[*]}"))
            unset IFS
            
            # Cleanup temp files
            rm -f "$temp_metadata" "$temp_seen_keys" "$temp_keep_files"
            
            local filtered_count=$((${#TV_FILES[@]} - ${#FILTERED_TV_FILES[@]}))
            if [[ $filtered_count -gt 0 ]]; then
                print_info "Pre-filtered $filtered_count duplicate(s) using $TV_EXTENSION_DUP_MODE comparison"
            fi
            
            TV_FILES=("${FILTERED_TV_FILES[@]}")
        fi
        
        # Parse series folder name ONCE for the entire batch
        # This avoids re-parsing the same folder name for every episode
        if [[ -d "$SOURCE" ]]; then
            local source_folder_name=$(basename "$SOURCE")
            parse_series_folder_name "$source_folder_name"
            BATCH_SERIES_TITLE="$FOLDER_SERIES_TITLE"
            BATCH_SERIES_YEAR="$FOLDER_SERIES_YEAR"
            BATCH_SERIES_TMDB_HINT="${FOLDER_TMDB_HINT:-}"
            BATCH_SERIES_IMDB_HINT="${FOLDER_IMDB_HINT:-}"
            BATCH_SERIES_TVDB_HINT="${FOLDER_TVDB_HINT:-}"
            should_debug high && print_info "[DEBUG] Batch series info: title='$BATCH_SERIES_TITLE' year='$BATCH_SERIES_YEAR' tmdb_hint='$BATCH_SERIES_TMDB_HINT' imdb_hint='$BATCH_SERIES_IMDB_HINT' tvdb_hint='$BATCH_SERIES_TVDB_HINT'" >&2
            
            # Export for parallel subprocesses
            export BATCH_SERIES_TITLE
            export BATCH_SERIES_YEAR
            export BATCH_SERIES_TMDB_HINT
            export BATCH_SERIES_IMDB_HINT
            export BATCH_SERIES_TVDB_HINT
            export TV_EXTENSION_DUP_MODE
            export EXTENSION_DUP_MODE
        else
            # Single file - parse from parent folder
            local parent_folder_name=$(basename "$(dirname "$SOURCE")")
            parse_series_folder_name "$parent_folder_name"
            BATCH_SERIES_TITLE="$FOLDER_SERIES_TITLE"
            BATCH_SERIES_YEAR="$FOLDER_SERIES_YEAR"
            BATCH_SERIES_TMDB_HINT="${FOLDER_TMDB_HINT:-}"
            BATCH_SERIES_IMDB_HINT="${FOLDER_IMDB_HINT:-}"
            BATCH_SERIES_TVDB_HINT="${FOLDER_TVDB_HINT:-}"
            should_debug high && print_info "[DEBUG] Single file - batch series info from parent: title='$BATCH_SERIES_TITLE' year='$BATCH_SERIES_YEAR' tmdb_hint='$BATCH_SERIES_TMDB_HINT' imdb_hint='$BATCH_SERIES_IMDB_HINT' tvdb_hint='$BATCH_SERIES_TVDB_HINT'" >&2
        fi
        
        # Initialize poster cache for this batch (one per series)
        CURRENT_SERIES_POSTER_URL=""
        CURRENT_SERIES_POSTER_SHOWN=false
        CURRENT_SERIES_NAME=""
        
        # Disable posters during parallel processing (causes slowdown)
        local ORIGINAL_SHOW_SERIES_POSTERS="$SHOW_SERIES_POSTERS"
        if [[ "$PARALLEL_PROCESSING" == "true" && "$AUTO_MODE" == "y" ]]; then
            SHOW_SERIES_POSTERS="no"
            should_debug low && print_info "[DEBUG] Disabled series posters during parallel processing" >&2
        fi
        
        # Track batch processing statistics
        local batch_start_time=$SECONDS
        local tv_cache_entries_before=0
        [[ -f "$TV_CACHE_FILE" ]] && tv_cache_entries_before=$(awk 'NF' "$TV_CACHE_FILE" 2>/dev/null | wc -l | tr -d ' ' || echo 0)
        
        # ========================================================================
        # SERIES-LEVEL EXTRAS PROCESSING (NEW)
        # Process first episode to establish series folder, then process extras,
        # then process remaining episodes in parallel
        # ========================================================================
        local series_folder_for_extras=""
        
        # Process each episode
        # Check if parallel processing is enabled AND rolling queue is enabled
        if [[ "$PARALLEL_PROCESSING" == "true" && "$AUTO_MODE" == "y" && "$ROLLING_QUEUE_MODE" == "true" ]]; then
            print_success "Parallel processing enabled: ${PARALLEL_JOBS} simultaneous jobs (rolling queue)"
            echo ""
            
            local total_files=${#TV_FILES[@]}
            local file_index=0
            
            # Rolling queue: indexed arrays for Bash 3.2 compatibility
            local -a active_pids=()
            local -a active_files=()
            local -a active_indices=()
            
            local success_count=0
            local failed_count=0
            local skipped_count=0
            
            # Process first episode to get series folder name for extras
            if [[ $total_files -gt 0 ]] && [[ -d "$SOURCE" ]]; then
                print_info "Processing first episode to establish series folder..."
                local first_ep="${TV_FILES[0]}"
                process_tv_episode "$first_ep" "$AUTO_MODE"
                local first_exit=$?
                
                # Count the result
                case $first_exit in
                    0|2|4) ((success_count++)) ;;
                    3|5|6) ((skipped_count++)) ;;
                    *) ((failed_count++)); FAILED_EPISODES+=("$first_ep") ;;
                esac
                
                # Small delay to ensure filesystem sync (especially on network drives)
                sleep 0.5
                
                # Get the series folder name from destination
                # Check for existing folder (should now exist after processing first episode)
                if [[ -d "$DESTINATION" ]]; then
                    # Look for series folders - they have year in parentheses and optionally ID in brackets
                    local series_dir=$(find "$DESTINATION" -maxdepth 1 -type d \( -name "* (*)" -o -name "* (*) [*]*" \) 2>/dev/null | head -1)
                    if [[ -z "$series_dir" ]]; then
                        # Fallback: just find any directory that's not the destination itself
                        series_dir=$(find "$DESTINATION" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | head -1)
                    fi
                    
                    if [[ -n "$series_dir" ]]; then
                        series_folder_for_extras=$(basename "$series_dir")
                        echo "[DEBUG] Detected series folder: $series_folder_for_extras from destination: $DESTINATION"
                        echo "[DEBUG] Source directory for extras scan: $SOURCE"
                        
                        # Now process ALL extras for this series
                        echo "[INFO] Processing extras for series: $series_folder_for_extras"
                        process_series_extras "$SOURCE" "$series_folder_for_extras" "$AUTO_MODE"
                    else
                        echo "[DEBUG] No series folder found in destination: $DESTINATION"
                        echo "[DEBUG] Find command result: $(find "$DESTINATION" -mindepth 1 -maxdepth 1 -type d 2>&1 | head -5)"
                    fi
                else
                    echo "[DEBUG] Destination directory does not exist: $DESTINATION"
                fi
                
                # Skip first file in rolling queue (already processed)
                ((file_index++))
                echo ""
            fi
            
            # Keep queue full until all files are processed
            while [[ $file_index -lt $total_files ]] || [[ ${#active_pids[@]} -gt 0 ]]; do
                # Poll active jobs (non-blocking) - collect completed indices first
                local -a completed_indices=()
                
                for i in "${!active_pids[@]}"; do
                    local pid="${active_pids[$i]}"
                    
                    # Non-blocking check if process is still running
                    if ! kill -0 "$pid" 2>/dev/null; then
                        # Process finished, get exit code
                        wait "$pid" 2>/dev/null
                        local exit_code=$?
                        
                        # Count results
                        case $exit_code in
                            0)
                                # Successfully processed
                                ((success_count++))
                                ;;
                            2|4)
                                # Already linked (2) or processed while waiting (4)
                                ((success_count++))
                                ;;
                            3|5|6)
                                # Skipped: 3=lower bitrate, 5=.ia file, 6=lower resolution
                                ((skipped_count++))
                                ;;
                            *)
                                # Failed
                                ((failed_count++))
                                FAILED_EPISODES+=("${active_files[$i]}")
                                ;;
                        esac
                        
                        # Mark for removal
                        completed_indices+=("$i")
                    fi
                done
                
                # Remove completed jobs from arrays (in reverse order to preserve indices)
                for ((idx=${#completed_indices[@]}-1; idx>=0; idx--)); do
                    local i="${completed_indices[$idx]}"
                    unset 'active_pids[$i]'
                    unset 'active_files[$i]'
                    unset 'active_indices[$i]'
                done
                
                # Rebuild arrays to remove gaps
                active_pids=("${active_pids[@]}")
                active_files=("${active_files[@]}")
                active_indices=("${active_indices[@]}")
                
                # Fill available slots
                while [[ ${#active_pids[@]} -lt $PARALLEL_JOBS ]] && [[ $file_index -lt $total_files ]]; do
                    local tv_file="${TV_FILES[$file_index]}"
                    
                    # Start background job - preserve exit code
                    (
                        process_tv_episode "$tv_file" "$AUTO_MODE"
                        exit $?
                    ) &
                    
                    local pid=$!
                    active_pids+=("$pid")
                    active_files+=("$tv_file")
                    active_indices+=("$file_index")
                    
                    ((file_index++))
                done
                
                # Brief sleep to avoid busy-waiting (reduced to 0.01s for faster processing)
                sleep 0.01
            done
            
            # Transfer counts to main variables
            should_debug low && echo "[DEBUG] Rolling queue complete for this batch: success_count=${success_count}, skipped_count=${skipped_count}, failed_count=${failed_count}" >&2
            should_debug low && echo "[DEBUG] Before this batch: total_success=${total_success}, total_skipped=${total_skipped}, total_failed=${total_failed}" >&2
            total_success=$((total_success + success_count))
            total_skipped=$((total_skipped + skipped_count))
            total_failed=$((total_failed + failed_count))
            total_files_found=$((total_files_found + files_found_total))
            total_excluded_by_detection=$((total_excluded_by_detection + files_excluded_by_is_tv_episode))
            should_debug low && echo "[DEBUG] After hardlinking this batch: total_success=${total_success}, total_skipped=${total_skipped}, total_failed=${total_failed}" >&2
            should_debug low && echo "[DEBUG] FAILED_EPISODES array length: ${#FAILED_EPISODES[@]}" >&2
            
            # Restore original poster setting
            SHOW_SERIES_POSTERS="$ORIGINAL_SHOW_SERIES_POSTERS"
            
        elif [[ "$PARALLEL_PROCESSING" == "true" && "$AUTO_MODE" == "y" ]]; then
            # Old batch mode (without rolling queue)
            total_files_found=$((total_files_found + files_found_total))
            total_excluded_by_detection=$((total_excluded_by_detection + files_excluded_by_is_tv_episode))
            
            print_success "Parallel processing enabled: ${PARALLEL_JOBS} simultaneous jobs (batch mode)"
            echo ""
            
            local total_files=${#TV_FILES[@]}
            local file_index=0
            local batch_size=$PARALLEL_JOBS
            
            while [[ $file_index -lt $total_files ]]; do
                # Start batch of parallel jobs
                local batch_pids=()
                
                for ((i=0; i<batch_size && file_index<total_files; i++)); do
                    local tv_file="${TV_FILES[$file_index]}"
                    ((file_index++))
                    
                    # Process file in background
                    (
                        if process_tv_episode "$tv_file" "$AUTO_MODE"; then
                            exit 0
                        else
                            exit 1
                        fi
                    ) &
                    
                    batch_pids+=($!)
                done
                
                # Wait for all jobs in this batch to complete
                local batch_file_index=0
                for pid in "${batch_pids[@]}"; do
                    wait "$pid"
                    local exit_code=$?
                    if [[ $exit_code -eq 0 ]] || [[ $exit_code -eq 2 ]] || [[ $exit_code -eq 4 ]]; then
                        ((total_success++))
                    elif [[ $exit_code -eq 3 ]] || [[ $exit_code -eq 5 ]] || [[ $exit_code -eq 6 ]]; then
                        # Skip codes: 3=lower bitrate, 5=.ia file, 6=lower resolution
                        ((total_skipped++))
                    else
                        ((total_failed++))
                        # Track which file in batch failed (approximate, since parallel)
                        if [[ $batch_file_index -lt ${#batch_files[@]} ]]; then
                            FAILED_EPISODES+=("${batch_files[$batch_file_index]}")
                        fi
                    fi
                    ((batch_file_index++))
                done
            done
        else
            # Sequential processing (original behavior)
            total_files_found=$((total_files_found + files_found_total))
            total_excluded_by_detection=$((total_excluded_by_detection + files_excluded_by_is_tv_episode))
            
            for tv_file in "${TV_FILES[@]}"; do
                process_tv_episode "$tv_file" "$AUTO_MODE"
                local exit_code=$?
                
                case $exit_code in
                    0)
                        # Successfully processed
                        ((total_success++))
                        ;;
                    2|4)
                        # Already linked (2) or processed while waiting (4)
                        # These count as successes (file was/is being processed)
                        ((total_success++))
                        ;;
                    3|5|6)
                        # Skipped: 3=lower bitrate, 5=.ia file, 6=lower resolution
                        ((total_skipped++))
                        ;;
                    *)
                        # Failed to process
                        ((total_failed++))
                        FAILED_EPISODES+=("$tv_file")
                        ;;
                esac
                echo ""
            done
        fi
        
        # Calculate TV processing statistics
        local batch_elapsed=$((SECONDS - batch_start_time))
        local batch_minutes=$((batch_elapsed / 60))
        local batch_seconds=$((batch_elapsed % 60))
        
        # Calculate average time per episode
        local avg_time_per_episode="0"
        if [[ $total_success -gt 0 ]]; then
            avg_time_per_episode=$(awk "BEGIN {printf \"%.2f\", $batch_elapsed / $total_success}")
        fi
        
        # Calculate total size processed for this source
        local source_size=0
        for tv_file in "${TV_FILES[@]}"; do
            local file_size=$(stat -f "%z" "$tv_file" 2>/dev/null || stat -c "%s" "$tv_file" 2>/dev/null)
            source_size=$((source_size + file_size))
        done
        overall_size=$((overall_size + source_size))
        
        # Clear poster cache after processing this batch
        CURRENT_SERIES_POSTER_URL=""
        CURRENT_SERIES_POSTER_SHOWN=false
        CURRENT_SERIES_NAME=""
        
        # Clean up canonical title/year temp cache files
        rm -f "${CACHE_DIR}"/.canon_*.tmp 2>/dev/null
        # Clean up lock result files from parallel processing
        rm -f /tmp/tv_lookup_locks/*.result 2>/dev/null
    done
    
    # Calculate overall statistics
    local overall_elapsed=$((SECONDS - overall_start_time))
    local overall_minutes=$((overall_elapsed / 60))
    local overall_seconds=$((overall_elapsed % 60))
    
    local avg_time_per_episode="0"
    if [[ $total_success -gt 0 ]]; then
        avg_time_per_episode=$(awk "BEGIN {printf \"%.2f\", $overall_elapsed / $total_success}")
    fi
    
    local size_gb=$((overall_size / 1073741824))
    local size_mb=$(((overall_size % 1073741824) / 1048576))
    
    # Read API call count from file (for parallel processing)
    if [[ -f "$API_COUNTER_FILE" ]]; then
        API_CALL_COUNT=$(wc -l < "$API_COUNTER_FILE" | tr -d ' ')
        rm -f "$API_COUNTER_FILE"
    fi
    
    # Clean up extras tracking temp files
    rm -f "$EXTRAS_PROCESSED_FILE" "$EXTRAS_SKIPPED_FILE" "$IA_SKIPPED_FILE" 2>/dev/null
    
    local overall_cache_after=0
    [[ -f "$TV_CACHE_FILE" ]] && overall_cache_after=$(awk 'NF' "$TV_CACHE_FILE" 2>/dev/null | wc -l | tr -d ' ' || echo 0)
    local new_tv_entries=$((overall_cache_after - overall_cache_before))
    
    # Aggregate extras tracking from temp files
    if [[ -f "$EXTRAS_PROCESSED_FILE" ]]; then
        total_extras_processed=$(wc -l < "$EXTRAS_PROCESSED_FILE" | tr -d ' ')
    fi
    
    if [[ -f "$EXTRAS_SKIPPED_FILE" ]]; then
        total_extras_skipped=$(wc -l < "$EXTRAS_SKIPPED_FILE" | tr -d ' ')
        
        # Build SKIPPED_EXTRAS array from temp file for detailed reporting
        while IFS='|' read -r file reason; do
            SKIPPED_EXTRAS+=("${file}|||${reason}")
        done < "$EXTRAS_SKIPPED_FILE"
    fi
    
    # Aggregate .ia skipped files
    if [[ -f "$IA_SKIPPED_FILE" ]]; then
        total_ia_skipped=$(wc -l < "$IA_SKIPPED_FILE" | tr -d ' ')
        
        # Build IA_SKIPPED array from temp file for detailed reporting
        while IFS='|' read -r ia_file non_ia_file; do
            IA_SKIPPED+=("${ia_file}|||${non_ia_file}")
        done < "$IA_SKIPPED_FILE"
    fi
    
    # Summary with detailed statistics
    echo ""
    local TV_STATISTICS_TIME=$(date '+%Y-%m-%d %H:%M:%S')
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${CYAN}TV SHOW PROCESSING STATISTICS${NC}"
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
    print_info "Instance PID: $$"
    print_info "Started: ${PROCESSING_START_TIME:-unknown}"
    print_info "Finished: $TV_STATISTICS_TIME"
    echo ""
    print_success "Episodes processed: $total_success successful, $total_skipped skipped, $total_failed failed"
    if [[ $total_excluded_by_detection -gt 0 ]]; then
        print_info "Files found: $total_files_found total, $total_excluded_by_detection excluded by episode detection"
    fi
    print_info "Total processing time: ${overall_minutes}m ${overall_seconds}s (avg ${avg_time_per_episode}s per episode)"
    print_info "  └─ Includes: file scanning, episode detection, filtering, hardlinking, and post-processing"
    
    # Calculate episodes per second (rounded to 2 decimal places)
    local episodes_per_second="0.00"
    if [[ $overall_elapsed -gt 0 && $total_success -gt 0 ]]; then
        if command -v bc &> /dev/null; then
            episodes_per_second=$(echo "scale=2; $total_success / $overall_elapsed" | bc)
        else
            episodes_per_second=$(awk "BEGIN {printf \"%.2f\", $total_success / $overall_elapsed}")
        fi
    fi
    print_info "Processing rate: $episodes_per_second episodes/sec"
    
    print_info "Data processed: ${size_gb}.$(printf "%03d" $size_mb) GB"
    print_info "TV cache entries: $overall_cache_before → $overall_cache_after (+$new_tv_entries new)"
    
    # Display cache mode
    local cache_display="${TV_CACHE_MODE:-tvshow}"
    case "$cache_display" in
        tvshow) cache_display="TV Shows cache" ;;
        anime) cache_display="Anime cache" ;;
        cartoons) cache_display="Cartoons cache" ;;
    esac
    print_info "  • Using: ${CYAN}${cache_display}${NC}"
    
    # Display extras statistics if extras were processed
    if [[ $total_extras_processed -gt 0 || $total_extras_skipped -gt 0 ]]; then
        echo ""
        print_info "Extras: $total_extras_processed processed, $total_extras_skipped skipped"
    fi
    
    # Display .ia file skip statistics
    if [[ $total_ia_skipped -gt 0 ]]; then
        print_info "Internet Archive (.ia) duplicates skipped: $total_ia_skipped files"
    fi
    
    # Display failed episodes if any
    if [[ $total_failed -gt 0 && ${#FAILED_EPISODES[@]} -gt 0 ]]; then
        echo ""
        print_warning "Failed episodes:"
        for failed_ep in "${FAILED_EPISODES[@]}"; do
            echo "  ✗ $failed_ep"
        done
    fi
    
    # Report shows with missing database IDs
    if [[ -f "${CACHE_DIR}/.missing_tv_ids_$$.tmp" ]]; then
        local missing_count=$(wc -l < "${CACHE_DIR}/.missing_tv_ids_$$.tmp" | tr -d ' ')
        if [[ $missing_count -gt 0 ]]; then
            echo ""
            print_warning "TV Shows with incomplete database IDs: $missing_count"
            echo ""
            while IFS='|||' read -r show_title missing_ids reason; do
                echo "  ⚠ $show_title"
                echo "    Missing: $missing_ids"
                echo "    Reason: $reason"
            done < "${CACHE_DIR}/.missing_tv_ids_$$.tmp"
            rm -f "${CACHE_DIR}/.missing_tv_ids_$$.tmp"
        fi
    fi
    
    # Display detailed skipped extras if any
    if [[ ${#SKIPPED_EXTRAS[@]} -gt 0 ]]; then
        echo ""
        print_info "Skipped Extras Details:"
        echo ""
        
        # Group by reason
        local -A reason_counts
        local -A reason_examples
        
        for entry in "${SKIPPED_EXTRAS[@]}"; do
            IFS='|||' read -r file reason <<< "$entry"
            reason_counts["$reason"]=$((${reason_counts["$reason"]:-0} + 1))
            
            # Store first 3 examples for each reason
            if [[ -z "${reason_examples["$reason"]}" ]]; then
                reason_examples["$reason"]="$file"
            elif [[ $(echo "${reason_examples["$reason"]}" | grep -c "^") -lt 3 ]]; then
                reason_examples["$reason"]="${reason_examples["$reason"]}"$'\n'"$file"
            fi
        done
        
        # Display grouped by reason
        for reason in "${!reason_counts[@]}"; do
            local count=${reason_counts["$reason"]}
            case "$reason" in
                "already_processed")
                    print_info "  Already processed in this run: $count files"
                    ;;
                "already_exists")
                    print_info "  Already exists (hardlinked): $count files"
                    ;;
                *)
                    print_info "  $reason: $count files"
                    ;;
            esac
            
            # Show examples (first 3)
            if [[ -n "${reason_examples["$reason"]}" ]]; then
                echo "${reason_examples["$reason"]}" | head -3 | while IFS= read -r example; do
                    local basename=$(basename "$example")
                    echo "    • $basename"
                done
            fi
        done
    fi
    
    # Display detailed .ia skipped files if any
    if [[ ${#IA_SKIPPED[@]} -gt 0 ]]; then
        echo ""
        print_info "Internet Archive (.ia) Duplicates Skipped: $total_ia_skipped"
        echo ""
        # Show first 10 examples
        local count=0
        for entry in "${IA_SKIPPED[@]}"; do
            IFS='|||' read -r ia_file non_ia_file <<< "$entry"
            local ia_basename=$(basename "$ia_file")
            local non_ia_basename=$(basename "$non_ia_file")
            echo "  • $ia_basename"
            echo "    └─ Non-.ia version exists: $non_ia_basename"
            ((count++))
            [[ $count -ge 10 ]] && break
        done
        if [[ ${#IA_SKIPPED[@]} -gt 10 ]]; then
            echo "  ... and $((${#IA_SKIPPED[@]} - 10)) more"
        fi
    fi
    
    # API call statistics
    if [[ $API_CALL_COUNT -gt 0 ]]; then
        local api_rate="0.00"
        if [[ $overall_elapsed -gt 0 ]]; then
            # Use bash arithmetic: multiply by 100, divide, then format
            local rate_calc=$(( (API_CALL_COUNT * 100) / overall_elapsed ))
            api_rate=$(printf "%d.%02d" $((rate_calc / 100)) $((rate_calc % 100)))
        fi
        print_info "API calls: $API_CALL_COUNT total (${api_rate}/sec average)"
    fi
    echo ""
    
    # Scan for duplicate IMDb/TMDb/TVDb IDs in destination (TV show folders)
    echo ""
    print_info "Scanning destination for duplicate TV show IDs..."
    
    # Create temporary files for tracking IDs
    local tmp_imdb_file=$(mktemp)
    local tmp_tmdb_file=$(mktemp)
    local tmp_tvdb_file=$(mktemp)
    
    # Extract all IDs and their paths (directories only)
    while IFS= read -r -d '' item; do
        local item_name=$(basename "$item")
        
        # Extract IMDb ID (all patterns: [imdbid-ttXXXXXXX], [imdb-ttXXXXXXX], {imdb-ttXXXXXXX})
        if [[ "$item_name" =~ \[imdbid-(tt[0-9]+)\] ]]; then
            echo "${BASH_REMATCH[1]}|$item" >> "$tmp_imdb_file"
        elif [[ "$item_name" =~ \[imdb-(tt[0-9]+)\] ]]; then
            echo "${BASH_REMATCH[1]}|$item" >> "$tmp_imdb_file"
        elif [[ "$item_name" =~ \{imdb-(tt[0-9]+)\} ]]; then
            echo "${BASH_REMATCH[1]}|$item" >> "$tmp_imdb_file"
        fi
        
        # Extract TMDb ID (all patterns: [tmdbid-XXXXX], [tmdb-XXXXX], {tmdb-XXXXX})
        if [[ "$item_name" =~ \[tmdbid-([0-9]+)\] ]]; then
            echo "${BASH_REMATCH[1]}|$item" >> "$tmp_tmdb_file"
        elif [[ "$item_name" =~ \[tmdb-([0-9]+)\] ]]; then
            echo "${BASH_REMATCH[1]}|$item" >> "$tmp_tmdb_file"
        elif [[ "$item_name" =~ \{tmdb-([0-9]+)\} ]]; then
            echo "${BASH_REMATCH[1]}|$item" >> "$tmp_tmdb_file"
        fi
        
        # Extract TVDb ID (all patterns: [tvdbid-XXXXX], [tvdb-XXXXX], {tvdb-XXXXX})
        if [[ "$item_name" =~ \[tvdbid-([0-9]+)\] ]]; then
            echo "${BASH_REMATCH[1]}|$item" >> "$tmp_tvdb_file"
        elif [[ "$item_name" =~ \[tvdb-([0-9]+)\] ]]; then
            echo "${BASH_REMATCH[1]}|$item" >> "$tmp_tvdb_file"
        elif [[ "$item_name" =~ \{tvdb-([0-9]+)\} ]]; then
            echo "${BASH_REMATCH[1]}|$item" >> "$tmp_tvdb_file"
        fi
    done < <(find "$DESTINATION" -mindepth 1 -maxdepth 1 -type d -print0 2>/dev/null)
    
    # Find duplicate IMDb IDs
    local duplicate_imdb_count=0
    if [[ -f "$tmp_imdb_file" && -s "$tmp_imdb_file" ]]; then
        local duplicate_ids=$(sort "$tmp_imdb_file" | awk -F'|' '{id=$1; count[id]++} END {for (i in count) if (count[i] > 1) print i}')
        
        if [[ -n "$duplicate_ids" ]]; then
            echo ""
            print_warning "Found duplicate IMDb IDs in TV shows:"
            
            while IFS= read -r id; do
                [[ -z "$id" ]] && continue
                
                local items=$(grep "^${id}|" "$tmp_imdb_file" | cut -d'|' -f2)
                local item_count=$(echo "$items" | wc -l | tr -d ' ')
                
                echo ""
                echo -e "  ${YELLOW}IMDb ID: $id (${item_count} shows)${NC}"
                
                local idx=1
                while IFS= read -r item_path; do
                    echo -e "    ${DIM}${idx}. $(basename "$item_path")${NC}"
                    ((idx++))
                done <<< "$items"
                
                ((duplicate_imdb_count++))
            done <<< "$duplicate_ids"
        fi
    fi
    
    # Find duplicate TMDb IDs
    local duplicate_tmdb_count=0
    if [[ -f "$tmp_tmdb_file" && -s "$tmp_tmdb_file" ]]; then
        local duplicate_ids=$(sort "$tmp_tmdb_file" | awk -F'|' '{id=$1; count[id]++} END {for (i in count) if (count[i] > 1) print i}')
        
        if [[ -n "$duplicate_ids" ]]; then
            echo ""
            print_warning "Found duplicate TMDb IDs in TV shows:"
            
            while IFS= read -r id; do
                [[ -z "$id" ]] && continue
                
                local items=$(grep "^${id}|" "$tmp_tmdb_file" | cut -d'|' -f2)
                local item_count=$(echo "$items" | wc -l | tr -d ' ')
                
                echo ""
                echo -e "  ${YELLOW}TMDb ID: $id (${item_count} shows)${NC}"
                
                local idx=1
                while IFS= read -r item_path; do
                    echo -e "    ${DIM}${idx}. $(basename "$item_path")${NC}"
                    ((idx++))
                done <<< "$items"
                
                ((duplicate_tmdb_count++))
            done <<< "$duplicate_ids"
        fi
    fi
    
    # Find duplicate TVDb IDs
    local duplicate_tvdb_count=0
    if [[ -f "$tmp_tvdb_file" && -s "$tmp_tvdb_file" ]]; then
        local duplicate_ids=$(sort "$tmp_tvdb_file" | awk -F'|' '{id=$1; count[id]++} END {for (i in count) if (count[i] > 1) print i}')
        
        if [[ -n "$duplicate_ids" ]]; then
            echo ""
            print_warning "Found duplicate TVDb IDs in TV shows:"
            
            while IFS= read -r id; do
                [[ -z "$id" ]] && continue
                
                local items=$(grep "^${id}|" "$tmp_tvdb_file" | cut -d'|' -f2)
                local item_count=$(echo "$items" | wc -l | tr -d ' ')
                
                echo ""
                echo -e "  ${YELLOW}TVDb ID: $id (${item_count} shows)${NC}"
                
                local idx=1
                while IFS= read -r item_path; do
                    echo -e "    ${DIM}${idx}. $(basename "$item_path")${NC}"
                    ((idx++))
                done <<< "$items"
                
                ((duplicate_tvdb_count++))
            done <<< "$duplicate_ids"
        fi
    fi
    
    # Cleanup temp files
    rm -f "$tmp_imdb_file" "$tmp_tmdb_file" "$tmp_tvdb_file"
    
    if [[ $duplicate_imdb_count -eq 0 && $duplicate_tmdb_count -eq 0 && $duplicate_tvdb_count -eq 0 ]]; then
        print_success "No duplicate IDs found in TV shows"
    else
        echo ""
        print_warning "Summary: Found $duplicate_imdb_count duplicate IMDb ID(s), $duplicate_tmdb_count duplicate TMDb ID(s), $duplicate_tvdb_count duplicate TVDb ID(s)"
        echo ""
        print_info "Note: Review the duplicates above and manually correct folder names if needed"
    fi
    echo ""
}

# Settings menu
show_settings_menu() {
    local -a settings_options=("TMDb API Key" "API Delay" "Test API Connection" "Back to Main Menu")
    local selected_idx=0
    
    # Load API delay setting
    [[ -f "${CACHE_DIR}/api_delay.txt" ]] && API_DELAY=$(cat "${CACHE_DIR}/api_delay.txt")
    
    tput civis 2>/dev/null
    
    while true; do
        clear
        
        echo ""
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${CYAN}SETTINGS${NC}"
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
        
        # Show current API key status
        if [[ -f "${CACHE_DIR}/tmdb_api_key.txt" ]]; then
            local current_key=$(cat "${CACHE_DIR}/tmdb_api_key.txt")
            local masked_key="${current_key:0:8}************************"
            echo -e "${DIM}Current TMDb API Key: ${masked_key}${NC}"
        else
            echo -e "${DIM}Current TMDb API Key: Using default (not recommended)${NC}"
        fi
        
        echo -e "${DIM}API Delay: ${CYAN}${API_DELAY}s${NC}${NC}"
        echo ""
        
        for i in "${!settings_options[@]}"; do
            if [[ $i -eq $selected_idx ]]; then
                echo -e "  ${GREEN}▶ ${settings_options[$i]}${NC}"
            else
                echo -e "    ${DIM}${settings_options[$i]}${NC}"
            fi
        done
        
        echo ""
        echo -e "${DIM}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${YELLOW}↑/↓${NC}: Navigate  ${YELLOW}ENTER${NC}: Select  ${YELLOW}b${NC}: Go Back"
        echo -e "${DIM}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
        
        read -rsn1 key 2>/dev/null
        
        if [[ "$key" == $'\x1b' ]]; then
            read -rsn2 -t 1 key 2>/dev/null
            case "$key" in
                '[A') # Up arrow
                    ((selected_idx > 0)) && ((selected_idx--))
                    ;;
                '[B') # Down arrow
                    ((selected_idx < ${#settings_options[@]}-1)) && ((selected_idx++))
                    ;;
            esac
        elif [[ "$key" == "b" ]] || [[ "$key" == "B" ]]; then
            # Back to main menu
            tput cnorm 2>/dev/null
            return 0
        elif [[ "$key" == "" ]]; then
            # Enter - confirm selection
            if [[ $selected_idx -eq 0 ]]; then
                # TMDb API Key configuration
                tput cnorm 2>/dev/null
                clear
                echo ""
                echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                echo -e "${CYAN}TMDb API KEY CONFIGURATION${NC}"
                echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                echo ""
                echo -e "${YELLOW}Get your free API key from:${NC}"
                echo -e "${CYAN}https://www.themoviedb.org/settings/api${NC}"
                echo ""
                echo -e "${DIM}Your API key will be saved to: ${CACHE_DIR}/tmdb_api_key.txt${NC}"
                echo ""
                echo -e "${GREEN}Copy your API key, then paste it below:${NC}"
                echo -e "${YELLOW}Paste your TMDb API key and press ENTER (or just ENTER to cancel):${NC}"
                stty echo
                read new_api_key
                stty -echo
                
                # Trim whitespace
                new_api_key=$(echo "$new_api_key" | tr -d '[:space:]')
                
                if [[ -n "$new_api_key" ]]; then
                    # Validate API key format (32 character hex string)
                    if [[ "$new_api_key" =~ ^[a-f0-9]{32}$ ]]; then
                        echo "$new_api_key" > "${CACHE_DIR}/tmdb_api_key.txt"
                        TMDB_API_KEY="$new_api_key"
                        echo ""
                        print_success "TMDb API key saved successfully!"
                        echo -e "${GREEN}✓ Saved to: ${CACHE_DIR}/tmdb_api_key.txt${NC}"
                        echo ""
                        echo -e "${DIM}Press any key to continue...${NC}"
                        read -rsn1
                    else
                        echo ""
                        print_error "Invalid API key format. Should be 32 hexadecimal characters."
                        echo -e "${DIM}Example: 44654364545645634565464536546454${NC}"
                        echo ""                 
                        echo -e "${DIM}Press any key to continue...${NC}"
                        read -rsn1
                    fi
                fi
                tput civis 2>/dev/null
            elif [[ $selected_idx -eq 1 ]]; then
                # API Delay configuration
                tput cnorm 2>/dev/null
                clear
                echo ""
                echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                echo -e "${CYAN}API DELAY CONFIGURATION${NC}"
                echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                echo ""
                echo -e "${DIM}Current delay: ${API_DELAY}s${NC}"
                echo ""
                echo -e "${YELLOW}Delay between API calls (in seconds):${NC}"
                echo -e "${DIM}  • 0.25 = Fast (recommended for personal use)${NC}"
                echo -e "${DIM}  • 0.5  = Moderate${NC}"
                echo -e "${DIM}  • 1.0  = Safe (conservative)${NC}"
                echo ""
                echo -e "${YELLOW}Enter delay (0.1-5.0 seconds):${NC}"
                stty echo
                read -r input_delay
                stty -echo
                
                # Validate input is a number and in range
                if [[ "$input_delay" =~ ^[0-9]+\.?[0-9]*$ ]]; then
                    # Use bc for floating point comparison if available
                    if command -v bc &> /dev/null; then
                        if (( $(echo "$input_delay >= 0.1" | bc -l) )) && (( $(echo "$input_delay <= 5.0" | bc -l) )); then
                            API_DELAY=$input_delay
                            echo "$API_DELAY" > "${CACHE_DIR}/api_delay.txt"
                            echo ""
                            echo -e "${GREEN}✓ API delay set to: ${API_DELAY}s${NC}"
                        else
                            echo ""
                            echo -e "${RED}✗ Invalid input. Must be between 0.1 and 5.0 seconds.${NC}"
                        fi
                    else
                        # Fallback without bc
                        API_DELAY=$input_delay
                        echo "$API_DELAY" > "${CACHE_DIR}/api_delay.txt"
                        echo ""
                        echo -e "${GREEN}✓ API delay set to: ${API_DELAY}s${NC}"
                    fi
                else
                    echo ""
                    echo -e "${RED}✗ Invalid input. Please enter a number.${NC}"
                fi
                echo ""
                echo -e "${DIM}Press any key to continue...${NC}"
                read -rsn1
                tput civis 2>/dev/null
            elif [[ $selected_idx -eq 2 ]]; then
                # Test API Connection
                tput cnorm 2>/dev/null
                clear
                echo ""
                echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                echo -e "${CYAN}TEST API CONNECTION${NC}"
                echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                echo ""
                echo -e "${YELLOW}Testing TMDb API connection...${NC}"
                echo ""
                
                # Test API with a simple movie search
                local test_start=$SECONDS
                local test_result=$(curl -s --connect-timeout 10 --max-time 30 "${TMDB_API_BASE}/search/movie?api_key=${TMDB_API_KEY}&query=Avatar&year=2009" 2>/dev/null)
                local test_time=$((SECONDS - test_start))
                
                if [[ -n "$test_result" ]] && echo "$test_result" | grep -q '"id"'; then
                    echo -e "${GREEN}✓ API connection successful!${NC}"
                    echo ""
                    echo -e "${DIM}Response time: ${test_time}s${NC}"
                    
                    # Extract and display result
                    local movie_id=$(echo "$test_result" | grep -oE '"id":[0-9]+' | head -1 | grep -oE '[0-9]+')
                    local movie_title=$(echo "$test_result" | grep -oE '"title":"[^"]+' | head -1 | cut -d'"' -f4)
                    
                    if [[ -n "$movie_id" && -n "$movie_title" ]]; then
                        echo -e "${DIM}Test search found: ${movie_title} (TMDb ID: ${movie_id})${NC}"
                    fi
                elif echo "$test_result" | grep -q "Invalid API key"; then
                    echo -e "${RED}✗ API key invalid!${NC}"
                    echo ""
                    echo -e "${YELLOW}Please update your TMDb API key.${NC}"
                else
                    echo -e "${RED}✗ API connection failed!${NC}"
                    echo ""
                    echo -e "${YELLOW}Please check:${NC}"
                    echo -e "${DIM}  • Your internet connection${NC}"
                    echo -e "${DIM}  • Your API key is valid${NC}"
                    echo -e "${DIM}  • TMDb service is online${NC}"
                fi
                
                echo ""
                echo -e "${DIM}Press any key to continue...${NC}"
                read -rsn1
                tput civis 2>/dev/null
            elif [[ $selected_idx -eq 3 ]]; then
                # Back to main menu
                tput cnorm 2>/dev/null
                return 0
            fi
        fi
    done
}

# Cache Management menu
show_cache_management_menu() {
    local -a cache_files=(
        "Back"
        "Sort ALL Caches Alphabetically"
        "Sync Cache with Destination Folders"
        "Sync Episode Cache with Destination"
        "MOVIE UNIFIED CACHE"
        "MOVIE 4K CACHE"
        "MOVIE 1080p CACHE"
        "MOVIE 1080p SOFTCORE CACHE"
        "MOVIE 4K SOFTCORE CACHE"
        "MOVIE CARTOONS CACHE"
        "MOVIE ANIME CACHE"
        "SHOWS TV CACHE"
        "SHOWS ANIME CACHE"
        "SHOWS CARTOONS CACHE"
        "TV EPISODES CACHE"
        "ANIME EPISODES CACHE"
        "CARTOON EPISODES CACHE"
        "Clear ALL Caches"
        "Clear Movie JSON Databases"
        "Clear TV Show JSON Databases"
        "Clear ALL JSON Databases"
        "Clear ALL Caches + JSON Databases"
    )
    local selected_idx=0
    
    while true; do
        clear
        
        echo ""
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${CYAN}CACHE MANAGEMENT${NC}"
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
        echo -e "${DIM}Select a cache: ENTER TO CLEAR, WARNING: CACHE WILL BE CLEARED ON ENTER PRESS no confirmation ${NC}"
        echo ""
        
        # Show cache file sizes
        local unified_count=0
        local fourk_count=0
        local p1080_count=0
        local p1080_soft_count=0
        local fourk_soft_count=0
        local cartoon_count=0
        local anime_movie_count=0
        local tv_count=0
        local anime_count=0
        local cartoon_tv_count=0
        
        # Count only non-empty lines (ignore blank lines)
        if [[ -f "$CACHE_DIR/MOVIE UNIFIED CACHE.txt" ]]; then
            unified_count=$(awk 'NF' "$CACHE_DIR/MOVIE UNIFIED CACHE.txt" 2>/dev/null | wc -l | tr -d ' ' || echo 0)
        fi
        if [[ -f "$CACHE_DIR/MOVIE 4K CACHE.txt" ]]; then
            fourk_count=$(awk 'NF' "$CACHE_DIR/MOVIE 4K CACHE.txt" 2>/dev/null | wc -l | tr -d ' ' || echo 0)
        fi
        if [[ -f "$CACHE_DIR/MOVIE 1080p CACHE.txt" ]]; then
            p1080_count=$(awk 'NF' "$CACHE_DIR/MOVIE 1080p CACHE.txt" 2>/dev/null | wc -l | tr -d ' ' || echo 0)
        fi
        if [[ -f "$CACHE_DIR/MOVIE 1080p SOFTCORE CACHE.txt" ]]; then
            p1080_soft_count=$(awk 'NF' "$CACHE_DIR/MOVIE 1080p SOFTCORE CACHE.txt" 2>/dev/null | wc -l | tr -d ' ' || echo 0)
        fi
        if [[ -f "$CACHE_DIR/MOVIE 4K SOFTCORE CACHE.txt" ]]; then
            fourk_soft_count=$(awk 'NF' "$CACHE_DIR/MOVIE 4K SOFTCORE CACHE.txt" 2>/dev/null | wc -l | tr -d ' ' || echo 0)
        fi
        if [[ -f "$CARTOON_CACHE_FILE" ]]; then
            cartoon_count=$(awk 'NF' "$CARTOON_CACHE_FILE" 2>/dev/null | wc -l | tr -d ' ' || echo 0)
        fi
        if [[ -f "$ANIME_MOVIE_CACHE_FILE" ]]; then
            anime_movie_count=$(awk 'NF' "$ANIME_MOVIE_CACHE_FILE" 2>/dev/null | wc -l | tr -d ' ' || echo 0)
        fi
        if [[ -f "$TV_CACHE_FILE" ]]; then
            tv_count=$(awk 'NF' "$TV_CACHE_FILE" 2>/dev/null | wc -l | tr -d ' ' || echo 0)
        fi
        if [[ -f "$ANIME_CACHE_FILE" ]]; then
            anime_count=$(awk 'NF' "$ANIME_CACHE_FILE" 2>/dev/null | wc -l | tr -d ' ' || echo 0)
        fi
        if [[ -f "$CARTOON_TV_CACHE_FILE" ]]; then
            cartoon_tv_count=$(awk 'NF' "$CARTOON_TV_CACHE_FILE" 2>/dev/null | wc -l | tr -d ' ' || echo 0)
        fi
        
        # Count episode cache files (all files in each directory)
        local tv_episodes_count=0
        local anime_episodes_count=0
        local cartoon_episodes_count=0
        
        if [[ -d "$TV_EPISODE_CACHE_DIR" ]]; then
            tv_episodes_count=$(find "$TV_EPISODE_CACHE_DIR" -type f -name "*.txt" 2>/dev/null | wc -l | tr -d ' ' || echo 0)
        fi
        if [[ -d "$ANIME_EPISODE_CACHE_DIR" ]]; then
            anime_episodes_count=$(find "$ANIME_EPISODE_CACHE_DIR" -type f -name "*.txt" 2>/dev/null | wc -l | tr -d ' ' || echo 0)
        fi
        if [[ -d "$CARTOON_EPISODE_CACHE_DIR" ]]; then
            cartoon_episodes_count=$(find "$CARTOON_EPISODE_CACHE_DIR" -type f -name "*.txt" 2>/dev/null | wc -l | tr -d ' ' || echo 0)
        fi
        
        for i in "${!cache_files[@]}"; do
            local display_text="${cache_files[$i]}"
            local count_text=""
            
            case $i in
                0) count_text="" ;; # Back - no count
                1) count_text="" ;; # Sort ALL - no count
                2) count_text="" ;; # Sync Cache - no count
                3) count_text="" ;; # Sync Episode Cache - no count
                4) count_text=" ${DIM}[$unified_count entries]${NC}" ;;
                5) count_text=" ${DIM}[$fourk_count entries]${NC}" ;;
                6) count_text=" ${DIM}[$p1080_count entries]${NC}" ;;
                7) count_text=" ${DIM}[$p1080_soft_count entries]${NC}" ;;
                8) count_text=" ${DIM}[$fourk_soft_count entries]${NC}" ;;
                9) count_text=" ${DIM}[$cartoon_count entries]${NC}" ;;
                10) count_text=" ${DIM}[$anime_movie_count entries]${NC}" ;;
                11) count_text=" ${DIM}[$tv_count entries]${NC}" ;;
                12) count_text=" ${DIM}[$anime_count entries]${NC}" ;;
                13) count_text=" ${DIM}[$cartoon_tv_count entries]${NC}" ;;
                14) count_text=" ${DIM}[$tv_episodes_count series]${NC}" ;;
                15) count_text=" ${DIM}[$anime_episodes_count series]${NC}" ;;
                16) count_text=" ${DIM}[$cartoon_episodes_count series]${NC}" ;;
                17) 
                    local total=$((unified_count + fourk_count + p1080_count + p1080_soft_count + fourk_soft_count + cartoon_count + anime_movie_count + tv_count + anime_count + cartoon_tv_count))
                    count_text=" ${DIM}[$total total entries]${NC}"
                    ;;
            esac
            
            if [[ $i -eq $selected_idx ]]; then
                echo -e "  ${GREEN}▶ ${display_text}${count_text}${NC}"
            else
                echo -e "    ${DIM}${display_text}${count_text}${NC}"
            fi
        done
        
        echo ""
        echo -e "${DIM}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${YELLOW}↑/↓${NC}: Navigate  ${YELLOW}ENTER${NC}: Select  ${YELLOW}b${NC}: Go Back"
        echo -e "${DIM}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
        
        read -rsn1 key 2>/dev/null
        
        if [[ "$key" == $'\x1b' ]]; then
            read -rsn2 -t 1 key 2>/dev/null
            case "$key" in
                '[A') ((selected_idx > 0)) && ((selected_idx--)) ;;
                '[B') ((selected_idx < ${#cache_files[@]} - 1)) && ((selected_idx++)) ;;
            esac
        elif [[ "$key" == "b" || "$key" == "B" ]]; then
            return 0
        elif [[ "$key" == "" ]]; then
            case $selected_idx in
                0) # Back
                    return 0
                    ;;
                1) # Sort ALL Caches Alphabetically
                    local sorted_count=0
                    local cache_list=(
                        "$CACHE_DIR/MOVIE UNIFIED CACHE.txt"
                        "$CACHE_DIR/MOVIE 4K CACHE.txt"
                        "$CACHE_DIR/MOVIE 1080p CACHE.txt"
                        "$CACHE_DIR/MOVIE 1080p SOFTCORE CACHE.txt"
                        "$CACHE_DIR/MOVIE 4K SOFTCORE CACHE.txt"
                        "$CARTOON_CACHE_FILE"
                        "$ANIME_MOVIE_CACHE_FILE"
                        "$TV_CACHE_FILE"
                        "$ANIME_CACHE_FILE"
                        "$CARTOON_TV_CACHE_FILE"
                    )
                    echo ""
                    echo -e "${CYAN}Sorting caches alphabetically...${NC}"
                    echo ""
                    for cache_file in "${cache_list[@]}"; do
                        if [[ -f "$cache_file" ]]; then
                            local entries=$(wc -l < "$cache_file" 2>/dev/null | tr -d ' ')
                            sort -t'|' -k1,1 "$cache_file" -o "${cache_file}.tmp" && mv "${cache_file}.tmp" "$cache_file"
                            print_success "$(basename "$cache_file"): $entries entries sorted"
                            ((sorted_count++))
                        fi
                    done
                    echo ""
                    if [[ $sorted_count -gt 0 ]]; then
                        print_success "Sorted $sorted_count cache file(s) alphabetically"
                    else
                        print_info "No cache files found to sort"
                    fi
                    echo ""
                    echo -e "${DIM}Press any key to continue...${NC}"
                    read -rsn1
                    ;;
                2) # Sync Cache with Destination Folders
                    tput cnorm 2>/dev/null
                    echo ""
                    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                    echo -e "${CYAN}Sync Cache with Destination${NC}"
                    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                    echo ""
                    echo -e "${YELLOW}Enter destination folder path:${NC}"
                    echo -e "${DIM}(You can drag & drop a folder or paste the path)${NC}"
                    echo ""
                    stty echo 2>/dev/null
                    read -e -p "> " sync_dest_path
                    stty -echo 2>/dev/null
                    
                    # Remove quotes and trim whitespace
                    sync_dest_path=$(echo "$sync_dest_path" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e "s/^'//" -e "s/'$//" -e 's/^"//' -e 's/"$//')
                    
                    if [[ -z "$sync_dest_path" ]]; then
                        echo ""
                        print_info "Cancelled - no path provided"
                        echo ""
                        echo -e "${DIM}Press any key to continue...${NC}"
                        read -rsn1
                        tput civis 2>/dev/null
                        continue
                    fi
                    
                    if [[ ! -d "$sync_dest_path" ]]; then
                        echo ""
                        print_error "Directory not found: $sync_dest_path"
                        echo ""
                        echo -e "${DIM}Press any key to continue...${NC}"
                        read -rsn1
                        tput civis 2>/dev/null
                        continue
                    fi
                    
                    # Select which cache to sync
                    echo ""
                    echo -e "${YELLOW}Select cache to sync with this destination:${NC}"
                    echo ""
                    echo -e "  ${GREEN}1${NC} - MOVIE UNIFIED CACHE"
                    echo -e "  ${GREEN}2${NC} - MOVIE 4K CACHE"
                    echo -e "  ${GREEN}3${NC} - MOVIE 1080p CACHE"
                    echo -e "  ${GREEN}4${NC} - MOVIE 1080p SOFTCORE CACHE"
                    echo -e "  ${GREEN}5${NC} - MOVIE 4K SOFTCORE CACHE"
                    echo -e "  ${GREEN}6${NC} - MOVIE CARTOONS CACHE"
                    echo -e "  ${GREEN}7${NC} - MOVIE ANIME CACHE"
                    echo -e "  ${GREEN}8${NC} - SHOWS TV CACHE"
                    echo -e "  ${GREEN}9${NC} - SHOWS ANIME CACHE"
                    echo -e "  ${GREEN}10${NC} - SHOWS CARTOONS CACHE"
                    echo ""
                    read -p "Enter choice (1-10): " cache_choice
                    
                    local selected_cache=""
                    local cache_name=""
                    
                    case "$cache_choice" in
                        1)
                            selected_cache="$CACHE_DIR/MOVIE UNIFIED CACHE.txt"
                            cache_name="Unified"
                            ;;
                        2)
                            selected_cache="$CACHE_DIR/MOVIE 4K CACHE.txt"
                            cache_name="4K"
                            ;;
                        3)
                            selected_cache="$CACHE_DIR/MOVIE 1080p CACHE.txt"
                            cache_name="1080p"
                            ;;
                        4)
                            selected_cache="$CACHE_DIR/MOVIE 1080p SOFTCORE CACHE.txt"
                            cache_name="1080p Softcore"
                            ;;
                        5)
                            selected_cache="$CACHE_DIR/MOVIE 4K SOFTCORE CACHE.txt"
                            cache_name="4K Softcore"
                            ;;
                        6)
                            selected_cache="$CARTOON_CACHE_FILE"
                            cache_name="Cartoon Movies"
                            ;;
                        7)
                            selected_cache="$ANIME_MOVIE_CACHE_FILE"
                            cache_name="Anime Movies"
                            ;;
                        8)
                            selected_cache="$TV_CACHE_FILE"
                            cache_name="TV Shows"
                            ;;
                        9)
                            selected_cache="$ANIME_CACHE_FILE"
                            cache_name="Anime TV Shows"
                            ;;
                        10)
                            selected_cache="$CARTOON_TV_CACHE_FILE"
                            cache_name="Cartoon TV Shows"
                            ;;
                        *)
                            echo ""
                            print_info "Invalid choice"
                            echo ""
                            echo -e "${DIM}Press any key to continue...${NC}"
                            read -rsn1
                            tput civis 2>/dev/null
                            continue
                            ;;
                    esac
                    
                    if [[ ! -f "$selected_cache" ]]; then
                        echo ""
                        print_error "Cache file not found: $(basename "$selected_cache")"
                        echo ""
                        echo -e "${DIM}Press any key to continue...${NC}"
                        read -rsn1
                        tput civis 2>/dev/null
                        continue
                    fi
                    
                    echo ""
                    echo -e "${CYAN}Syncing $cache_name cache with destination...${NC}"
                    echo -e "${DIM}Destination: $sync_dest_path${NC}"
                    echo ""
                    
                    local total_cached=0
                    local matched=0
                    local cache_missing_in_dest=0
                    local -a cache_missing_entries=()
                    local -a found_ids=()
                    local -a invalid_entries=()
                    
                    # Build destination folder list once for fast lookup
                    local temp_dest_list="/tmp/movie_dest_folders_$$.txt"
                    should_debug high && echo "[DEBUG] Scanning destination: '$sync_dest_path'" >&2
                    should_debug high && echo "[DEBUG] Folder count: $(ls -1 "$sync_dest_path" 2>/dev/null | wc -l)" >&2
                    ls -1 "$sync_dest_path" 2>/dev/null > "$temp_dest_list"
                    
                    # Check cache entries against destination
                    while IFS='|' read -r title year imdb_id tmdb_id timestamp; do
                        # Skip empty lines
                        [[ -z "$title" ]] && continue
                        
                        # Count valid entries only
                        if [[ -z "$year" ]] || [[ -z "$imdb_id" && -z "$tmdb_id" ]]; then
                            # Invalid entry format
                            invalid_entries+=("$title")
                            continue
                        fi
                        
                        ((total_cached++))
                        
                        # Check if any folder in destination contains IMDb ID or TMDb ID using awk
                        local found=false
                        if [[ -n "$imdb_id" ]]; then
                            if awk -v id="$imdb_id" '$0 ~ "imdb-"id || $0 ~ "imdbid-"id {exit 0} END {exit 1}' "$temp_dest_list" 2>/dev/null; then
                                found=true
                                found_ids+=("$imdb_id")
                            fi
                        fi
                        if [[ "$found" == false && -n "$tmdb_id" ]]; then
                            if awk -v id="$tmdb_id" '$0 ~ "tmdb-"id || $0 ~ "tmdbid-"id {exit 0} END {exit 1}' "$temp_dest_list" 2>/dev/null; then
                                found=true
                                found_ids+=("$tmdb_id")
                            fi
                        fi
                        
                        if [[ "$found" == true ]]; then
                            ((matched++))
                        else
                            ((cache_missing_in_dest++))
                            cache_missing_entries+=("$title ($year) - IMDb: ${imdb_id:-N/A}, TMDb: ${tmdb_id:-N/A}")
                        fi
                    done < "$selected_cache"
                    
                    # Cleanup temp file
                    rm -f "$temp_dest_list" 2>/dev/null
                    
                    # Check destination folders not in cache
                    local dest_missing_in_cache=0
                    local -a dest_missing_entries=()
                    local total_in_dest=0
                    
                    should_debug high && echo "[DEBUG] Starting destination folder scan with find..." >&2
                    
                    while IFS= read -r -d '' folder; do
                        local folder_name=$(basename "$folder")
                        
                        # Extract IMDb, TMDb, and TVDb IDs from folder name
                        local folder_imdb=""
                        local folder_tmdb=""
                        local folder_tvdb=""
                        
                        if [[ "$folder_name" =~ \[imdbid-(tt[0-9]+)\] ]]; then
                            folder_imdb="${BASH_REMATCH[1]}"
                        elif [[ "$folder_name" =~ \[imdb-(tt[0-9]+)\] ]]; then
                            folder_imdb="${BASH_REMATCH[1]}"
                        elif [[ "$folder_name" =~ \{imdb-(tt[0-9]+)\} ]]; then
                            folder_imdb="${BASH_REMATCH[1]}"
                        fi
                        
                        if [[ "$folder_name" =~ \[tmdbid-([0-9]+)\] ]]; then
                            folder_tmdb="${BASH_REMATCH[1]}"
                        elif [[ "$folder_name" =~ \[tmdb-([0-9]+)\] ]]; then
                            folder_tmdb="${BASH_REMATCH[1]}"
                        elif [[ "$folder_name" =~ \{tmdb-([0-9]+)\} ]]; then
                            folder_tmdb="${BASH_REMATCH[1]}"
                        fi
                        
                        if [[ "$folder_name" =~ \[tvdbid-([0-9]+)\] ]]; then
                            folder_tvdb="${BASH_REMATCH[1]}"
                        elif [[ "$folder_name" =~ \[tvdb-([0-9]+)\] ]]; then
                            folder_tvdb="${BASH_REMATCH[1]}"
                        elif [[ "$folder_name" =~ \{tvdb-([0-9]+)\} ]]; then
                            folder_tvdb="${BASH_REMATCH[1]}"
                        fi
                        
                        # Skip if no IDs found
                        if [[ -z "$folder_imdb" && -z "$folder_tmdb" && -z "$folder_tvdb" ]]; then
                            continue
                        fi
                        
                        ((total_in_dest++))
                        
                        # Check if this folder's IDs are in cache
                        local in_cache=false
                        if [[ -n "$folder_imdb" ]]; then
                            if grep -q "|$folder_imdb|" "$selected_cache" 2>/dev/null; then
                                in_cache=true
                            fi
                        fi
                        if [[ "$in_cache" == false && -n "$folder_tmdb" ]]; then
                            if grep -q "|$folder_tmdb|" "$selected_cache" 2>/dev/null; then
                                in_cache=true
                            fi
                        fi
                        
                        if [[ "$in_cache" == false ]]; then
                            ((dest_missing_in_cache++))
                            dest_missing_entries+=("$folder_name")
                        fi
                    done < <(find "$sync_dest_path" -mindepth 1 -maxdepth 1 -type d -print0 2>/dev/null)
                    
                    should_debug high && echo "[DEBUG] Destination scan complete. Found $total_in_dest folders with IDs" >&2
                    
                    # Display results
                    echo -e "${CYAN}Sync Results:${NC}"
                    echo -e "  Destination path: $sync_dest_path"
                    echo -e "  Total in cache: $total_cached"
                    echo -e "  Total in destination: $total_in_dest"
                    echo -e "  ${GREEN}Matched: $matched${NC}"
                    echo ""
                    
                    if [[ $cache_missing_in_dest -gt 0 ]]; then
                        echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                        echo -e "${YELLOW}⚠  CACHE ENTRIES NOT IN DESTINATION: $cache_missing_in_dest${NC}"
                        echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                        echo -e "${DIM}These entries exist in cache but no matching folder in destination:${NC}"
                        echo ""
                        for entry in "${cache_missing_entries[@]}"; do
                            echo -e "  ${YELLOW}• $entry${NC}"
                        done
                        echo ""
                    fi
                    
                    if [[ $dest_missing_in_cache -gt 0 ]]; then
                        echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                        echo -e "${YELLOW}⚠  DESTINATION FOLDERS NOT IN CACHE: $dest_missing_in_cache${NC}"
                        echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                        echo -e "${DIM}These folders exist in destination but not in cache:${NC}"
                        echo ""
                        for entry in "${dest_missing_entries[@]}"; do
                            echo -e "  ${YELLOW}• $entry${NC}"
                        done
                        echo ""
                    fi
                    
                    if [[ ${#invalid_entries[@]} -gt 0 ]]; then
                        echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                        echo -e "${RED}⚠  INVALID CACHE ENTRIES: ${#invalid_entries[@]}${NC}"
                        echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                        echo -e "${DIM}These entries have invalid format (missing title, year, or IDs):${NC}"
                        echo ""
                        for entry in "${invalid_entries[@]}"; do
                            echo -e "  ${RED}• $entry${NC}"
                        done
                        echo ""
                    fi
                    
                    if [[ $matched -eq $total_cached && $dest_missing_in_cache -eq 0 && ${#invalid_entries[@]} -eq 0 ]]; then
                        echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                        echo -e "${GREEN}✓ PERFECT SYNC - ALL ENTRIES MATCH!${NC}"
                        echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                        echo ""
                    fi
                    
                    # Offer sync actions if there are mismatches
                    if [[ $cache_missing_in_dest -gt 0 || $dest_missing_in_cache -gt 0 || ${#invalid_entries[@]} -gt 0 ]]; then
                        echo ""
                        echo -e "${CYAN}Sync Actions:${NC}"
                        echo -e "  ${DIM}1)${NC} Remove cache entries not in destination ($cache_missing_in_dest entries)"
                        echo -e "  ${DIM}2)${NC} Add destination folders to cache ($dest_missing_in_cache folders)"
                        echo -e "  ${DIM}3)${NC} Do both (full sync)"
                        echo -e "  ${DIM}4)${NC} Remove invalid cache entries (${#invalid_entries[@]} entries)"
                        echo -e "  ${DIM}0)${NC} Skip - return to menu"
                        echo ""
                        echo -n "Choose action: "
                        read -r sync_action
                        
                        case "$sync_action" in
                            1) # Remove cache entries not in destination
                                echo ""
                                echo -e "${YELLOW}Removing $cache_missing_in_dest cache entries...${NC}"
                                local removed=0
                                for entry in "${cache_missing_entries[@]}"; do
                                    # Extract IMDb/TMDb from entry string
                                    local entry_imdb=""
                                    local entry_tmdb=""
                                    if [[ "$entry" =~ IMDb:[[:space:]]*(tt[0-9]+) ]]; then
                                        entry_imdb="${BASH_REMATCH[1]}"
                                    fi
                                    if [[ "$entry" =~ TMDb:[[:space:]]*([0-9]+) ]]; then
                                        entry_tmdb="${BASH_REMATCH[1]}"
                                    fi
                                    
                                    # Remove line from cache
                                    if [[ -n "$entry_imdb" ]]; then
                                        sed -i.bak "/|$entry_imdb|/d" "$selected_cache"
                                        ((removed++))
                                    elif [[ -n "$entry_tmdb" ]]; then
                                        sed -i.bak "/|$entry_tmdb|/d" "$selected_cache"
                                        ((removed++))
                                    fi
                                done
                                [[ -f "${selected_cache}.bak" ]] && rm "${selected_cache}.bak"
                                echo -e "${GREEN}✓ Removed $removed entries from cache${NC}"
                                ;;
                            2) # Add destination folders to cache
                                echo ""
                                echo -e "${CYAN}Adding $dest_missing_in_cache destination folders to cache...${NC}"
                                echo -e "${DIM}Using API delay: ${API_DELAY}s between calls${NC}"
                                [[ "$PARALLEL_PROCESSING" == "true" ]] && echo -e "${DIM}Parallel processing: ${PARALLEL_JOBS} jobs${NC}"
                                local added=0
                                local api_calls=0
                                local sync_start_time=$SECONDS
                                
                                # Use parallel processing if enabled
                                if [[ "$PARALLEL_PROCESSING" == "true" ]]; then
                                    local total_entries=${#dest_missing_entries[@]}
                                    local entry_index=0
                                    local batch_size=$PARALLEL_JOBS
                                    local temp_results="/tmp/cache_sync_results_$$.txt"
                                    local temp_progress="/tmp/cache_sync_progress_$$.txt"
                                    > "$temp_results"
                                    > "$temp_progress"
                                    
                                    while [[ $entry_index -lt $total_entries ]]; do
                                        local batch_pids=()
                                        local -a batch_folders=()
                                        
                                        for ((i=0; i<batch_size && entry_index<total_entries; i++)); do
                                            local folder_name="${dest_missing_entries[$entry_index]}"
                                            batch_folders+=("$folder_name")
                                            ((entry_index++))
                                            
                                            # Extract title and year for progress message
                                            local display_title=$(echo "$folder_name" | sed -E 's/[[:space:]]*\([0-9]{4}\).*//' | sed -E 's/[[:space:]]*\[.*//')
                                            local display_year=""
                                            [[ "$folder_name" =~ \(([0-9]{4})\) ]] && display_year="${BASH_REMATCH[1]}"
                                            
                                            # Check if API call will be needed
                                            local needs_api=false
                                            local has_imdb=false has_tmdb=false
                                            [[ "$folder_name" =~ \[(imdbid-|imdb-)(tt[0-9]+)\] ]] && has_imdb=true
                                            [[ "$folder_name" =~ \[(tmdbid-|tmdb-)([0-9]+)\] ]] && has_tmdb=true
                                            [[ "$has_imdb" == true && "$has_tmdb" == false ]] && needs_api=true
                                            [[ "$has_imdb" == false && "$has_tmdb" == true ]] && needs_api=true
                                            
                                            if [[ "$needs_api" == true && -n "$TMDB_API_KEY" ]]; then
                                                if [[ "$has_imdb" == true ]]; then
                                                    echo -e "${DIM}  Fetching TMDb ID for: $display_title ($display_year)...${NC}"
                                                else
                                                    echo -e "${DIM}  Fetching IMDb ID for: $display_title ($display_year)...${NC}"
                                                fi
                                            fi
                                            
                                            # Process in background
                                            (
                                                local folder_title="" folder_year="" folder_imdb="" folder_tmdb="" folder_tvdb=""
                                                
                                                [[ "$folder_name" =~ \(([0-9]{4})\) ]] && folder_year="${BASH_REMATCH[1]}"
                                                
                                                if [[ "$folder_name" =~ \[imdbid-(tt[0-9]+)\] ]]; then folder_imdb="${BASH_REMATCH[1]}"
                                                elif [[ "$folder_name" =~ \[imdb-(tt[0-9]+)\] ]]; then folder_imdb="${BASH_REMATCH[1]}"
                                                elif [[ "$folder_name" =~ \{imdb-(tt[0-9]+)\} ]]; then folder_imdb="${BASH_REMATCH[1]}"
                                                fi
                                                
                                                if [[ "$folder_name" =~ \[tmdbid-([0-9]+)\] ]]; then folder_tmdb="${BASH_REMATCH[1]}"
                                                elif [[ "$folder_name" =~ \[tmdb-([0-9]+)\] ]]; then folder_tmdb="${BASH_REMATCH[1]}"
                                                elif [[ "$folder_name" =~ \{tmdb-([0-9]+)\} ]]; then folder_tmdb="${BASH_REMATCH[1]}"
                                                fi
                                                
                                                if [[ "$folder_name" =~ \[tvdbid-([0-9]+)\] ]]; then folder_tvdb="${BASH_REMATCH[1]}"
                                                elif [[ "$folder_name" =~ \[tvdb-([0-9]+)\] ]]; then folder_tvdb="${BASH_REMATCH[1]}"
                                                elif [[ "$folder_name" =~ \{tvdb-([0-9]+)\} ]]; then folder_tvdb="${BASH_REMATCH[1]}"
                                                fi
                                                
                                                folder_title=$(echo "$folder_name" | sed -E 's/[[:space:]]*\([0-9]{4}\).*//' | sed -E 's/[[:space:]]*\[.*//')
                                                
                                                local api_made=0
                                                if [[ -n "$folder_imdb" && -z "$folder_tmdb" && -n "$TMDB_API_KEY" ]]; then
                                                    sleep "$API_DELAY"
                                                    local find_url="${TMDB_API_BASE}/find/${folder_imdb}?api_key=${TMDB_API_KEY}&external_source=imdb_id"
                                                    local find_result=$(curl -s "$find_url" 2>/dev/null)
                                                    folder_tmdb=$(echo "$find_result" | grep -oE '"id":[0-9]+' | head -1 | grep -oE '[0-9]+')
                                                    api_made=1
                                                    [[ -n "$folder_tmdb" ]] && echo "FOUND_TMDB|$folder_tmdb" >> "$temp_progress"
                                                elif [[ -n "$folder_tmdb" && -z "$folder_imdb" && -n "$TMDB_API_KEY" ]]; then
                                                    sleep "$API_DELAY"
                                                    local movie_url="${TMDB_API_BASE}/movie/${folder_tmdb}?api_key=${TMDB_API_KEY}&append_to_response=external_ids"
                                                    local movie_result=$(curl -s "$movie_url" 2>/dev/null)
                                                    folder_imdb=$(echo "$movie_result" | grep -oE '"imdb_id":"tt[0-9]+"' | grep -oE 'tt[0-9]+')
                                                    api_made=1
                                                    [[ -n "$folder_imdb" ]] && echo "FOUND_IMDB|$folder_imdb" >> "$temp_progress"
                                                fi
                                                
                                                if [[ -n "$folder_title" && -n "$folder_year" && ( -n "$folder_imdb" || -n "$folder_tmdb" ) ]]; then
                                                    local timestamp=$(date +%s)
                                                    # Write to cache immediately
                                                    echo "${folder_title}|${folder_year}|${folder_imdb}|${folder_tmdb}|${timestamp}" >> "$selected_cache" 2>/dev/null || true
                                                    echo "ADDED|$api_made"
                                                fi
                                            ) >> "$temp_results" &
                                            
                                            batch_pids+=($!)
                                        done
                                        
                                        # Wait for batch to complete and show results
                                        for pid in "${batch_pids[@]}"; do
                                            wait "$pid"
                                        done
                                        
                                        # Display completion messages for this batch
                                        if [[ -f "$temp_progress" ]]; then
                                            while IFS='|' read -r msg_type msg_value; do
                                                if [[ "$msg_type" == "FOUND_TMDB" ]]; then
                                                    echo -e "${GREEN}  ✓ Found TMDb ID: $msg_value${NC}"
                                                elif [[ "$msg_type" == "FOUND_IMDB" ]]; then
                                                    echo -e "${GREEN}  ✓ Found IMDb ID: $msg_value${NC}"
                                                fi
                                            done < "$temp_progress"
                                            > "$temp_progress"
                                        fi
                                    done
                                    
                                    # Count results (cache already written immediately by each subshell)
                                    while IFS='|' read -r result_type api_made; do
                                        [[ "$result_type" == "ADDED" ]] && ((added++))
                                        [[ "$api_made" == "1" ]] && ((api_calls++))
                                    done < "$temp_results"
                                    
                                    rm -f "$temp_results" "$temp_progress"
                                else
                                    # Sequential processing
                                    for folder_name in "${dest_missing_entries[@]}"; do
                                        local folder_title="" folder_year="" folder_imdb="" folder_tmdb="" folder_tvdb=""
                                        
                                        [[ "$folder_name" =~ \(([0-9]{4})\) ]] && folder_year="${BASH_REMATCH[1]}"
                                        
                                        if [[ "$folder_name" =~ \[imdbid-(tt[0-9]+)\] ]]; then folder_imdb="${BASH_REMATCH[1]}"
                                        elif [[ "$folder_name" =~ \[imdb-(tt[0-9]+)\] ]]; then folder_imdb="${BASH_REMATCH[1]}"
                                        elif [[ "$folder_name" =~ \{imdb-(tt[0-9]+)\} ]]; then folder_imdb="${BASH_REMATCH[1]}"
                                        fi
                                        
                                        if [[ "$folder_name" =~ \[tmdbid-([0-9]+)\] ]]; then folder_tmdb="${BASH_REMATCH[1]}"
                                        elif [[ "$folder_name" =~ \[tmdb-([0-9]+)\] ]]; then folder_tmdb="${BASH_REMATCH[1]}"
                                        elif [[ "$folder_name" =~ \{tmdb-([0-9]+)\} ]]; then folder_tmdb="${BASH_REMATCH[1]}"
                                        fi
                                        
                                        if [[ "$folder_name" =~ \[tvdbid-([0-9]+)\] ]]; then folder_tvdb="${BASH_REMATCH[1]}"
                                        elif [[ "$folder_name" =~ \[tvdb-([0-9]+)\] ]]; then folder_tvdb="${BASH_REMATCH[1]}"
                                        elif [[ "$folder_name" =~ \{tvdb-([0-9]+)\} ]]; then folder_tvdb="${BASH_REMATCH[1]}"
                                        fi
                                        
                                        folder_title=$(echo "$folder_name" | sed -E 's/[[:space:]]*\([0-9]{4}\).*//' | sed -E 's/[[:space:]]*\[.*//')
                                        
                                        if [[ -n "$folder_imdb" && -z "$folder_tmdb" && -n "$TMDB_API_KEY" ]]; then
                                            echo -e "${DIM}  Fetching TMDb ID for: $folder_title ($folder_year)...${NC}"
                                            api_delay
                                            local find_url="${TMDB_API_BASE}/find/${folder_imdb}?api_key=${TMDB_API_KEY}&external_source=imdb_id"
                                            local find_result=$(curl -s "$find_url" 2>/dev/null)
                                            folder_tmdb=$(echo "$find_result" | grep -oE '"id":[0-9]+' | head -1 | grep -oE '[0-9]+')
                                            ((api_calls++))
                                            [[ -n "$folder_tmdb" ]] && echo -e "${GREEN}  ✓ Found TMDb ID: $folder_tmdb${NC}"
                                        elif [[ -n "$folder_tmdb" && -z "$folder_imdb" && -n "$TMDB_API_KEY" ]]; then
                                            echo -e "${DIM}  Fetching IMDb ID for: $folder_title ($folder_year)...${NC}"
                                            api_delay
                                            local movie_url="${TMDB_API_BASE}/movie/${folder_tmdb}?api_key=${TMDB_API_KEY}&append_to_response=external_ids"
                                            local movie_result=$(curl -s "$movie_url" 2>/dev/null)
                                            folder_imdb=$(echo "$movie_result" | grep -oE '"imdb_id":"tt[0-9]+"' | grep -oE 'tt[0-9]+')
                                            ((api_calls++))
                                            [[ -n "$folder_imdb" ]] && echo -e "${GREEN}  ✓ Found IMDb ID: $folder_imdb${NC}"
                                        fi
                                        
                                        if [[ -n "$folder_title" && -n "$folder_year" && ( -n "$folder_imdb" || -n "$folder_tmdb" ) ]]; then
                                            local timestamp=$(date +%s)
                                            echo "${folder_title}|${folder_year}|${folder_imdb}|${folder_tmdb}|${timestamp}" >> "$selected_cache"
                                            ((added++))
                                        fi
                                    done
                                fi
                                
                                local sync_elapsed=$((SECONDS - sync_start_time))
                                local api_rate=$(awk "BEGIN {printf \"%.2f\", $api_calls / ($sync_elapsed > 0 ? $sync_elapsed : 1)}")
                                echo -e "${GREEN}✓ Added $added folders to cache${NC}"
                                if [[ $api_calls -gt 0 ]]; then
                                    echo -e "${DIM}  API calls: $api_calls (${api_rate}/sec average, ${sync_elapsed}s total)${NC}"
                                else
                                    echo -e "${DIM}  API calls: 0 (all IDs found in folder names)${NC}"
                                fi
                                ;;
                            3) # Do both
                                echo ""
                                echo -e "${CYAN}Performing full sync...${NC}"
                                echo -e "${DIM}Using API delay: ${API_DELAY}s between calls${NC}"
                                [[ "$PARALLEL_PROCESSING" == "true" ]] && echo -e "${DIM}Parallel processing: ${PARALLEL_JOBS} jobs${NC}"
                                
                                local api_calls=0
                                local sync_start_time=$SECONDS
                                
                                # Remove cache entries not in destination
                                echo -e "${YELLOW}Removing $cache_missing_in_dest cache entries...${NC}"
                                local removed=0
                                for entry in "${cache_missing_entries[@]}"; do
                                    local entry_imdb=""
                                    local entry_tmdb=""
                                    if [[ "$entry" =~ IMDb:[[:space:]]*(tt[0-9]+) ]]; then
                                        entry_imdb="${BASH_REMATCH[1]}"
                                    fi
                                    if [[ "$entry" =~ TMDb:[[:space:]]*([0-9]+) ]]; then
                                        entry_tmdb="${BASH_REMATCH[1]}"
                                    fi
                                    
                                    if [[ -n "$entry_imdb" ]]; then
                                        sed -i.bak "/|$entry_imdb|/d" "$selected_cache"
                                        ((removed++))
                                    elif [[ -n "$entry_tmdb" ]]; then
                                        sed -i.bak "/|$entry_tmdb|/d" "$selected_cache"
                                        ((removed++))
                                    fi
                                done
                                [[ -f "${selected_cache}.bak" ]] && rm "${selected_cache}.bak"
                                echo -e "${GREEN}✓ Removed $removed entries from cache${NC}"
                                
                                # Add destination folders to cache
                                echo -e "${CYAN}Adding $dest_missing_in_cache destination folders to cache...${NC}"
                                local added=0
                                
                                # Use parallel processing if enabled
                                if [[ "$PARALLEL_PROCESSING" == "true" ]]; then
                                    local total_entries=${#dest_missing_entries[@]}
                                    local entry_index=0
                                    local batch_size=$PARALLEL_JOBS
                                    local temp_results="/tmp/cache_sync_results_$$.txt"
                                    local temp_progress="/tmp/cache_sync_progress_$$.txt"
                                    > "$temp_results"
                                    > "$temp_progress"
                                    
                                    while [[ $entry_index -lt $total_entries ]]; do
                                        local batch_pids=()
                                        
                                        for ((i=0; i<batch_size && entry_index<total_entries; i++)); do
                                            local folder_name="${dest_missing_entries[$entry_index]}"
                                            
                                            # Extract title and year for progress message
                                            local display_title=$(echo "$folder_name" | sed -E 's/[[:space:]]*\([0-9]{4}\).*//' | sed -E 's/[[:space:]]*\[.*//')
                                            local display_year=""
                                            [[ "$folder_name" =~ \(([0-9]{4})\) ]] && display_year="${BASH_REMATCH[1]}"
                                            
                                            # Check if API call will be needed
                                            local needs_api=false
                                            local has_imdb=false has_tmdb=false
                                            [[ "$folder_name" =~ \[(imdbid-|imdb-)(tt[0-9]+)\] ]] && has_imdb=true
                                            [[ "$folder_name" =~ \[(tmdbid-|tmdb-)([0-9]+)\] ]] && has_tmdb=true
                                            [[ "$has_imdb" == true && "$has_tmdb" == false ]] && needs_api=true
                                            [[ "$has_imdb" == false && "$has_tmdb" == true ]] && needs_api=true
                                            
                                            if [[ "$needs_api" == true && -n "$TMDB_API_KEY" ]]; then
                                                if [[ "$has_imdb" == true ]]; then
                                                    echo -e "${DIM}  Fetching TMDb ID for: $display_title ($display_year)...${NC}"
                                                else
                                                    echo -e "${DIM}  Fetching IMDb ID for: $display_title ($display_year)...${NC}"
                                                fi
                                            fi
                                            
                                            ((entry_index++))
                                            
                                            (
                                                local folder_title="" folder_year="" folder_imdb="" folder_tmdb="" folder_tvdb=""
                                                
                                                [[ "$folder_name" =~ \(([0-9]{4})\) ]] && folder_year="${BASH_REMATCH[1]}"
                                                
                                                if [[ "$folder_name" =~ \[imdbid-(tt[0-9]+)\] ]]; then folder_imdb="${BASH_REMATCH[1]}"
                                                elif [[ "$folder_name" =~ \[imdb-(tt[0-9]+)\] ]]; then folder_imdb="${BASH_REMATCH[1]}"
                                                elif [[ "$folder_name" =~ \{imdb-(tt[0-9]+)\} ]]; then folder_imdb="${BASH_REMATCH[1]}"
                                                fi
                                                
                                                if [[ "$folder_name" =~ \[tmdbid-([0-9]+)\] ]]; then folder_tmdb="${BASH_REMATCH[1]}"
                                                elif [[ "$folder_name" =~ \[tmdb-([0-9]+)\] ]]; then folder_tmdb="${BASH_REMATCH[1]}"
                                                elif [[ "$folder_name" =~ \{tmdb-([0-9]+)\} ]]; then folder_tmdb="${BASH_REMATCH[1]}"
                                                fi
                                                
                                                if [[ "$folder_name" =~ \[tvdbid-([0-9]+)\] ]]; then folder_tvdb="${BASH_REMATCH[1]}"
                                                elif [[ "$folder_name" =~ \[tvdb-([0-9]+)\] ]]; then folder_tvdb="${BASH_REMATCH[1]}"
                                                elif [[ "$folder_name" =~ \{tvdb-([0-9]+)\} ]]; then folder_tvdb="${BASH_REMATCH[1]}"
                                                fi
                                                
                                                folder_title=$(echo "$folder_name" | sed -E 's/[[:space:]]*\([0-9]{4}\).*//' | sed -E 's/[[:space:]]*\[.*//')
                                                
                                                local api_made=0
                                                if [[ -n "$folder_imdb" && -z "$folder_tmdb" && -n "$TMDB_API_KEY" ]]; then
                                                    sleep "$API_DELAY"
                                                    local find_url="${TMDB_API_BASE}/find/${folder_imdb}?api_key=${TMDB_API_KEY}&external_source=imdb_id"
                                                    local find_result=$(curl -s "$find_url" 2>/dev/null)
                                                    folder_tmdb=$(echo "$find_result" | grep -oE '"id":[0-9]+' | head -1 | grep -oE '[0-9]+')
                                                    api_made=1
                                                    [[ -n "$folder_tmdb" ]] && echo "FOUND_TMDB|$folder_tmdb" >> "$temp_progress"
                                                elif [[ -n "$folder_tmdb" && -z "$folder_imdb" && -n "$TMDB_API_KEY" ]]; then
                                                    sleep "$API_DELAY"
                                                    local movie_url="${TMDB_API_BASE}/movie/${folder_tmdb}?api_key=${TMDB_API_KEY}&append_to_response=external_ids"
                                                    local movie_result=$(curl -s "$movie_url" 2>/dev/null)
                                                    folder_imdb=$(echo "$movie_result" | grep -oE '"imdb_id":"tt[0-9]+"' | grep -oE 'tt[0-9]+')
                                                    api_made=1
                                                    [[ -n "$folder_imdb" ]] && echo "FOUND_IMDB|$folder_imdb" >> "$temp_progress"
                                                fi
                                                
                                                if [[ -n "$folder_title" && -n "$folder_year" && ( -n "$folder_imdb" || -n "$folder_tmdb" ) ]]; then
                                                    local timestamp=$(date +%s)
                                                    # Write to cache immediately
                                                    echo "${folder_title}|${folder_year}|${folder_imdb}|${folder_tmdb}|${timestamp}" >> "$selected_cache" 2>/dev/null || true
                                                    echo "ADDED|$api_made"
                                                fi
                                            ) >> "$temp_results" &
                                            
                                            batch_pids+=($!)
                                        done
                                        
                                        # Wait for batch to complete and show results
                                        for pid in "${batch_pids[@]}"; do
                                            wait "$pid"
                                        done
                                        
                                        # Display completion messages for this batch
                                        if [[ -f "$temp_progress" ]]; then
                                            while IFS='|' read -r msg_type msg_value; do
                                                if [[ "$msg_type" == "FOUND_TMDB" ]]; then
                                                    echo -e "${GREEN}  ✓ Found TMDb ID: $msg_value${NC}"
                                                elif [[ "$msg_type" == "FOUND_IMDB" ]]; then
                                                    echo -e "${GREEN}  ✓ Found IMDb ID: $msg_value${NC}"
                                                fi
                                            done < "$temp_progress"
                                            > "$temp_progress"
                                        fi
                                    done
                                    
                                    # Count results (cache already written immediately by each subshell)
                                    while IFS='|' read -r result_type api_made; do
                                        [[ "$result_type" == "ADDED" ]] && ((added++))
                                        [[ "$api_made" == "1" ]] && ((api_calls++))
                                    done < "$temp_results"
                                    
                                    rm -f "$temp_results" "$temp_progress"
                                else
                                    # Sequential processing
                                    for folder_name in "${dest_missing_entries[@]}"; do
                                        local folder_title="" folder_year="" folder_imdb="" folder_tmdb="" folder_tvdb=""
                                        
                                        [[ "$folder_name" =~ \(([0-9]{4})\) ]] && folder_year="${BASH_REMATCH[1]}"
                                        
                                        if [[ "$folder_name" =~ \[imdbid-(tt[0-9]+)\] ]]; then folder_imdb="${BASH_REMATCH[1]}"
                                        elif [[ "$folder_name" =~ \[imdb-(tt[0-9]+)\] ]]; then folder_imdb="${BASH_REMATCH[1]}"
                                        elif [[ "$folder_name" =~ \{imdb-(tt[0-9]+)\} ]]; then folder_imdb="${BASH_REMATCH[1]}"
                                        fi
                                        
                                        if [[ "$folder_name" =~ \[tmdbid-([0-9]+)\] ]]; then folder_tmdb="${BASH_REMATCH[1]}"
                                        elif [[ "$folder_name" =~ \[tmdb-([0-9]+)\] ]]; then folder_tmdb="${BASH_REMATCH[1]}"
                                        elif [[ "$folder_name" =~ \{tmdb-([0-9]+)\} ]]; then folder_tmdb="${BASH_REMATCH[1]}"
                                        fi
                                        
                                        if [[ "$folder_name" =~ \[tvdbid-([0-9]+)\] ]]; then folder_tvdb="${BASH_REMATCH[1]}"
                                        elif [[ "$folder_name" =~ \[tvdb-([0-9]+)\] ]]; then folder_tvdb="${BASH_REMATCH[1]}"
                                        elif [[ "$folder_name" =~ \{tvdb-([0-9]+)\} ]]; then folder_tvdb="${BASH_REMATCH[1]}"
                                        fi
                                        
                                        folder_title=$(echo "$folder_name" | sed -E 's/[[:space:]]*\([0-9]{4}\).*//' | sed -E 's/[[:space:]]*\[.*//')
                                        
                                        if [[ -n "$folder_imdb" && -z "$folder_tmdb" && -n "$TMDB_API_KEY" ]]; then
                                            echo -e "${DIM}  Fetching TMDb ID for: $folder_title ($folder_year)...${NC}"
                                            api_delay
                                            local find_url="${TMDB_API_BASE}/find/${folder_imdb}?api_key=${TMDB_API_KEY}&external_source=imdb_id"
                                            local find_result=$(curl -s "$find_url" 2>/dev/null)
                                            folder_tmdb=$(echo "$find_result" | grep -oE '"id":[0-9]+' | head -1 | grep -oE '[0-9]+')
                                            ((api_calls++))
                                            [[ -n "$folder_tmdb" ]] && echo -e "${GREEN}  ✓ Found TMDb ID: $folder_tmdb${NC}"
                                        elif [[ -n "$folder_tmdb" && -z "$folder_imdb" && -n "$TMDB_API_KEY" ]]; then
                                            echo -e "${DIM}  Fetching IMDb ID for: $folder_title ($folder_year)...${NC}"
                                            api_delay
                                            local movie_url="${TMDB_API_BASE}/movie/${folder_tmdb}?api_key=${TMDB_API_KEY}&append_to_response=external_ids"
                                            local movie_result=$(curl -s "$movie_url" 2>/dev/null)
                                            folder_imdb=$(echo "$movie_result" | grep -oE '"imdb_id":"tt[0-9]+"' | grep -oE 'tt[0-9]+')
                                            ((api_calls++))
                                            [[ -n "$folder_imdb" ]] && echo -e "${GREEN}  ✓ Found IMDb ID: $folder_imdb${NC}"
                                        fi
                                        
                                        if [[ -n "$folder_title" && -n "$folder_year" && ( -n "$folder_imdb" || -n "$folder_tmdb" ) ]]; then
                                            local timestamp=$(date +%s)
                                            echo "${folder_title}|${folder_year}|${folder_imdb}|${folder_tmdb}|${timestamp}" >> "$selected_cache"
                                            ((added++))
                                        fi
                                    done
                                fi
                                
                                local sync_elapsed=$((SECONDS - sync_start_time))
                                local api_rate=$(awk "BEGIN {printf \"%.2f\", $api_calls / ($sync_elapsed > 0 ? $sync_elapsed : 1)}")
                                echo -e "${GREEN}✓ Added $added folders to cache${NC}"
                                if [[ $api_calls -gt 0 ]]; then
                                    echo -e "${DIM}  API calls: $api_calls (${api_rate}/sec average, ${sync_elapsed}s total)${NC}"
                                else
                                    echo -e "${DIM}  API calls: 0 (all IDs found in folder names)${NC}"
                                fi
                                echo ""
                                echo -e "${GREEN}✓ Full sync complete!${NC}"
                                ;;
                            4) # Remove invalid entries
                                echo ""
                                echo -e "${YELLOW}Removing ${#invalid_entries[@]} invalid cache entries...${NC}"
                                local removed=0
                                for invalid_entry in "${invalid_entries[@]}"; do
                                    # Escape special characters for sed
                                    local escaped_entry=$(printf '%s\n' "$invalid_entry" | sed 's/[[\.*^$()+?{|]/\\&/g')
                                    sed -i.bak "/^${escaped_entry}$/d" "$selected_cache"
                                    ((removed++))
                                done
                                [[ -f "${selected_cache}.bak" ]] && rm "${selected_cache}.bak"
                                echo -e "${GREEN}✓ Removed $removed invalid entries from cache${NC}"
                                ;;
                            0|"")
                                echo ""
                                echo -e "${DIM}Skipping sync actions${NC}"
                                ;;
                            *)
                                echo ""
                                echo -e "${RED}Invalid choice${NC}"
                                ;;
                        esac
                    fi
                    
                    echo ""
                    echo -e "${DIM}Press any key to continue...${NC}"
                    read -rsn1
                    tput civis 2>/dev/null
                    ;;
                3) # Sync Episode Cache with Destination
                    tput cnorm 2>/dev/null
                    echo ""
                    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                    echo -e "${CYAN}Sync Episode Cache with Destination${NC}"
                    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                    echo ""
                    echo -e "${DIM}This will scan your destination TV show folders and extract episode${NC}"
                    echo -e "${DIM}information from renamed files to populate the episode cache.${NC}"
                    echo ""
                    echo -e "${YELLOW}Enter destination TV shows folder path:${NC}"
                    echo -e "${DIM}(You can drag & drop a folder or paste the path)${NC}"
                    echo ""
                    stty echo 2>/dev/null
                    read -e -p "> " episode_sync_dest
                    stty -echo 2>/dev/null
                    
                    # Remove quotes and trim whitespace
                    episode_sync_dest=$(echo "$episode_sync_dest" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e "s/^'//" -e "s/'$//" -e 's/^"//' -e 's/"$//')
                    
                    if [[ -z "$episode_sync_dest" ]]; then
                        echo ""
                        print_info "Cancelled - no path provided"
                        echo ""
                        echo -e "${DIM}Press any key to continue...${NC}"
                        read -rsn1
                        tput civis 2>/dev/null
                        continue
                    fi
                    
                    if [[ ! -d "$episode_sync_dest" ]]; then
                        echo ""
                        print_error "Directory not found: $episode_sync_dest"
                        echo ""
                        echo -e "${DIM}Press any key to continue...${NC}"
                        read -rsn1
                        tput civis 2>/dev/null
                        continue
                    fi
                    
                    # Select category
                    echo ""
                    echo -e "${YELLOW}Select episode cache category:${NC}"
                    echo ""
                    echo -e "  ${GREEN}1${NC} - TV Shows"
                    echo -e "  ${GREEN}2${NC} - Anime"
                    echo -e "  ${GREEN}3${NC} - Cartoons"
                    echo ""
                    read -p "Enter choice (1-3): " ep_cache_choice
                    
                    local ep_cache_dir=""
                    local ep_cache_name=""
                    
                    case "$ep_cache_choice" in
                        1)
                            ep_cache_dir="$TV_EPISODE_CACHE_DIR"
                            ep_cache_name="TV Shows"
                            ;;
                        2)
                            ep_cache_dir="$ANIME_EPISODE_CACHE_DIR"
                            ep_cache_name="Anime"
                            ;;
                        3)
                            ep_cache_dir="$CARTOON_EPISODE_CACHE_DIR"
                            ep_cache_name="Cartoons"
                            ;;
                        *)
                            echo ""
                            print_info "Invalid choice"
                            echo ""
                            echo -e "${DIM}Press any key to continue...${NC}"
                            read -rsn1
                            tput civis 2>/dev/null
                            continue
                            ;;
                    esac
                    
                    echo ""
                    echo -e "${CYAN}Scanning $ep_cache_name folders in destination...${NC}"
                    echo -e "${DIM}Destination: $episode_sync_dest${NC}"
                    echo ""
                    
                    local total_series=0
                    local total_episodes_added=0
                    local total_episodes_skipped=0
                    
                    # Find all series folders (folders with year and IMDb ID)
                    while IFS= read -r -d '' series_folder; do
                        local series_name=$(basename "$series_folder")
                        
                        # Extract IMDb, TMDb, and TVDb IDs from folder name
                        local series_imdb=""
                        local series_tmdb=""
                        local series_tvdb=""
                        
                        if [[ "$series_name" =~ \{imdb-(tt[0-9]+)\} ]]; then
                            series_imdb="${BASH_REMATCH[1]}"
                        elif [[ "$series_name" =~ \[imdb-(tt[0-9]+)\] ]]; then
                            series_imdb="${BASH_REMATCH[1]}"
                        elif [[ "$series_name" =~ \[imdbid-(tt[0-9]+)\] ]]; then
                            series_imdb="${BASH_REMATCH[1]}"
                        fi
                        
                        if [[ "$series_name" =~ \{tmdb-([0-9]+)\} ]]; then
                            series_tmdb="${BASH_REMATCH[1]}"
                        elif [[ "$series_name" =~ \[tmdb-([0-9]+)\] ]]; then
                            series_tmdb="${BASH_REMATCH[1]}"
                        elif [[ "$series_name" =~ \[tmdbid-([0-9]+)\] ]]; then
                            series_tmdb="${BASH_REMATCH[1]}"
                        fi
                        
                        if [[ "$series_name" =~ \{tvdb-([0-9]+)\} ]]; then
                            series_tvdb="${BASH_REMATCH[1]}"
                        elif [[ "$series_name" =~ \[tvdb-([0-9]+)\] ]]; then
                            series_tvdb="${BASH_REMATCH[1]}"
                        elif [[ "$series_name" =~ \[tvdbid-([0-9]+)\] ]]; then
                            series_tvdb="${BASH_REMATCH[1]}"
                        fi
                        
                        # Skip if no IMDb ID found
                        [[ -z "$series_imdb" ]] && continue
                        
                        # Extract clean series title (remove year and IDs)
                        local clean_series=$(echo "$series_name" | sed -E 's/[[:space:]]*\([0-9]{4}\).*//' | sed -E 's/[[:space:]]*[\[{](imdb|tmdb|tvdb)[^]}]*[\]}].*//')
                        
                        # Get episode cache file for this series
                        local ep_cache_file="${ep_cache_dir}/$(echo "$clean_series" | sed 's/[^a-zA-Z0-9 ]//g' | tr ' ' '_')_${series_imdb}.txt"
                        
                        ((total_series++))
                        local series_episodes_added=0
                        
                        # Scan for episode files in season folders
                        while IFS= read -r -d '' episode_file; do
                            local ep_filename=$(basename "$episode_file")
                            
                            # Parse S##E## from filename
                            local season="" episode=""
                            if [[ "$ep_filename" =~ [Ss]([0-9]{2})[Ee]([0-9]{2}) ]]; then
                                season="${BASH_REMATCH[1]}"
                                episode="${BASH_REMATCH[2]}"
                            elif [[ "$ep_filename" =~ ([0-9]{1,2})x([0-9]{2}) ]]; then
                                season=$(printf "%02d" "${BASH_REMATCH[1]}")
                                episode="${BASH_REMATCH[2]}"
                            else
                                continue
                            fi
                            
                            # Remove leading zeros for cache lookup
                            season=$((10#$season))
                            episode=$((10#$episode))
                            
                            # Check if episode already in cache
                            if [[ -f "$ep_cache_file" ]] && grep -q "^${season}|${episode}|" "$ep_cache_file" 2>/dev/null; then
                                ((total_episodes_skipped++))
                                continue
                            fi
                            
                            # Extract episode title from filename (between E## and quality markers)
                            local ep_title=""
                            if [[ "$ep_filename" =~ [Ee][0-9]{2}[[:space:]]*-?[[:space:]]*([^[{\(]+) ]]; then
                                ep_title="${BASH_REMATCH[1]}"
                                # Clean up title
                                ep_title=$(echo "$ep_title" | sed -E 's/[._]/ /g' | sed 's/  */ /g' | sed 's/^ //;s/ $//')
                            fi
                            
                            # Skip if no title found
                            [[ -z "$ep_title" ]] && continue
                            
                            # Save to cache
                            save_episode_to_cache "$ep_cache_file" "$season" "$episode" "$ep_title" "" "$series_imdb" "$series_tmdb" "$series_tvdb"
                            ((total_episodes_added++))
                            ((series_episodes_added++))
                            
                        done < <(find "$series_folder" -type f \( -name "*.mkv" -o -name "*.mp4" -o -name "*.avi" \) -print0 2>/dev/null)
                        
                        if [[ $series_episodes_added -gt 0 ]]; then
                            echo -e "${GREEN}✓${NC} ${clean_series}: ${series_episodes_added} episodes added"
                        fi
                        
                    done < <(find "$episode_sync_dest" -mindepth 1 -maxdepth 1 -type d -print0 2>/dev/null)
                    
                    echo ""
                    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                    echo -e "${CYAN}Episode Cache Sync Complete${NC}"
                    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                    echo ""
                    echo -e "  ${GREEN}Series scanned:${NC} $total_series"
                    echo -e "  ${GREEN}Episodes added to cache:${NC} $total_episodes_added"
                    echo -e "  ${YELLOW}Episodes already cached:${NC} $total_episodes_skipped"
                    echo ""
                    echo -e "${DIM}Press any key to continue...${NC}"
                    read -rsn1
                    tput civis 2>/dev/null
                    ;;
                4) # Clear unified
                    if [[ -f "$CACHE_DIR/MOVIE UNIFIED CACHE.txt" ]]; then
                        > "$CACHE_DIR/MOVIE UNIFIED CACHE.txt"
                        echo ""
                        print_success "Unified cache cleared"
                    else
                        touch "$CACHE_DIR/MOVIE UNIFIED CACHE.txt"
                        echo ""
                        print_info "Unified cache is already empty"
                    fi
                    echo ""
                    echo -e "${DIM}Press any key to continue...${NC}"
                    read -rsn1
                    ;;
                5) # Clear 4K
                    if [[ -f "$CACHE_DIR/MOVIE 4K CACHE.txt" ]]; then
                        > "$CACHE_DIR/MOVIE 4K CACHE.txt"
                        echo ""
                        print_success "4K cache cleared"
                    else
                        touch "$CACHE_DIR/MOVIE 4K CACHE.txt"
                        echo ""
                        print_info "4K cache is already empty"
                    fi
                    echo ""
                    echo -e "${DIM}Press any key to continue...${NC}"
                    read -rsn1
                    ;;
                6) # Clear 1080p
                    if [[ -f "$CACHE_DIR/MOVIE 1080p CACHE.txt" ]]; then
                        > "$CACHE_DIR/MOVIE 1080p CACHE.txt"
                        echo ""
                        print_success "1080p cache cleared"
                    else
                        touch "$CACHE_DIR/MOVIE 1080p CACHE.txt"
                        echo ""
                        print_info "1080p cache is already empty"
                    fi
                    echo ""
                    echo -e "${DIM}Press any key to continue...${NC}"
                    read -rsn1
                    ;;
                7) # Clear 1080p Softcore
                    if [[ -f "$CACHE_DIR/MOVIE 1080p SOFTCORE CACHE.txt" ]]; then
                        > "$CACHE_DIR/MOVIE 1080p SOFTCORE CACHE.txt"
                        echo ""
                        print_success "1080p Softcore cache cleared"
                    else
                        touch "$CACHE_DIR/MOVIE 1080p SOFTCORE CACHE.txt"
                        echo ""
                        print_info "1080p Softcore cache is already empty"
                    fi
                    echo ""
                    echo -e "${DIM}Press any key to continue...${NC}"
                    read -rsn1
                    ;;
                8) # Clear 4K Softcore
                    if [[ -f "$CACHE_DIR/MOVIE 4K SOFTCORE CACHE.txt" ]]; then
                        > "$CACHE_DIR/MOVIE 4K SOFTCORE CACHE.txt"
                        echo ""
                        print_success "4K Softcore cache cleared"
                    else
                        touch "$CACHE_DIR/MOVIE 4K SOFTCORE CACHE.txt"
                        echo ""
                        print_info "4K Softcore cache is already empty"
                    fi
                    echo ""
                    echo -e "${DIM}Press any key to continue...${NC}"
                    read -rsn1
                    ;;
                9) # Clear Cartoons
                    if [[ -f "$CARTOON_CACHE_FILE" ]]; then
                        > "$CARTOON_CACHE_FILE"
                        echo ""
                        print_success "Cartoon cache cleared"
                    else
                        touch "$CARTOON_CACHE_FILE"
                        echo ""
                        print_info "Cartoon cache is already empty"
                    fi
                    echo ""
                    echo -e "${DIM}Press any key to continue...${NC}"
                    read -rsn1
                    ;;
                10) # Clear Anime Movies
                    if [[ -f "$ANIME_MOVIE_CACHE_FILE" ]]; then
                        > "$ANIME_MOVIE_CACHE_FILE"
                        echo ""
                        print_success "Anime movie cache cleared"
                    else
                        touch "$ANIME_MOVIE_CACHE_FILE"
                        echo ""
                        print_info "Anime movie cache is already empty"
                    fi
                    echo ""
                    echo -e "${DIM}Press any key to continue...${NC}"
                    read -rsn1
                    ;;
                11) # Clear TV Shows
                    if [[ -f "$TV_CACHE_FILE" ]]; then
                        > "$TV_CACHE_FILE"
                        echo ""
                        print_success "TV show cache cleared"
                    else
                        touch "$TV_CACHE_FILE"
                        echo ""
                        print_info "TV show cache is already empty"
                    fi
                    echo ""
                    echo -e "${DIM}Press any key to continue...${NC}"
                    read -rsn1
                    ;;
                12) # Clear Anime TV Shows
                    if [[ -f "$ANIME_CACHE_FILE" ]]; then
                        > "$ANIME_CACHE_FILE"
                        echo ""
                        print_success "Anime TV show cache cleared"
                    else
                        touch "$ANIME_CACHE_FILE"
                        echo ""
                        print_info "Anime TV show cache is already empty"
                    fi
                    echo ""
                    echo -e "${DIM}Press any key to continue...${NC}"
                    read -rsn1
                    ;;
                13) # Clear Cartoon TV Shows
                    if [[ -f "$CARTOON_TV_CACHE_FILE" ]]; then
                        > "$CARTOON_TV_CACHE_FILE"
                        echo ""
                        print_success "Cartoon TV show cache cleared"
                    else
                        touch "$CARTOON_TV_CACHE_FILE"
                        echo ""
                        print_info "Cartoon TV show cache is already empty"
                    fi
                    echo ""
                    echo -e "${DIM}Press any key to continue...${NC}"
                    read -rsn1
                    ;;
                14) # Clear TV Episodes Cache
                    if [[ -d "$TV_EPISODE_CACHE_DIR" ]]; then
                        local file_count=$(find "$TV_EPISODE_CACHE_DIR" -type f -name "*.txt" 2>/dev/null | wc -l | tr -d ' ')
                        if [[ $file_count -gt 0 ]]; then
                            rm -f "$TV_EPISODE_CACHE_DIR"/*.txt 2>/dev/null
                            echo ""
                            print_success "TV episodes cache cleared ($file_count series)"
                        else
                            echo ""
                            print_info "TV episodes cache is already empty"
                        fi
                    else
                        echo ""
                        print_info "TV episodes cache directory not found"
                    fi
                    echo ""
                    echo -e "${DIM}Press any key to continue...${NC}"
                    read -rsn1
                    ;;
                15) # Clear Anime Episodes Cache
                    if [[ -d "$ANIME_EPISODE_CACHE_DIR" ]]; then
                        local file_count=$(find "$ANIME_EPISODE_CACHE_DIR" -type f -name "*.txt" 2>/dev/null | wc -l | tr -d ' ')
                        if [[ $file_count -gt 0 ]]; then
                            rm -f "$ANIME_EPISODE_CACHE_DIR"/*.txt 2>/dev/null
                            echo ""
                            print_success "Anime episodes cache cleared ($file_count series)"
                        else
                            echo ""
                            print_info "Anime episodes cache is already empty"
                        fi
                    else
                        echo ""
                        print_info "Anime episodes cache directory not found"
                    fi
                    echo ""
                    echo -e "${DIM}Press any key to continue...${NC}"
                    read -rsn1
                    ;;
                16) # Clear Cartoon Episodes Cache
                    if [[ -d "$CARTOON_EPISODE_CACHE_DIR" ]]; then
                        local file_count=$(find "$CARTOON_EPISODE_CACHE_DIR" -type f -name "*.txt" 2>/dev/null | wc -l | tr -d ' ')
                        if [[ $file_count -gt 0 ]]; then
                            rm -f "$CARTOON_EPISODE_CACHE_DIR"/*.txt 2>/dev/null
                            echo ""
                            print_success "Cartoon episodes cache cleared ($file_count series)"
                        else
                            echo ""
                            print_info "Cartoon episodes cache is already empty"
                        fi
                    else
                        echo ""
                        print_info "Cartoon episodes cache directory not found"
                    fi
                    echo ""
                    echo -e "${DIM}Press any key to continue...${NC}"
                    read -rsn1
                    ;;
                17) # Clear ALL
                    tput cnorm 2>/dev/null
                    echo ""
                    echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                    echo -e "${RED}⚠  WARNING: CLEAR ALL CACHES${NC}"
                    echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                    echo ""
                    echo -e "${YELLOW}This will delete ALL cache files:${NC}"
                    echo -e "  • MOVIE UNIFIED CACHE.txt"
                    echo -e "  • MOVIE 4K CACHE.txt"
                    echo -e "  • MOVIE 1080p CACHE.txt"
                    echo -e "  • MOVIE 1080p SOFTCORE CACHE.txt"
                    echo -e "  • MOVIE 4K SOFTCORE CACHE.txt"
                    echo -e "  • MOVIE CARTOONS CACHE.txt"
                    echo -e "  • MOVIE ANIME CACHE.txt"
                    echo -e "  • SHOWS TV CACHE.txt"
                    echo -e "  • SHOWS ANIME CACHE.txt"
                    echo -e "  • SHOWS CARTOONS CACHE.txt"
                    echo -e "  • TV Episodes Cache (all series)"
                    echo -e "  • Anime Episodes Cache (all series)"
                    echo -e "  • Cartoon Episodes Cache (all series)"
                    echo ""
                    echo -e "${RED}All cached movie and TV show metadata will be lost!${NC}"
                    echo ""
                    read -p "Type 'yes' to confirm: " confirm
                    if [[ "$confirm" == "yes" ]]; then
                        # Create/clear all cache files
                        : > "$CACHE_DIR/MOVIE UNIFIED CACHE.txt"
                        : > "$CACHE_DIR/MOVIE 4K CACHE.txt"
                        : > "$CACHE_DIR/MOVIE 1080p CACHE.txt"
                        : > "$CACHE_DIR/MOVIE 1080p SOFTCORE CACHE.txt"
                        : > "$CACHE_DIR/MOVIE 4K SOFTCORE CACHE.txt"
                        : > "$CARTOON_CACHE_FILE"
                        : > "$ANIME_MOVIE_CACHE_FILE"
                        : > "$TV_CACHE_FILE"
                        : > "$ANIME_CACHE_FILE"
                        : > "$CARTOON_TV_CACHE_FILE"
                        # Clear episode caches
                        [[ -d "$TV_EPISODE_CACHE_DIR" ]] && rm -f "$TV_EPISODE_CACHE_DIR"/*.txt 2>/dev/null
                        [[ -d "$ANIME_EPISODE_CACHE_DIR" ]] && rm -f "$ANIME_EPISODE_CACHE_DIR"/*.txt 2>/dev/null
                        [[ -d "$CARTOON_EPISODE_CACHE_DIR" ]] && rm -f "$CARTOON_EPISODE_CACHE_DIR"/*.txt 2>/dev/null
                        echo ""
                        print_success "All caches cleared successfully (including episode caches)"
                    else
                        echo ""
                        print_info "Cancelled - no caches were cleared"
                    fi
                    echo ""
                    echo -e "${DIM}Press any key to continue...${NC}"
                    read -rsn1
                    tput civis 2>/dev/null
                    ;;
                18) # Clear Movie JSON Databases
                    tput cnorm 2>/dev/null
                    echo ""
                    echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                    echo -e "${RED}⚠  WARNING: CLEAR MOVIE JSON DATABASES${NC}"
                    echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                    echo ""
                    echo -e "${YELLOW}This will delete all MOVIE JSON database files:${NC}"
                    echo -e "  • movie_json.db"
                    echo -e "  • movie_4k_json.db"
                    echo -e "  • movie_1080p_json.db"
                    echo -e "  • movie_1080p_softcore_json.db"
                    echo -e "  • movie_4k_softcore_json.db"
                    echo -e "  • movie_cartoons_json.db"
                    echo -e "  • movie_anime_json.db"
                    echo ""
                    echo -e "${RED}All cached movie TMDb API responses will be lost!${NC}"
                    echo -e "${YELLOW}Note: TV show JSON databases and text caches will NOT be affected${NC}"
                    echo ""
                    read -p "Type 'yes' to confirm: " confirm
                    if [[ "$confirm" == "yes" ]]; then
                        rm -f "$JSON_DB_DIR"/movie*.db 2>/dev/null
                        echo ""
                        print_success "All movie JSON databases cleared successfully"
                    else
                        echo ""
                        print_info "Cancelled - no movie JSON databases were cleared"
                    fi
                    echo ""
                    echo -e "${DIM}Press any key to continue...${NC}"
                    read -rsn1
                    tput civis 2>/dev/null
                    ;;
                19) # Clear TV Show JSON Databases
                    tput cnorm 2>/dev/null
                    echo ""
                    echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                    echo -e "${RED}⚠  WARNING: CLEAR TV SHOW JSON DATABASES${NC}"
                    echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                    echo ""
                    echo -e "${YELLOW}This will delete all TV SHOW JSON database files:${NC}"
                    echo -e "  • tvshow_json.db"
                    echo -e "  • tvshow_anime_json.db"
                    echo -e "  • tvshow_cartoons_json.db"
                    echo ""
                    echo -e "${RED}All cached TV show TMDb API responses will be lost!${NC}"
                    echo -e "${YELLOW}Note: Movie JSON databases and text caches will NOT be affected${NC}"
                    echo ""
                    read -p "Type 'yes' to confirm: " confirm
                    if [[ "$confirm" == "yes" ]]; then
                        rm -f "$TV_JSON_DB_FILE" "$ANIME_TV_JSON_DB_FILE" "$CARTOON_TV_JSON_DB_FILE" 2>/dev/null
                        echo ""
                        print_success "All TV show JSON databases cleared successfully"
                    else
                        echo ""
                        print_info "Cancelled - no TV show JSON databases were cleared"
                    fi
                    echo ""
                    echo -e "${DIM}Press any key to continue...${NC}"
                    read -rsn1
                    tput civis 2>/dev/null
                    ;;
                20) # Clear ALL JSON Databases
                    tput cnorm 2>/dev/null
                    echo ""
                    echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                    echo -e "${RED}⚠  WARNING: CLEAR ALL JSON DATABASES${NC}"
                    echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                    echo ""
                    echo -e "${YELLOW}This will delete ALL JSON database files (movies AND TV shows):${NC}"
                    echo -e "${CYAN}Movies:${NC}"
                    echo -e "  • movie_json.db"
                    echo -e "  • movie_4k_json.db"
                    echo -e "  • movie_1080p_json.db"
                    echo -e "  • movie_1080p_softcore_json.db"
                    echo -e "  • movie_4k_softcore_json.db"
                    echo -e "  • movie_cartoons_json.db"
                    echo -e "  • movie_anime_json.db"
                    echo -e "${CYAN}TV Shows:${NC}"
                    echo -e "  • tvshow_json.db"
                    echo -e "  • tvshow_anime_json.db"
                    echo -e "  • tvshow_cartoons_json.db"
                    echo ""
                    echo -e "${RED}All cached TMDb API responses will be lost!${NC}"
                    echo -e "${YELLOW}Note: Text caches will NOT be affected${NC}"
                    echo ""
                    read -p "Type 'yes' to confirm: " confirm
                    if [[ "$confirm" == "yes" ]]; then
                        rm -f "$JSON_DB_DIR"/*.db "$TV_JSON_DB_FILE" "$ANIME_TV_JSON_DB_FILE" "$CARTOON_TV_JSON_DB_FILE" 2>/dev/null
                        echo ""
                        print_success "All JSON databases cleared successfully"
                    else
                        echo ""
                        print_info "Cancelled - no JSON databases were cleared"
                    fi
                    echo ""
                    echo -e "${DIM}Press any key to continue...${NC}"
                    read -rsn1
                    tput civis 2>/dev/null
                    ;;
                21) # Clear ALL Caches + JSON Databases
                    tput cnorm 2>/dev/null
                    echo ""
                    echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                    echo -e "${RED}⚠  WARNING: CLEAR ALL CACHES + JSON DATABASES${NC}"
                    echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                    echo ""
                    echo -e "${YELLOW}This will delete:${NC}"
                    echo -e "${CYAN}Text Caches:${NC}"
                    echo -e "  • MOVIE UNIFIED CACHE.txt"
                    echo -e "  • MOVIE 4K CACHE.txt"
                    echo -e "  • MOVIE 1080p CACHE.txt"
                    echo -e "  • MOVIE 1080p SOFTCORE CACHE.txt"
                    echo -e "  • MOVIE 4K SOFTCORE CACHE.txt"
                    echo -e "  • MOVIE CARTOONS CACHE.txt"
                    echo -e "  • MOVIE ANIME CACHE.txt"
                    echo -e "  • SHOWS TV CACHE.txt"
                    echo -e "  • SHOWS ANIME CACHE.txt"
                    echo -e "  • SHOWS CARTOONS CACHE.txt"
                    echo -e "  • TV Episodes Cache (all series)"
                    echo -e "  • Anime Episodes Cache (all series)"
                    echo -e "  • Cartoon Episodes Cache (all series)"
                    echo ""
                    echo -e "${CYAN}JSON Databases (Movies):${NC}"
                    echo -e "  • movie_json.db"
                    echo -e "  • movie_4k_json.db"
                    echo -e "  • movie_1080p_json.db"
                    echo -e "  • movie_1080p_softcore_json.db"
                    echo -e "  • movie_4k_softcore_json.db"
                    echo -e "  • movie_cartoons_json.db"
                    echo -e "  • movie_anime_json.db"
                    echo -e "${CYAN}JSON Databases (TV Shows):${NC}"
                    echo -e "  • tvshow_json.db"
                    echo -e "  • tvshow_anime_json.db"
                    echo -e "  • tvshow_cartoons_json.db"
                    echo ""
                    echo -e "${RED}All cached data will be completely wiped!${NC}"
                    echo ""
                    read -p "Type 'yes' to confirm: " confirm
                    if [[ "$confirm" == "yes" ]]; then
                        # Clear all cache files (keep files, empty content)
                        : > "$CACHE_DIR/MOVIE UNIFIED CACHE.txt"
                        : > "$CACHE_DIR/MOVIE 4K CACHE.txt"
                        : > "$CACHE_DIR/MOVIE 1080p CACHE.txt"
                        : > "$CACHE_DIR/MOVIE 1080p SOFTCORE CACHE.txt"
                        : > "$CACHE_DIR/MOVIE 4K SOFTCORE CACHE.txt"
                        : > "$CARTOON_CACHE_FILE"
                        : > "$ANIME_MOVIE_CACHE_FILE"
                        : > "$TV_CACHE_FILE"
                        : > "$ANIME_CACHE_FILE"
                        : > "$CARTOON_TV_CACHE_FILE"
                        # Clear episode caches
                        [[ -d "$TV_EPISODE_CACHE_DIR" ]] && rm -f "$TV_EPISODE_CACHE_DIR"/*.txt 2>/dev/null
                        [[ -d "$ANIME_EPISODE_CACHE_DIR" ]] && rm -f "$ANIME_EPISODE_CACHE_DIR"/*.txt 2>/dev/null
                        [[ -d "$CARTOON_EPISODE_CACHE_DIR" ]] && rm -f "$CARTOON_EPISODE_CACHE_DIR"/*.txt 2>/dev/null
                        # Delete all JSON databases
                        rm -f "$JSON_DB_DIR"/*.db "$TV_JSON_DB_FILE" "$ANIME_TV_JSON_DB_FILE" "$CARTOON_TV_JSON_DB_FILE" 2>/dev/null
                        echo ""
                        print_success "All caches and JSON databases cleared successfully (including episode caches)"
                    else
                        echo ""
                        print_info "Cancelled - nothing was cleared"
                    fi
                    echo ""
                    echo -e "${DIM}Press any key to continue...${NC}"
                    read -rsn1
                    tput civis 2>/dev/null
                    ;;
            esac
        fi
    done
}

# Naming scheme selection with checkbox interface
select_naming_scheme() {
    local start_step="${1:-1}"  # Optional parameter: which step to start at (default: 1)
    local scheme_file="${CACHE_DIR}/naming_scheme.txt"
    
    # Folder format options (Based on TRaSH-Guides.info)
    local -a folder_opts=(
        "0|No Renaming"
        "1|Standard - TRaSH Guides"
        "2|Jellyfin (IMDb) - TRaSH Guides"
        "3|Jellyfin (TMDb) - TRaSH Guides"
        "4|Plex (IMDb) - TRaSH Guides"
        "5|Plex (TMDb) - TRaSH Guides"
        "6|Emby (IMDb) - TRaSH Guides"
        "7|Emby (TMDb) - TRaSH Guides"
    )
    
    # File format options (Based on TRaSH-Guides.info)
    local -a file_opts=(
        "0|No Renaming"
        "8|Standard - TRaSH Guides"
        "9|Jellyfin (IMDb) - TRaSH Guides"
        "10|Jellyfin (TMDb) - TRaSH Guides"
        "11|Jellyfin Anime (IMDb) - TRaSH Guides"
        "12|Jellyfin Anime (TMDb) - TRaSH Guides"
        "13|Plex (IMDb) - TRaSH Guides"
        "14|Plex (TMDb) - TRaSH Guides"
        "15|Plex Anime (IMDb) - TRaSH Guides"
        "16|Plex Anime (TMDb) - TRaSH Guides"
        "17|Emby (IMDb) - TRaSH Guides"
        "18|Emby (TMDb) - TRaSH Guides"
        "19|Emby Anime (IMDb) - TRaSH Guides"
        "20|Emby Anime (TMDb) - TRaSH Guides"
    )
    
    # Poster display options
    local -a poster_opts=(
        "yes|Display posters in terminal (requires chafa/imgcat)"
        "no|Skip poster display (faster processing)"
    )
    
    # Cache options
    local cache_files=(
        "unified|MOVIE UNIFIED CACHE.txt|Single cache for all resolutions"
        "4k|MOVIE 4K CACHE.txt|4K/UHD cache only"
        "1080p|MOVIE 1080p CACHE.txt|1080p and below cache only"
        "1080p_softcore|MOVIE 1080p SOFTCORE CACHE.txt|1080p Softcore content only"
        "4k_softcore|MOVIE 4K SOFTCORE CACHE.txt|4K Softcore content only"
        "cartoons|MOVIE CARTOONS CACHE.txt|Cartoon/Animated movies"
        "anime|MOVIE ANIME CACHE.txt|Anime movies"
    )
    
    # Load saved preferences
    local saved_folder="1"  # Default to Standard (TRaSH)
    local saved_file="8"    # Default to Standard (TRaSH)
    if [[ -f "$scheme_file" ]]; then
        saved_folder=$(sed -n '1p' "$scheme_file")
        saved_file=$(sed -n '2p' "$scheme_file")
    fi
    
    local saved_poster="yes"
    if [[ -f "$POSTER_PREFS" ]]; then
        saved_poster=$(cat "$POSTER_PREFS")
    fi
    
    local cache_mode_file="$CACHE_DIR/cache_mode.txt"
    local saved_cache_mode="4k"
    if [[ -f "$cache_mode_file" ]]; then
        saved_cache_mode=$(cat "$cache_mode_file")
    fi
    
    # Step-based navigation: 1=folder, 2=file, 3=poster, 4=cache
    local current_step="$start_step"  # Use provided start step
    local folder_choice="$saved_folder"
    local file_choice="$saved_file"
    local poster_choice="$saved_poster"
    local cache_choice="$saved_cache_mode"
    
    while true; do
        case $current_step in
            1)  # Folder format
                if arrow_select_menu "FOLDER FORMAT SELECTION" "$folder_choice" "folder_choice" "${folder_opts[@]}"; then
                    current_step=2
                else
                    return 1  # Back from first step = exit
                fi
                ;;
                
            2)  # File format
                if arrow_select_menu "FILE FORMAT SELECTION" "$file_choice" "file_choice" "${file_opts[@]}"; then
                    current_step=3
                else
                    current_step=1  # Back to folder
                fi
                ;;
                
            3)  # Poster display
                if arrow_select_menu "MOVIE POSTER DISPLAY" "$poster_choice" "poster_choice" "${poster_opts[@]}"; then
                    echo "$poster_choice" > "$POSTER_PREFS"
                    SHOW_MOVIE_POSTERS="$poster_choice"
                    current_step=4
                else
                    current_step=2  # Back to file format
                fi
                ;;
                
            4)  # Cache selection
                # Build cache options with entry counts
                local -a cache_opts=()
                for cache_info in "${cache_files[@]}"; do
                    IFS='|' read -r cache_key cache_filename cache_desc <<< "$cache_info"
                    local cache_path="$CACHE_DIR/$cache_filename"
                    local entry_count=0
                    if [[ -f "$cache_path" ]]; then
                        entry_count=$(awk 'NF' "$cache_path" 2>/dev/null | wc -l | tr -d ' ')
                    fi
                    cache_opts+=("${cache_key}|${cache_desc} (${cache_filename}) - ${entry_count} entries")
                done
                cache_opts+=("manage|📋 Manage Movie Caches (Clear/Reset)")
                
                if arrow_select_menu "MOVIE CACHE SELECTION" "$cache_choice" "cache_choice" "${cache_opts[@]}"; then
                    if [[ "$cache_choice" == "manage" ]]; then
                        manage_movie_caches
                        continue  # Stay on cache step
                    fi
                    echo "$cache_choice" > "$cache_mode_file"
                    CACHE_MODE="$cache_choice"
                    SESSION_CACHE_MODE="$cache_choice"
                    break  # All steps complete
                else
                    current_step=3  # Back to poster
                fi
                ;;
        esac
    done
    
    # Save folder and file preferences
    echo "$folder_choice" > "$scheme_file"
    echo "$file_choice" >> "$scheme_file"
    
    clear
    echo ""
    print_success "MOVIE settings saved:"
    echo "  • Folder format: $folder_choice"
    echo "  • File format: $file_choice"
    echo "  • Poster display: $poster_choice"
    echo "  • Cache mode: $cache_choice"
    echo ""
    
    NAMING_FOLDER="$folder_choice"
    NAMING_FILE="$file_choice"
    return 0
}

# Detect and filter duplicates (keep largest file)
detect_duplicates() {
    local -a files=("$@")
    local -a filtered_files=()
    local duplicate_count=0
    local temp_file="/tmp/movie_duplicates_$$"
    
    # Create temp file for storing movie data
    > "$temp_file"
    
    # Parse all files and group by title+year
    for file in "${files[@]}"; do
        # Check cache first, then parse if needed
        local cached_data=$(lookup_parse_cache "$file")
        if [[ -n "$cached_data" ]]; then
            PARSED_TITLE="${cached_data%%|*}"
            PARSED_YEAR="${cached_data#*|}"
        else
            parse_filename "$file"
        fi
        if [[ -n "$PARSED_TITLE" && -n "$PARSED_YEAR" ]]; then
            local key="${PARSED_TITLE}|${PARSED_YEAR}"
            local size=$(stat -f "%z" "$file" 2>/dev/null || stat -c "%s" "$file" 2>/dev/null)
            
            # Store in temp file: key|file|size
            echo "${key}|${file}|${size}" >> "$temp_file"
        else
            # Can't parse title/year, keep it
            filtered_files+=("$file")
        fi
    done
    
    # Process temp file to find largest of each group
    if [[ -s "$temp_file" ]]; then
        local -a kept_files=()
        
        # Sort by key and size (descending)
        while IFS='|' read -r key file size; do
            local found=0
            
            # Check if we already have this key
            for i in "${!kept_files[@]}"; do
                local kept_data="${kept_files[$i]}"
                local kept_key="${kept_data%%|*}"
                
                if [[ "$kept_key" == "$key" ]]; then
                    found=1
                    local kept_rest="${kept_data#*|}"
                    local kept_size="${kept_rest##*|}"
                    
                    if [[ $size -gt $kept_size ]]; then
                        # New file is larger, replace
                        kept_files[$i]="${key}|${file}|${size}"
                    fi
                    break
                fi
            done
            
            if [[ $found -eq 0 ]]; then
                # First occurrence of this key
                kept_files+=("${key}|${file}|${size}")
            fi
        done < "$temp_file"
        
        # Count duplicates and build filtered list
        local reported=""
        for file in "${files[@]}"; do
            # Check cache first, then parse if needed
            local cached_data=$(lookup_parse_cache "$file")
            if [[ -n "$cached_data" ]]; then
                PARSED_TITLE="${cached_data%%|*}"
                PARSED_YEAR="${cached_data#*|}"
            else
                parse_filename "$file"
            fi
            if [[ -n "$PARSED_TITLE" && -n "$PARSED_YEAR" ]]; then
                local key="${PARSED_TITLE}|${PARSED_YEAR}"
                local is_kept=0
                
                # Check if this file is the kept version
                for kept_data in "${kept_files[@]}"; do
                    local kept_key="${kept_data%%|*}"
                    local kept_rest="${kept_data#*|}"
                    local kept_file="${kept_rest%%|*}"
                    
                    if [[ "$kept_key" == "$key" && "$kept_file" == "$file" ]]; then
                        is_kept=1
                        break
                    fi
                done
                
                if [[ $is_kept -eq 1 ]]; then
                    filtered_files+=("$file")
                else
                    ((duplicate_count++))
                fi
            fi
        done
        
        # Print duplicate info if any found
        if [[ $duplicate_count -gt 0 ]]; then
            echo "" >&2
            print_warning "=========================================" >&2
            print_warning "Duplicate Detection Results" >&2
            print_warning "=========================================" >&2
            
            # Show which duplicates were found
            for kept_data in "${kept_files[@]}"; do
                local key="${kept_data%%|*}"
                local rest="${kept_data#*|}"
                local kept_file="${rest%%|*}"
                local kept_size="${rest##*|}"
                
                # Count how many files have this key
                local count=0
                for file in "${files[@]}"; do
                    parse_filename "$file"
                    if [[ "${PARSED_TITLE}|${PARSED_YEAR}" == "$key" ]]; then
                        ((count++))
                    fi
                done
                
                if [[ $count -gt 1 ]]; then
                    local title="${key%%|*}"
                    local year="${key##*|}"
                    
                    echo "" >&2
                    print_info "Movie: ${title} (${year})" >&2
                    
                    # Format file size
                    local size_display
                    if command -v numfmt &>/dev/null; then
                        size_display=$(numfmt --to=iec-i --suffix=B "$kept_size" 2>/dev/null)
                    else
                        # Fallback for macOS without numfmt
                        if [[ $kept_size -gt 1073741824 ]]; then
                            size_display=$(awk "BEGIN {printf \"%.1f GiB\", $kept_size/1073741824}")
                        elif [[ $kept_size -gt 1048576 ]]; then
                            size_display=$(awk "BEGIN {printf \"%.1f MiB\", $kept_size/1048576}")
                        else
                            size_display="${kept_size} bytes"
                        fi
                    fi
                    
                    print_success "Keeping largest: $(basename "$kept_file") ($size_display)" >&2
                    
                    # Show skipped versions
                    for file in "${files[@]}"; do
                        parse_filename "$file"
                        if [[ "${PARSED_TITLE}|${PARSED_YEAR}" == "$key" && "$file" != "$kept_file" ]]; then
                            local check_size=$(stat -f "%z" "$file" 2>/dev/null || stat -c "%s" "$file" 2>/dev/null)
                            
                            local check_size_display
                            if command -v numfmt &>/dev/null; then
                                check_size_display=$(numfmt --to=iec-i --suffix=B "$check_size" 2>/dev/null)
                            else
                                if [[ $check_size -gt 1073741824 ]]; then
                                    check_size_display=$(awk "BEGIN {printf \"%.1f GiB\", $check_size/1073741824}")
                                elif [[ $check_size -gt 1048576 ]]; then
                                    check_size_display=$(awk "BEGIN {printf \"%.1f MiB\", $check_size/1048576}")
                                else
                                    check_size_display="${check_size} bytes"
                                fi
                            fi
                            
                            print_warning "Skipping smaller: $(basename "$file") ($check_size_display)" >&2
                        fi
                    done
                fi
            done
            
            echo "" >&2
            print_warning "Total duplicates found: $duplicate_count" >&2
            print_info "Kept largest version of each movie" >&2
            echo "" >&2
        fi
    fi
    
    # Cleanup
    rm -f "$temp_file"
    
    # Return filtered list
    printf '%s\n' "${filtered_files[@]}"
}

# Standalone function to select Movie cache interactively
select_movie_cache_interactive() {
    # Load saved mediainfo tool preference
    local mediainfo_pref_file="$CACHE_DIR/mediainfo_tool.txt"
    if [[ -f "$mediainfo_pref_file" ]]; then
        MEDIAINFO_TOOL=$(cat "$mediainfo_pref_file")
    fi
    
    local cache_files=(
        "unified|MOVIE UNIFIED CACHE.txt|Single cache for all resolutions"
        "4k|MOVIE 4K CACHE.txt|4K/UHD cache only"
        "1080p|MOVIE 1080p CACHE.txt|1080p and below cache only"
        "1080p_softcore|MOVIE 1080p SOFTCORE CACHE.txt|1080p Softcore content only"
        "4k_softcore|MOVIE 4K SOFTCORE CACHE.txt|4K Softcore content only"
        "cartoons|MOVIE CARTOONS CACHE.txt|Cartoon/Animated movies"
        "anime|MOVIE ANIME CACHE.txt|Anime movies"
    )
    
    local cache_mode_file="$CACHE_DIR/cache_mode.txt"
    local saved_cache_mode="1080p"
    if [[ -f "$cache_mode_file" ]]; then
        saved_cache_mode=$(cat "$cache_mode_file")
    fi
    
    local cache_choice
    while true; do
        # Build cache options with entry counts
        local -a cache_opts=()
        
        for cache_info in "${cache_files[@]}"; do
            IFS='|' read -r cache_key cache_filename cache_desc <<< "$cache_info"
            local cache_path="$CACHE_DIR/$cache_filename"
            local entry_count=0
            if [[ -f "$cache_path" ]]; then
                entry_count=$(awk 'NF' "$cache_path" 2>/dev/null | wc -l | tr -d ' ')
            fi
            cache_opts+=("${cache_key}|${cache_desc} (${cache_filename}) - ${entry_count} entries")
        done
        
        # Add cache management option
        cache_opts+=("manage|📋 Manage Movie Caches (Clear/Reset)")
        
        if arrow_select_menu "MOVIE CACHE SELECTION" "$saved_cache_mode" "cache_choice" "${cache_opts[@]}"; then
            if [[ "$cache_choice" == "manage" ]]; then
                # Show cache management menu
                manage_movie_caches
                continue
            fi
            echo "$cache_choice" > "$cache_mode_file"
            CACHE_MODE="$cache_choice"
            SESSION_CACHE_MODE="$cache_choice"
            
            # Step 2: MediaInfo Tool Selection
            local mediainfo_pref_file="$CACHE_DIR/mediainfo_tool.txt"
            local saved_mediainfo_tool="mediainfo"
            if [[ -f "$mediainfo_pref_file" ]]; then
                saved_mediainfo_tool=$(cat "$mediainfo_pref_file")
            fi
            
            local -a mediainfo_opts=(
                "mediainfo|mediainfo (recommended) - Extract codec/audio/resolution from video stream"
                "ffprobe|ffprobe - Extract codec/audio/resolution from video stream"
                "off|Disabled - Use filename/folder parsing only (no stream analysis)"
            )
            
            local mediainfo_choice
            if arrow_select_menu "METADATA EXTRACTION TOOL" "$saved_mediainfo_tool" "mediainfo_choice" "${mediainfo_opts[@]}"; then
                echo "$mediainfo_choice" > "$mediainfo_pref_file"
                MEDIAINFO_TOOL="$mediainfo_choice"
                return 0
            else
                # User pressed back to cache menu
                continue
            fi
        else
            # User pressed back
            return 1
        fi
    done
}

# Standalone function to select TV cache interactively
select_tv_cache_interactive() {
    # Load saved mediainfo tool preference
    local mediainfo_pref_file="$CACHE_DIR/mediainfo_tool.txt"
    if [[ -f "$mediainfo_pref_file" ]]; then
        MEDIAINFO_TOOL=$(cat "$mediainfo_pref_file")
    fi
    
    local tv_cache_files=(
        "tvshow|SHOWS TV CACHE.txt|Standard TV Shows"
        "anime|SHOWS ANIME CACHE.txt|Anime TV Shows"
        "cartoons|SHOWS CARTOONS CACHE.txt|Cartoon TV Shows"
    )
    
    local tv_cache_mode_file="$CACHE_DIR/tv_cache_mode.txt"
    local saved_tv_cache_mode="tvshow"
    if [[ -f "$tv_cache_mode_file" ]]; then
        saved_tv_cache_mode=$(cat "$tv_cache_mode_file")
    fi
    
    local tv_cache_choice
    while true; do
        # Build TV cache options with entry counts
        local -a tv_cache_opts=()
        
        for cache_info in "${tv_cache_files[@]}"; do
            IFS='|' read -r cache_key cache_filename cache_desc <<< "$cache_info"
            local cache_path="$CACHE_DIR/$cache_filename"
            local entry_count=0
            if [[ -f "$cache_path" ]]; then
                entry_count=$(awk 'NF' "$cache_path" 2>/dev/null | wc -l | tr -d ' ')
            fi
            tv_cache_opts+=("${cache_key}|${cache_desc} (${cache_filename}) - ${entry_count} entries")
        done
        
        # Add cache management options
        tv_cache_opts+=("manage|📋 Manage Series Caches (Clear/Reset)")
        tv_cache_opts+=("manage_episodes|📺 Manage Episode Caches (Clear/Reset)")
        
        if arrow_select_menu "SERIES CACHE SELECTION" "$saved_tv_cache_mode" "tv_cache_choice" "${tv_cache_opts[@]}"; then
            if [[ "$tv_cache_choice" == "manage" ]]; then
                # Show TV cache management menu
                manage_series_caches
                continue
            elif [[ "$tv_cache_choice" == "manage_episodes" ]]; then
                # Show episode cache management menu  
                manage_episode_caches
                continue
            fi
            echo "$tv_cache_choice" > "$tv_cache_mode_file"
            TV_CACHE_MODE="$tv_cache_choice"
            SESSION_TV_CACHE_MODE="$tv_cache_choice"
            
            # Update saved position for when user returns from inner menus
            saved_tv_cache_mode="$tv_cache_choice"
            
            # Step 2: Episode Format Selection
            while true; do
                local scheme_file="${CACHE_DIR}/tv_naming_scheme.txt"
                local saved_episode_format="0"
                if [[ -f "$scheme_file" ]]; then
                    saved_episode_format=$(grep "^TV_NAMING_EPISODE=" "$scheme_file" 2>/dev/null | cut -d'=' -f2)
                    [[ -z "$saved_episode_format" ]] && saved_episode_format="0"
                fi
                
                local -a episode_format_opts=(
                    "0|📺 Standard - S##E## - Episode Title"
                    "1|📅 Daily - YYYY-MM-DD - Episode Title"
                    "2|🎌 Anime - S##E## - ### - Episode Title"
                )
                
                local episode_format_choice
                if ! arrow_select_menu "TV EPISODE FORMAT" "$saved_episode_format" "episode_format_choice" "${episode_format_opts[@]}"; then
                    # User pressed back to cache menu
                    break
                fi
                
                TV_NAMING_EPISODE="$episode_format_choice"
                # Update the scheme file with new episode format
                if [[ -f "$scheme_file" ]]; then
                    # Update existing entry or append if not found
                    if grep -q "^TV_NAMING_EPISODE=" "$scheme_file"; then
                        sed -i '' "s/^TV_NAMING_EPISODE=.*/TV_NAMING_EPISODE=$episode_format_choice/" "$scheme_file"
                    else
                        echo "TV_NAMING_EPISODE=$episode_format_choice" >> "$scheme_file"
                    fi
                else
                    # Create scheme file if it doesn't exist
                    cat > "$scheme_file" <<EOF
TV_NAMING_FOLDER=0
TV_NAMING_EPISODE=$episode_format_choice
TV_LINK_TYPE="hardlink"
EOF
                fi
                
                # Step 3: MediaInfo Tool Selection
                local mediainfo_pref_file="$CACHE_DIR/mediainfo_tool.txt"
                local saved_mediainfo_tool="mediainfo"
                if [[ -f "$mediainfo_pref_file" ]]; then
                    saved_mediainfo_tool=$(cat "$mediainfo_pref_file")
                fi
                
                local -a mediainfo_opts=(
                    "mediainfo|mediainfo (recommended) - Extract codec/audio/resolution from video stream"
                    "ffprobe|ffprobe - Extract codec/audio/resolution from video stream"
                    "off|Disabled - Use filename/folder parsing only (no stream analysis)"
                )
                
                local mediainfo_choice
                if arrow_select_menu "METADATA EXTRACTION TOOL" "$saved_mediainfo_tool" "mediainfo_choice" "${mediainfo_opts[@]}"; then
                    echo "$mediainfo_choice" > "$mediainfo_pref_file"
                    MEDIAINFO_TOOL="$mediainfo_choice"
                    return 0
                else
                    # User pressed back to episode format menu
                    continue
                fi
            done
            # If we broke out of inner loop, continue outer loop (show cache selection again)
        else
            # User pressed back
            return 1
        fi
    done
}

# Interactive mode
interactive_mode() {
    # Select OS first (if not already selected)
    select_operating_system
    
    # Check dependencies
    check_and_install_dependencies
    
    echo ""
    print_info "========================================="
    print_info "Movie/Series Hardlink Simulator"
    print_info "========================================="
    echo ""
    
    # Ask user to choose between Movie or TV Show mode
    local selected_idx=0
    local -a mode_options=("Quick Movies (Saved Settings)" "Quick TV Shows (Saved Settings)" "Movies (Movie)" "TV Shows (Series)" "Parallel Processing" "Parallel Jobs Count" "Rolling Queue Mode" "Parallel Parsing" "Parallel Parse Jobs" "Parsing Rolling Queue" "JSON Database Mode" "Cache Management" "Debug Level: Movies" "Debug Level: TV Shows" "Diagnostics Mode" "API Delay" "AWK Parser" "Extension Duplicate Mode" "TV Extension Duplicate Mode" "Image Resizer" "Test API Connection" "API Settings" "OS Settings" "Round Resolution")
    
    # Check if API key is configured
    if [[ -z "$TMDB_API_KEY" ]]; then
        clear
        echo ""
        echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${YELLOW}⚠  TMDb API KEY NOT CONFIGURED${NC}"
        echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
        echo -e "${YELLOW}This script requires a TMDb API key to look up movie metadata.${NC}"
        echo ""
        echo -e "${CYAN}Get your free API key from:${NC}"
        echo -e "${GREEN}https://www.themoviedb.org/settings/api${NC}"
        echo ""
        echo -e "${YELLOW}Enter 'y' to open settings menu, or paste your 32-character API key directly:${NC}"
        echo -e "${DIM}(Press Enter without input to proceed without API key)${NC}"
        stty echo
        read -r configure_api
        stty -echo
        
        # Trim whitespace
        configure_api=$(echo "$configure_api" | tr -d '[:space:]')
        
        if [[ "$configure_api" =~ ^[a-f0-9]{32}$ ]]; then
            # Direct API key paste - save it immediately
            echo "$configure_api" > "${CACHE_DIR}/tmdb_api_key.txt"
            TMDB_API_KEY="$configure_api"
            echo ""
            print_success "✓ TMDb API key saved successfully!"
            echo -e "${DIM}Saved to: ${CACHE_DIR}/tmdb_api_key.txt${NC}"
            echo ""
            sleep 1
        elif [[ "$configure_api" =~ ^[Yy]$ ]]; then
            show_settings_menu
        else
            echo ""
            print_warning "Proceeding without TMDb API key - using IMDb-only search"
            echo -e "${DIM}Note: You can configure TMDb API key later via Settings menu${NC}"
            echo ""
            sleep 2
        fi
    fi
    
    # Disable echo to prevent escape sequences from being displayed
    stty -echo 2>/dev/null
    tput civis 2>/dev/null
    
    while true; do
        clear  # Clear screen before redrawing to prevent escape sequence artifacts
        {
        
        echo ""
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${CYAN}SELECT MODE${NC}"
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
        echo -e "${YELLOW}ℹ  Note:${NC} ${DIM}Folder names OR file names should contain title and year${NC}"
        echo -e "${YELLOW}ℹ  Note:${NC} ${DIM}Script checks file name first, then folder (file name is preferred)${NC}"
        echo -e "${DIM}   Good Example: Folder 'Movie.Title.2020.1080p/' with any video file inside${NC}"
        echo -e "${DIM}   Good Example: File 'Movie.Title.2020.1080p.mkv' or 'Movie Title (2020).mp4'${NC}"
        echo -e "${DIM}   Bad Example:  Folder 'downloads/' with 'watchable-moviename-sd.mkv' (no year anywhere)${NC}"
        echo -e "${DIM}   if the movie folder has MOVIE TITLE YEAR then dont worry about the file name and vice versa${NC}"
        echo ""
        
        # Load debug mode and parallel processing statuses
        [[ -f "${CACHE_DIR}/debug_mode_movies.txt" ]] && DEBUG_MODE_MOVIES=$(cat "${CACHE_DIR}/debug_mode_movies.txt")
        [[ -f "${CACHE_DIR}/debug_mode_tv.txt" ]] && DEBUG_MODE_TV=$(cat "${CACHE_DIR}/debug_mode_tv.txt")
        [[ -f "${CACHE_DIR}/diagnostics_mode.txt" ]] && DIAGNOSTICS_MODE=$(cat "${CACHE_DIR}/diagnostics_mode.txt")
        [[ -f "${CACHE_DIR}/parallel_processing.txt" ]] && PARALLEL_PROCESSING=$(cat "${CACHE_DIR}/parallel_processing.txt")
        [[ -f "${CACHE_DIR}/parallel_jobs.txt" ]] && PARALLEL_JOBS=$(cat "${CACHE_DIR}/parallel_jobs.txt")
        [[ -f "${CACHE_DIR}/json_db_mode.txt" ]] && JSON_DB_MODE=$(cat "${CACHE_DIR}/json_db_mode.txt")
        [[ -f "${CACHE_DIR}/api_delay.txt" ]] && API_DELAY=$(cat "${CACHE_DIR}/api_delay.txt")
        [[ -f "${CACHE_DIR}/awk_parser.txt" ]] && AWK_PARSER=$(cat "${CACHE_DIR}/awk_parser.txt") || AWK_PARSER="awk"
        [[ -f "${CACHE_DIR}/extension_dup_mode.txt" ]] && EXTENSION_DUP_MODE=$(cat "${CACHE_DIR}/extension_dup_mode.txt") || EXTENSION_DUP_MODE="off"
        [[ -f "${CACHE_DIR}/tv_extension_dup_mode.txt" ]] && TV_EXTENSION_DUP_MODE=$(cat "${CACHE_DIR}/tv_extension_dup_mode.txt") || TV_EXTENSION_DUP_MODE="off"
        [[ -f "${CACHE_DIR}/image_resizer.txt" ]] && IMAGE_RESIZER=$(cat "${CACHE_DIR}/image_resizer.txt") || IMAGE_RESIZER="auto"
        
        for i in "${!mode_options[@]}"; do
            local display_text="${mode_options[$i]}"
            
            # Add status indicators
            if [[ $i -eq 4 ]]; then
                # Parallel Processing
                if [[ "$PARALLEL_PROCESSING" == "true" ]]; then
                    display_text="${mode_options[$i]} ${GREEN}[ON]${NC}"
                else
                    display_text="${mode_options[$i]} ${RED}[OFF]${NC}"
                fi
            elif [[ $i -eq 5 ]]; then
                # Parallel Jobs Count
                display_text="${mode_options[$i]} ${CYAN}[${PARALLEL_JOBS}]${NC}"
            elif [[ $i -eq 6 ]]; then
                # Rolling Queue Mode
                [[ -f "${CACHE_DIR}/rolling_queue_mode.txt" ]] && ROLLING_QUEUE_MODE=$(cat "${CACHE_DIR}/rolling_queue_mode.txt")
                if [[ "$ROLLING_QUEUE_MODE" == "true" ]]; then
                    display_text="${mode_options[$i]} ${GREEN}[ON]${NC}"
                else
                    display_text="${mode_options[$i]} ${RED}[OFF]${NC}"
                fi
            elif [[ $i -eq 7 ]]; then
                # Parallel Parsing
                if [[ "$PARALLEL_PARSING" == "true" ]]; then
                    display_text="${mode_options[$i]} ${GREEN}[ON]${NC}"
                else
                    display_text="${mode_options[$i]} ${RED}[OFF]${NC}"
                fi
            elif [[ $i -eq 8 ]]; then
                # Parallel Parse Jobs
                display_text="${mode_options[$i]} ${CYAN}[${PARALLEL_PARSE_JOBS}]${NC}"
            elif [[ $i -eq 9 ]]; then
                # Parsing Rolling Queue
                [[ -f "${CACHE_DIR}/parsing_rolling_queue_mode.txt" ]] && PARSING_ROLLING_QUEUE_MODE=$(cat "${CACHE_DIR}/parsing_rolling_queue_mode.txt")
                if [[ "$PARSING_ROLLING_QUEUE_MODE" == "true" ]]; then
                    display_text="${mode_options[$i]} ${GREEN}[ON]${NC}"
                else
                    display_text="${mode_options[$i]} ${RED}[OFF]${NC}"
                fi
            elif [[ $i -eq 10 ]]; then
                # JSON Database Mode
                case "$JSON_DB_MODE" in
                    json_only) display_text="${mode_options[$i]} ${CYAN}[JSON ONLY EXPERIMENTAL]${NC}" ;;
                    api_only) display_text="${mode_options[$i]} ${YELLOW}[API ONLY]${NC}" ;;
                    hybrid) display_text="${mode_options[$i]} ${GREEN}[HYBRID EXPERIMENTAL]${NC}" ;;
                    *) display_text="${mode_options[$i]} ${GREEN}[HYBRID]${NC}" ;;
                esac
            elif [[ $i -eq 11 ]]; then
                # Cache Management - no status needed
                display_text="${mode_options[$i]}"
            elif [[ $i -eq 12 ]]; then
                # Debug Level: Movies
                local movies_level="off"
                if [[ -f "${CACHE_DIR}/debug_mode_movies.txt" ]]; then
                    local value=$(cat "${CACHE_DIR}/debug_mode_movies.txt")
                    case "$value" in
                        true) movies_level="high" ;;
                        false) movies_level="off" ;;
                        off|low|medium|high) movies_level="$value" ;;
                    esac
                fi
                case "$movies_level" in
                    off) display_text="${mode_options[$i]} ${RED}[OFF]${NC}" ;;
                    low) display_text="${mode_options[$i]} ${YELLOW}[LOW]${NC}" ;;
                    medium) display_text="${mode_options[$i]} ${CYAN}[MEDIUM]${NC}" ;;
                    high) display_text="${mode_options[$i]} ${GREEN}[HIGH]${NC}" ;;
                esac
            elif [[ $i -eq 13 ]]; then
                # Debug Level: TV Shows
                local tv_level="off"
                if [[ -f "${CACHE_DIR}/debug_mode_tv.txt" ]]; then
                    local value=$(cat "${CACHE_DIR}/debug_mode_tv.txt")
                    case "$value" in
                        true) tv_level="high" ;;
                        false) tv_level="off" ;;
                        off|low|medium|high) tv_level="$value" ;;
                    esac
                fi
                case "$tv_level" in
                    off) display_text="${mode_options[$i]} ${RED}[OFF]${NC}" ;;
                    low) display_text="${mode_options[$i]} ${YELLOW}[LOW]${NC}" ;;
                    medium) display_text="${mode_options[$i]} ${CYAN}[MEDIUM]${NC}" ;;
                    high) display_text="${mode_options[$i]} ${GREEN}[HIGH]${NC}" ;;
                esac
            elif [[ $i -eq 14 ]]; then
                # Diagnostics Mode
                if [[ "$DIAGNOSTICS_MODE" == "true" ]]; then
                    display_text="${mode_options[$i]} ${GREEN}[ON]${NC}"
                else
                    display_text="${mode_options[$i]} ${RED}[OFF]${NC}"
                fi
            elif [[ $i -eq 15 ]]; then
                # API Delay
                display_text="${mode_options[$i]} ${CYAN}[${API_DELAY}s]${NC}"
            elif [[ $i -eq 16 ]]; then
                # AWK Parser
                local awk_display="awk"
                case "$AWK_PARSER" in
                    gawk) 
                        if command -v gawk &> /dev/null; then
                            awk_display="gawk (GNU)"
                        else
                            awk_display="gawk (not installed)"
                        fi
                        ;;
                    mawk) 
                        if command -v mawk &> /dev/null; then
                            awk_display="mawk (fastest)"
                        else
                            awk_display="mawk (not installed)"
                        fi
                        ;;
                    *) awk_display="awk (BSD)" ;;
                esac
                display_text="${mode_options[$i]} ${CYAN}[${awk_display}]${NC}"
            elif [[ $i -eq 17 ]]; then
                # Extension Duplicate Mode
                case "$EXTENSION_DUP_MODE" in
                    resolution) display_text="${mode_options[$i]} ${GREEN}[RESOLUTION]${NC}" ;;
                    bitrate) display_text="${mode_options[$i]} ${CYAN}[BITRATE]${NC}" ;;
                    off) display_text="${mode_options[$i]} ${RED}[OFF]${NC}" ;;
                    *) display_text="${mode_options[$i]} ${RED}[OFF]${NC}" ;;
                esac
            elif [[ $i -eq 18 ]]; then
                # TV Extension Duplicate Mode
                case "$TV_EXTENSION_DUP_MODE" in
                    resolution) display_text="${mode_options[$i]} ${GREEN}[RESOLUTION]${NC}" ;;
                    bitrate) display_text="${mode_options[$i]} ${CYAN}[BITRATE]${NC}" ;;
                    off) display_text="${mode_options[$i]} ${RED}[OFF]${NC}" ;;
                    *) display_text="${mode_options[$i]} ${RED}[OFF]${NC}" ;;
                esac
            elif [[ $i -eq 19 ]]; then
                # Image Resizer
                local resizer_display="auto"
                local resizer_status=""
                case "$IMAGE_RESIZER" in
                    auto) 
                        resizer_display="AUTO"
                        resizer_status="${GREEN}[AUTO]${NC}"
                        ;;
                    sips)
                        if command -v sips &> /dev/null; then
                            resizer_display="sips"
                            resizer_status="${GREEN}[sips]${NC}"
                        else
                            resizer_display="sips (not available)"
                            resizer_status="${RED}[sips ✗]${NC}"
                        fi
                        ;;
                    vips)
                        if command -v vipsthumbnail &> /dev/null; then
                            resizer_display="vips"
                            resizer_status="${GREEN}[vips]${NC}"
                        else
                            resizer_display="vips (not installed)"
                            resizer_status="${RED}[vips ✗]${NC}"
                        fi
                        ;;
                    *) 
                        resizer_display="AUTO"
                        resizer_status="${GREEN}[AUTO]${NC}"
                        ;;
                esac
                display_text="${mode_options[$i]} ${resizer_status}"
            elif [[ $i -eq 20 ]]; then
                # Test API Connection
                display_text="${mode_options[$i]}"
            elif [[ $i -eq 21 ]]; then
                # API Settings
                display_text="${mode_options[$i]}"
            elif [[ $i -eq 22 ]]; then
                # OS Settings
                display_text="${mode_options[$i]}"
            elif [[ $i -eq 23 ]]; then
                # Round Resolution
                if [[ "$ROUND_RESOLUTION" == "yes" ]]; then
                    display_text="${mode_options[$i]} ${GREEN}[ON]${NC}"
                else
                    display_text="${mode_options[$i]} ${RED}[OFF]${NC}"
                fi
            fi
            
            if [[ $i -eq $selected_idx ]]; then
                echo -e "  ${GREEN}▶ ${display_text}${NC}"
            else
                echo -e "    ${DIM}${display_text}${NC}"
            fi
        done
        
        echo ""
        
        # Show explanation for Extension Duplicate Mode when selected
        if [[ $selected_idx -eq 17 ]]; then
            if [[ "$EXTENSION_DUP_MODE" == "off" ]]; then
                echo -e "${DIM}  Same-name files with different extensions will be shown for manual${NC}"
                echo -e "${DIM}  review at post-processing, allowing you to choose which to keep.${NC}"
                echo ""
            fi
        fi
        
        # Show explanation for Round Resolution when selected
        if [[ $selected_idx -eq 22 ]]; then
            if [[ "$ROUND_RESOLUTION" == "yes" ]]; then
                echo -e "${DIM}  Resolution from mediainfo/ffprobe is rounded to standard heights:${NC}"
                echo -e "${DIM}  ${CYAN}Examples:${NC} 1028p → 1080p, 800p → 1080p, 719p → 720p, 570p → 576p${NC}"
                echo -e "${DIM}  ${GREEN}Enabled:${NC} Outputs standard resolutions (recommended for most users)${NC}"
            else
                echo -e "${DIM}  Resolution from mediainfo/ffprobe uses exact pixel height:${NC}"
                echo -e "${DIM}  ${CYAN}Examples:${NC} 1028p, 800p, 719p, 570p (exact measurements)${NC}"
                echo -e "${DIM}  ${YELLOW}Disabled:${NC} Outputs exact resolutions (for advanced/technical users)${NC}"
            fi
            echo ""
        fi
        
        echo -e "${DIM}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        
        # Display current settings status
        local masked_key=""
        if [[ -n "$TMDB_API_KEY" ]]; then
            masked_key="${TMDB_API_KEY:0:8}$(printf '%.0s*' {1..24})"
        else
            masked_key="Not configured"
        fi
        
        local pp_status=$(if [[ "$PARALLEL_PROCESSING" == "true" ]]; then echo "${GREEN}ON${NC}"; else echo "${RED}OFF${NC}"; fi)
        local pparse_status=$(if [[ "$PARALLEL_PARSING" == "true" ]]; then echo "${GREEN}ON${NC}"; else echo "${RED}OFF${NC}"; fi)
        
        # Get debug levels with colors
        local debug_movies_level="off"
        [[ -f "${CACHE_DIR}/debug_mode_movies.txt" ]] && debug_movies_level=$(cat "${CACHE_DIR}/debug_mode_movies.txt")
        local debug_movies_display=""
        case "$debug_movies_level" in
            off) debug_movies_display="${RED}off${NC}" ;;
            low) debug_movies_display="${YELLOW}low${NC}" ;;
            medium) debug_movies_display="${CYAN}medium${NC}" ;;
            high) debug_movies_display="${GREEN}high${NC}" ;;
            *) debug_movies_display="${RED}off${NC}" ;;
        esac
        
        local debug_tv_level="off"
        [[ -f "${CACHE_DIR}/debug_mode_tv.txt" ]] && debug_tv_level=$(cat "${CACHE_DIR}/debug_mode_tv.txt")
        local debug_tv_display=""
        case "$debug_tv_level" in
            off) debug_tv_display="${RED}off${NC}" ;;
            low) debug_tv_display="${YELLOW}low${NC}" ;;
            medium) debug_tv_display="${CYAN}medium${NC}" ;;
            high) debug_tv_display="${GREEN}high${NC}" ;;
            *) debug_tv_display="${RED}off${NC}" ;;
        esac
        
        # Get diagnostics mode
        local diag_status=$(if [[ "$DIAGNOSTICS_MODE" == "true" ]]; then echo "${GREEN}ON${NC}"; else echo "${RED}OFF${NC}"; fi)
        
        # Show contextual help for selected items with left/right arrow support
        if [[ $selected_idx -eq 4 ]]; then
            echo -e "${YELLOW}↑/↓${NC}: Navigate  ${YELLOW}←/→/ENTER${NC}: Toggle  ${YELLOW}b${NC}: Back/Exit"
            echo -e "Enables ${CYAN}parallel batch processing${NC} of movie files for ${GREEN}faster execution${NC}"
        elif [[ $selected_idx -eq 5 ]]; then
            echo -e "${YELLOW}↑/↓${NC}: Navigate  ${YELLOW}←/→${NC}: Adjust jobs  ${YELLOW}ENTER${NC}: Manual input  ${YELLOW}b${NC}: Back/Exit"
            echo -e "Number of ${CYAN}parallel jobs${NC} for batch processing (currently: ${GREEN}${PARALLEL_JOBS}${NC})"
        elif [[ $selected_idx -eq 6 ]]; then
            echo -e "${YELLOW}↑/↓${NC}: Navigate  ${YELLOW}←/→/ENTER${NC}: Toggle  ${YELLOW}b${NC}: Back/Exit"
            echo -e "${GREEN}Speeds up${NC} ${CYAN}duplicate detection${NC} by parsing files in parallel"
        elif [[ $selected_idx -eq 7 ]]; then
            echo -e "${YELLOW}↑/↓${NC}: Navigate  ${YELLOW}←/→${NC}: Adjust jobs  ${YELLOW}ENTER${NC}: Manual input  ${YELLOW}b${NC}: Back/Exit"
            echo -e "Number of ${CYAN}parallel jobs${NC} for file parsing (currently: ${GREEN}${PARALLEL_PARSE_JOBS}${NC})"
        elif [[ $selected_idx -eq 8 ]]; then
            echo -e "${YELLOW}↑/↓${NC}: Navigate  ${YELLOW}←/→/ENTER${NC}: Toggle  ${YELLOW}b${NC}: Back/Exit"
            echo -e "${GREEN}Rolling queue${NC} for file parsing: starts new jobs as soon as slots open (${CYAN}non-blocking${NC})"
        elif [[ $selected_idx -eq 10 ]]; then
            echo -e "${YELLOW}↑/↓${NC}: Navigate  ${YELLOW}←/→/ENTER${NC}: Cycle modes  ${YELLOW}b${NC}: Back/Exit"
            local json_desc=""
            case "$JSON_DB_MODE" in
                json_only) json_desc="${CYAN}JSON ONLY${NC}: Uses local database, ${RED}no API calls${NC} (${GREEN}slowest${NC}, may be outdated)" ;;
                api_only) json_desc="${YELLOW}API ONLY${NC}: Always queries TMDb API (${GREEN}fastest${NC}, ${GREEN}most current${NC})" ;;
                hybrid) json_desc="${GREEN}HYBRID${NC}: Checks JSON first, falls back to API (${CYAN}balanced${NC}, ${RED}slowest${NC})" ;;
            esac
            echo -e "${json_desc}"
        elif [[ $selected_idx -eq 11 ]]; then
            echo -e "${YELLOW}↑/↓${NC}: Navigate  ${YELLOW}ENTER${NC}: Manage cache  ${YELLOW}b${NC}: Back/Exit"
            echo -e "Manage ${CYAN}local cache${NC} files for movies, TV shows, and metadata"
        elif [[ $selected_idx -eq 12 ]]; then
            echo -e "${YELLOW}↑/↓${NC}: Navigate  ${YELLOW}←/→/ENTER${NC}: Cycle levels  ${YELLOW}b${NC}: Back/Exit"
            local debug_movies_level="off"
            [[ -f "${CACHE_DIR}/debug_mode_movies.txt" ]] && debug_movies_level=$(cat "${CACHE_DIR}/debug_mode_movies.txt")
            case "$debug_movies_level" in
                off) echo -e "Debug logging for movies: ${RED}OFF${NC} (no debug output)" ;;
                low) echo -e "Debug logging for movies: ${YELLOW}LOW${NC} (essential operations only)" ;;
                medium) echo -e "Debug logging for movies: ${CYAN}MEDIUM${NC} (includes parsing details)" ;;
                high|true) echo -e "Debug logging for movies: ${GREEN}HIGH${NC} (verbose, all details)" ;;
            esac
        elif [[ $selected_idx -eq 13 ]]; then
            echo -e "${YELLOW}↑/↓${NC}: Navigate  ${YELLOW}←/→/ENTER${NC}: Cycle levels  ${YELLOW}b${NC}: Back/Exit"
            local debug_tv_level="off"
            [[ -f "${CACHE_DIR}/debug_mode_tv.txt" ]] && debug_tv_level=$(cat "${CACHE_DIR}/debug_mode_tv.txt")
            case "$debug_tv_level" in
                off) echo -e "Debug logging for TV shows: ${RED}OFF${NC} (no debug output)" ;;
                low) echo -e "Debug logging for TV shows: ${YELLOW}LOW${NC} (essential operations only)" ;;
                medium) echo -e "Debug logging for TV shows: ${CYAN}MEDIUM${NC} (includes parsing details)" ;;
                high|true) echo -e "Debug logging for TV shows: ${GREEN}HIGH${NC} (verbose, all details)" ;;
            esac
        elif [[ $selected_idx -eq 14 ]]; then
            echo -e "${YELLOW}↑/↓${NC}: Navigate  ${YELLOW}←/→/ENTER${NC}: Toggle  ${YELLOW}b${NC}: Back/Exit"
            echo -e "Logs ${CYAN}detailed timing${NC} and ${CYAN}resource usage${NC} for parallel jobs (for ${GREEN}performance analysis${NC})"
        elif [[ $selected_idx -eq 15 ]]; then
            echo -e "${YELLOW}↑/↓${NC}: Navigate  ${YELLOW}←/→${NC}: Adjust delay  ${YELLOW}ENTER${NC}: Manual input  ${YELLOW}b${NC}: Back/Exit"
            echo -e "Delay between ${CYAN}TMDb API calls${NC} (currently: ${GREEN}${API_DELAY}s${NC})"
        elif [[ $selected_idx -eq 16 ]]; then
            # Load AWK parser setting
            [[ -f "${CACHE_DIR}/awk_parser.txt" ]] && AWK_PARSER=$(cat "${CACHE_DIR}/awk_parser.txt") || AWK_PARSER="awk"
            local awk_info=""
            case "$AWK_PARSER" in
                awk) awk_info="${CYAN}BSD AWK${NC} - Default, most compatible" ;;
                gawk) 
                    if command -v gawk &> /dev/null; then
                        awk_info="${GREEN}GNU AWK${NC} - Feature-rich ${GREEN}(installed)${NC}"
                    else
                        awk_info="${YELLOW}GNU AWK${NC} - ${RED}Not installed${NC} (brew install gawk)"
                    fi
                    ;;
                mawk) 
                    if command -v mawk &> /dev/null; then
                        awk_info="${GREEN}Mike's AWK${NC} - Fastest performance ${GREEN}(installed)${NC}"
                    else
                        awk_info="${YELLOW}Mike's AWK${NC} - ${RED}Not installed${NC} (brew install mawk)"
                    fi
                    ;;
            esac
            echo -e "${YELLOW}↑/↓${NC}: Navigate  ${YELLOW}←/→/ENTER${NC}: Cycle parsers  ${YELLOW}b${NC}: Back/Exit"
            echo -e "${awk_info}"
        elif [[ $selected_idx -eq 17 ]]; then
            local ext_info=""
            case "$EXTENSION_DUP_MODE" in
                off) ext_info="${RED}OFF${NC}: No duplicate filtering for same-name movies with different extensions" ;;
                resolution) ext_info="${GREEN}RESOLUTION${NC}: Inline filter keeps highest resolution movie (bitrate as tiebreaker)" ;;
                bitrate) ext_info="${CYAN}BITRATE${NC}: Inline filter keeps highest bitrate movie (resolution as tiebreaker)" ;;
            esac
            echo -e "${YELLOW}↑/↓${NC}: Navigate  ${YELLOW}←/→/ENTER${NC}: Toggle mode  ${YELLOW}b${NC}: Back/Exit"
            echo -e "${ext_info}"
        elif [[ $selected_idx -eq 18 ]]; then
            # TV Extension Duplicate Mode
            local tv_ext_info=""
            case "$TV_EXTENSION_DUP_MODE" in
                off) tv_ext_info="${RED}OFF${NC}: No duplicate filtering for same-name TV episodes with different extensions" ;;
                resolution) tv_ext_info="${GREEN}RESOLUTION${NC}: Pre-batch filter keeps highest resolution episode (bitrate tiebreaker)" ;;
                bitrate) tv_ext_info="${CYAN}BITRATE${NC}: Pre-batch filter keeps highest bitrate episode (resolution tiebreaker)" ;;
            esac
            echo -e "${YELLOW}↑/↓${NC}: Navigate  ${YELLOW}←/→/ENTER${NC}: Toggle mode  ${YELLOW}b${NC}: Back/Exit"
            echo -e "${tv_ext_info}"
        elif [[ $selected_idx -eq 19 ]]; then
            # Image Resizer
            [[ -f "${CACHE_DIR}/image_resizer.txt" ]] && IMAGE_RESIZER=$(cat "${CACHE_DIR}/image_resizer.txt") || IMAGE_RESIZER="auto"
            local resizer_info=""
            case "$IMAGE_RESIZER" in
                auto)
                    resizer_info="${GREEN}AUTO${NC}: Automatically uses best available tool ${CYAN}(sips → vips)${NC}"
                    ;;
                sips)
                    if command -v sips &> /dev/null; then
                        resizer_info="${GREEN}sips${NC}: macOS built-in ${GREEN}(installed)${NC} - Fast, system default"
                    else
                        resizer_info="${RED}sips${NC}: ${RED}Not available${NC} - macOS only"
                    fi
                    ;;
                vips)
                    if command -v vipsthumbnail &> /dev/null; then
                        resizer_info="${GREEN}vips${NC}: Fast image processor ${GREEN}(installed)${NC} - Very fast, memory efficient"
                    else
                        resizer_info="${RED}vips${NC}: ${RED}Not installed${NC} - Fastest option when available"
                    fi
                    ;;
            esac
            echo -e "${YELLOW}↑/↓${NC}: Navigate  ${YELLOW}←/→/ENTER${NC}: Cycle tools  ${YELLOW}b${NC}: Back/Exit"
            echo -e "${resizer_info}"
        elif [[ $selected_idx -eq 20 ]]; then
            # Test API Connection
            echo -e "${YELLOW}↑/↓${NC}: Navigate  ${YELLOW}ENTER${NC}: Test connection  ${YELLOW}b${NC}: Back/Exit"
            echo -e "Test ${CYAN}TMDb API${NC} connectivity and response time"
        elif [[ $selected_idx -eq 21 ]]; then
            # API Settings
            echo -e "${YELLOW}↑/↓${NC}: Navigate  ${YELLOW}ENTER${NC}: Configure API  ${YELLOW}b${NC}: Back/Exit"
            echo -e "Configure ${CYAN}TMDb API key${NC} and related settings"
        elif [[ $selected_idx -eq 22 ]]; then
            # OS Settings
            local current_os="macOS"
            if [[ -f "${CACHE_DIR}/selected_os.txt" ]]; then
                current_os=$(cat "${CACHE_DIR}/selected_os.txt")
            fi
            echo -e "${YELLOW}↑/↓${NC}: Navigate  ${YELLOW}ENTER${NC}: Change OS  ${YELLOW}b${NC}: Back/Exit"
            echo -e "Current OS: ${CYAN}${current_os}${NC} - ${DIM}Change to see OS-specific dependencies${NC}"
        elif [[ $selected_idx -eq 23 ]]; then
            # Round Resolution
            echo -e "${YELLOW}↑/↓${NC}: Navigate  ${YELLOW}←/→/ENTER${NC}: Toggle  ${YELLOW}b${NC}: Back/Exit"
            if [[ "$ROUND_RESOLUTION" == "yes" ]]; then
                echo -e "${GREEN}Enabled${NC}: Rounds mediainfo/ffprobe resolution to standard (1028p → 1080p)"
            else
                echo -e "${YELLOW}Disabled${NC}: Uses exact pixel height from mediainfo/ffprobe (e.g., 1028p)"
            fi
        else
            echo -e "${YELLOW}↑/↓${NC}: Navigate  ${YELLOW}ENTER${NC}: Select  ${YELLOW}b/d${NC}: Dependencies  ${YELLOW}ESC${NC}: Exit"
        fi
        echo -e "${DIM}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        
        # Get current OS for display
        local display_os="macOS"
        if [[ -f "${CACHE_DIR}/selected_os.txt" ]]; then
            display_os=$(cat "${CACHE_DIR}/selected_os.txt")
        fi
        
        # Get current AWK parser
        local awk_parser_display="awk (BSD)"
        [[ -f "${CACHE_DIR}/awk_parser.txt" ]] && AWK_PARSER=$(cat "${CACHE_DIR}/awk_parser.txt") || AWK_PARSER="awk"
        case "$AWK_PARSER" in
            gawk) awk_parser_display="gawk (GNU)" ;;
            mawk) awk_parser_display="mawk (fastest)" ;;
            *) awk_parser_display="awk (BSD)" ;;
        esac
        
        echo -e "${DIM}OS: ${CYAN}\033[5m${display_os}\033[25m${NC}  |  TMDb API Key: ${masked_key}  |  API Delay: ${CYAN}\033[5m${API_DELAY}s\033[25m${NC}${NC}"
        local rolling_queue_status="${RED}OFF${NC}"
        [[ -f "${CACHE_DIR}/rolling_queue_mode.txt" ]] && ROLLING_QUEUE_MODE=$(cat "${CACHE_DIR}/rolling_queue_mode.txt")
        [[ "$ROLLING_QUEUE_MODE" == "true" ]] && rolling_queue_status="${GREEN}ON${NC}"
        local parsing_queue_status="${RED}OFF${NC}"
        [[ -f "${CACHE_DIR}/parsing_rolling_queue_mode.txt" ]] && PARSING_ROLLING_QUEUE_MODE=$(cat "${CACHE_DIR}/parsing_rolling_queue_mode.txt")
        [[ "$PARSING_ROLLING_QUEUE_MODE" == "true" ]] && parsing_queue_status="${GREEN}ON${NC}"
        echo -e "${DIM}Parallel Processing: ${pp_status} (${PARALLEL_JOBS} jobs, Queue: ${rolling_queue_status})  |  Parallel Parsing: ${pparse_status} (${PARALLEL_PARSE_JOBS} jobs, Queue: ${parsing_queue_status})${NC}"
        echo -e "${DIM}Debug: Movies=${debug_movies_display}${DIM} TV=${debug_tv_display}${DIM}  |  Diagnostics: ${diag_status}  |  AWK: ${CYAN}\033[5m${awk_parser_display}\033[25m${NC}${NC}"
        echo -e "${DIM}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        } </dev/null  # Prevent stdin from leaking during screen redraw
        echo ""
        
        read -rsn1 key 2>/dev/null
        
        if [[ "$key" == $'\x1b' ]]; then
            read -rsn2 -t 1 key 2>/dev/null
            # If we didn't get a complete sequence, discard it
            if [[ ${#key} -ne 2 ]]; then
                continue
            fi
            case "$key" in
                '[A'|'OA') # Up arrow
                    ((selected_idx--))
                    [[ $selected_idx -lt 0 ]] && selected_idx=$((${#mode_options[@]} - 1))
                    ;;
                '[B'|'OB') # Down arrow
                    ((selected_idx++))
                    [[ $selected_idx -ge ${#mode_options[@]} ]] && selected_idx=0
                    ;;
                '[C'|'OC') # Right arrow
                    # If on Parallel Processing (index 4), toggle
                    if [[ $selected_idx -eq 4 ]]; then
                        [[ -f "${CACHE_DIR}/parallel_processing.txt" ]] && PARALLEL_PROCESSING=$(cat "${CACHE_DIR}/parallel_processing.txt")
                        if [[ "$PARALLEL_PROCESSING" == "true" ]]; then
                            PARALLEL_PROCESSING="false"
                        else
                            PARALLEL_PROCESSING="true"
                        fi
                        echo "$PARALLEL_PROCESSING" > "${CACHE_DIR}/parallel_processing.txt"
                    # If on Parallel Jobs Count (index 5), increase by 1
                    elif [[ $selected_idx -eq 5 ]]; then
                        [[ -f "${CACHE_DIR}/parallel_jobs.txt" ]] && PARALLEL_JOBS=$(cat "${CACHE_DIR}/parallel_jobs.txt")
                        ((PARALLEL_JOBS++))
                        # Warn if going above 64
                        if [[ $PARALLEL_JOBS -ge 64 ]]; then
                            tput cnorm 2>/dev/null
                            print_warning "Warning: Setting parallel jobs to ${PARALLEL_JOBS}. High values may impact system performance."
                            tput civis 2>/dev/null
                        fi
                        echo "$PARALLEL_JOBS" > "${CACHE_DIR}/parallel_jobs.txt"
                    # If on Rolling Queue Mode (index 6), toggle
                    elif [[ $selected_idx -eq 6 ]]; then
                        [[ -f "${CACHE_DIR}/rolling_queue_mode.txt" ]] && ROLLING_QUEUE_MODE=$(cat "${CACHE_DIR}/rolling_queue_mode.txt")
                        if [[ "$ROLLING_QUEUE_MODE" == "true" ]]; then
                            ROLLING_QUEUE_MODE="false"
                        else
                            ROLLING_QUEUE_MODE="true"
                        fi
                        echo "$ROLLING_QUEUE_MODE" > "${CACHE_DIR}/rolling_queue_mode.txt"
                    # If on Parallel Parsing (index 7), toggle
                    elif [[ $selected_idx -eq 7 ]]; then
                        [[ -f "${CACHE_DIR}/parallel_parsing.txt" ]] && PARALLEL_PARSING=$(cat "${CACHE_DIR}/parallel_parsing.txt")
                        if [[ "$PARALLEL_PARSING" == "true" ]]; then
                            PARALLEL_PARSING="false"
                        else
                            PARALLEL_PARSING="true"
                        fi
                        echo "$PARALLEL_PARSING" > "${CACHE_DIR}/parallel_parsing.txt"
                    # If on Parallel Parse Jobs (index 8), increase by 1
                    elif [[ $selected_idx -eq 8 ]]; then
                        [[ -f "${CACHE_DIR}/parallel_parse_jobs.txt" ]] && PARALLEL_PARSE_JOBS=$(cat "${CACHE_DIR}/parallel_parse_jobs.txt")
                        ((PARALLEL_PARSE_JOBS++))
                        # Warn if going above 64
                        if [[ $PARALLEL_PARSE_JOBS -ge 64 ]]; then
                            tput cnorm 2>/dev/null
                            print_warning "Warning: Setting parallel parse jobs to ${PARALLEL_PARSE_JOBS}. High values may impact system performance."
                            tput civis 2>/dev/null
                        fi
                        echo "$PARALLEL_PARSE_JOBS" > "${CACHE_DIR}/parallel_parse_jobs.txt"
                    # If on Parsing Rolling Queue (index 9), toggle
                    elif [[ $selected_idx -eq 9 ]]; then
                        [[ -f "${CACHE_DIR}/parsing_rolling_queue_mode.txt" ]] && PARSING_ROLLING_QUEUE_MODE=$(cat "${CACHE_DIR}/parsing_rolling_queue_mode.txt")
                        if [[ "$PARSING_ROLLING_QUEUE_MODE" == "true" ]]; then
                            PARSING_ROLLING_QUEUE_MODE="false"
                        else
                            PARSING_ROLLING_QUEUE_MODE="true"
                        fi
                        echo "$PARSING_ROLLING_QUEUE_MODE" > "${CACHE_DIR}/parsing_rolling_queue_mode.txt"
                    # If on JSON Database Mode (index 10), cycle forward
                    elif [[ $selected_idx -eq 10 ]]; then
                        [[ -f "${CACHE_DIR}/json_db_mode.txt" ]] && JSON_DB_MODE=$(cat "${CACHE_DIR}/json_db_mode.txt")
                        case "$JSON_DB_MODE" in
                            hybrid) JSON_DB_MODE="json_only" ;;
                            json_only) JSON_DB_MODE="api_only" ;;
                            api_only) JSON_DB_MODE="hybrid" ;;
                        esac
                        echo "$JSON_DB_MODE" > "${CACHE_DIR}/json_db_mode.txt"
                    # If on Debug Level: Movies (index 12), cycle forward
                    elif [[ $selected_idx -eq 12 ]]; then
                        [[ -f "${CACHE_DIR}/debug_mode_movies.txt" ]] && DEBUG_LEVEL_MOVIES=$(cat "${CACHE_DIR}/debug_mode_movies.txt") || DEBUG_LEVEL_MOVIES="off"
                        case "$DEBUG_LEVEL_MOVIES" in
                            off) DEBUG_LEVEL_MOVIES="low" ;;
                            low) DEBUG_LEVEL_MOVIES="medium" ;;
                            medium) DEBUG_LEVEL_MOVIES="high" ;;
                            high) DEBUG_LEVEL_MOVIES="off" ;;
                        esac
                        echo "$DEBUG_LEVEL_MOVIES" > "${CACHE_DIR}/debug_mode_movies.txt"
                        # Update backward compat variable
                        [[ "$DEBUG_LEVEL_MOVIES" != "off" ]] && DEBUG_MODE_MOVIES="true" || DEBUG_MODE_MOVIES="false"
                    # If on Debug Level: TV Shows (index 13), cycle forward
                    elif [[ $selected_idx -eq 13 ]]; then
                        [[ -f "${CACHE_DIR}/debug_mode_tv.txt" ]] && DEBUG_LEVEL_TV=$(cat "${CACHE_DIR}/debug_mode_tv.txt") || DEBUG_LEVEL_TV="off"
                        case "$DEBUG_LEVEL_TV" in
                            off) DEBUG_LEVEL_TV="low" ;;
                            low) DEBUG_LEVEL_TV="medium" ;;
                            medium) DEBUG_LEVEL_TV="high" ;;
                            high) DEBUG_LEVEL_TV="off" ;;
                        esac
                        echo "$DEBUG_LEVEL_TV" > "${CACHE_DIR}/debug_mode_tv.txt"
                        # Update backward compat variable
                        [[ "$DEBUG_LEVEL_TV" != "off" ]] && DEBUG_MODE_TV="true" || DEBUG_MODE_TV="false"
                    # If on Diagnostics Mode (index 14), toggle
                    elif [[ $selected_idx -eq 14 ]]; then
                        [[ -f "${CACHE_DIR}/diagnostics_mode.txt" ]] && DIAGNOSTICS_MODE=$(cat "${CACHE_DIR}/diagnostics_mode.txt")
                        if [[ "$DIAGNOSTICS_MODE" == "true" ]]; then
                            DIAGNOSTICS_MODE="false"
                        else
                            DIAGNOSTICS_MODE="true"
                        fi
                        echo "$DIAGNOSTICS_MODE" > "${CACHE_DIR}/diagnostics_mode.txt"
                    # If on API Delay (index 15), increase by 0.1 (below 2.0) or 0.5 (at/above 2.0)
                    elif [[ $selected_idx -eq 15 ]]; then
                        [[ -f "${CACHE_DIR}/api_delay.txt" ]] && API_DELAY=$(cat "${CACHE_DIR}/api_delay.txt")
                        local new_delay
                        if command -v bc &> /dev/null; then
                            # Determine increment based on current value
                            if (( $(echo "$API_DELAY < 2.0" | bc -l) )); then
                                new_delay=$(echo "$API_DELAY + 0.1" | bc)
                            else
                                new_delay=$(echo "$API_DELAY + 0.5" | bc)
                            fi
                            # Cap at 5.0
                            if (( $(echo "$new_delay > 5.0" | bc -l) )); then
                                new_delay="5.0"
                            fi
                        else
                            # Determine increment based on current value
                            if (( $(awk "BEGIN {print ($API_DELAY < 2.0)}") )); then
                                new_delay=$(awk "BEGIN {print $API_DELAY + 0.1}")
                            else
                                new_delay=$(awk "BEGIN {print $API_DELAY + 0.5}")
                            fi
                            if (( $(awk "BEGIN {print ($new_delay > 5.0)}") )); then
                                new_delay="5.0"
                            fi
                        fi
                        API_DELAY=$new_delay
                        # Format to 2 decimal places
                        API_DELAY=$(printf "%.2f" "$API_DELAY")
                        echo "$API_DELAY" > "${CACHE_DIR}/api_delay.txt"
                    # If on AWK Parser (index 16), cycle forward
                    elif [[ $selected_idx -eq 16 ]]; then
                        [[ -f "${CACHE_DIR}/awk_parser.txt" ]] && AWK_PARSER=$(cat "${CACHE_DIR}/awk_parser.txt") || AWK_PARSER="awk"
                        case "$AWK_PARSER" in
                            awk)
                                if command -v gawk &> /dev/null; then
                                    AWK_PARSER="gawk"
                                elif command -v mawk &> /dev/null; then
                                    AWK_PARSER="mawk"
                                fi
                                ;;
                            gawk)
                                if command -v mawk &> /dev/null; then
                                    AWK_PARSER="mawk"
                                else
                                    AWK_PARSER="awk"
                                fi
                                ;;
                            mawk) AWK_PARSER="awk" ;;
                        esac
                        echo "$AWK_PARSER" > "${CACHE_DIR}/awk_parser.txt"
                    # If on Extension Duplicate Mode (index 17), cycle forward
                    elif [[ $selected_idx -eq 17 ]]; then
                        [[ -f "${CACHE_DIR}/extension_dup_mode.txt" ]] && EXTENSION_DUP_MODE=$(cat "${CACHE_DIR}/extension_dup_mode.txt") || EXTENSION_DUP_MODE="off"
                        case "$EXTENSION_DUP_MODE" in
                            off) EXTENSION_DUP_MODE="resolution" ;;
                            resolution) EXTENSION_DUP_MODE="bitrate" ;;
                            bitrate) EXTENSION_DUP_MODE="off" ;;
                            *) EXTENSION_DUP_MODE="off" ;;
                        esac
                        echo "$EXTENSION_DUP_MODE" > "${CACHE_DIR}/extension_dup_mode.txt"
                    # If on TV Extension Duplicate Mode (index 18), cycle forward
                    elif [[ $selected_idx -eq 18 ]]; then
                        [[ -f "${CACHE_DIR}/tv_extension_dup_mode.txt" ]] && TV_EXTENSION_DUP_MODE=$(cat "${CACHE_DIR}/tv_extension_dup_mode.txt") || TV_EXTENSION_DUP_MODE="off"
                        case "$TV_EXTENSION_DUP_MODE" in
                            off) TV_EXTENSION_DUP_MODE="resolution" ;;
                            resolution) TV_EXTENSION_DUP_MODE="bitrate" ;;
                            bitrate) TV_EXTENSION_DUP_MODE="off" ;;
                            *) TV_EXTENSION_DUP_MODE="off" ;;
                        esac
                        echo "$TV_EXTENSION_DUP_MODE" > "${CACHE_DIR}/tv_extension_dup_mode.txt"
                    # If on Image Resizer (index 19), cycle forward
                    elif [[ $selected_idx -eq 19 ]]; then
                        [[ -f "${CACHE_DIR}/image_resizer.txt" ]] && IMAGE_RESIZER=$(cat "${CACHE_DIR}/image_resizer.txt") || IMAGE_RESIZER="auto"
                        case "$IMAGE_RESIZER" in
                            auto) IMAGE_RESIZER="sips" ;;
                            sips) IMAGE_RESIZER="vips" ;;
                            vips) IMAGE_RESIZER="auto" ;;
                            *) IMAGE_RESIZER="auto" ;;
                        esac
                        echo "$IMAGE_RESIZER" > "${CACHE_DIR}/image_resizer.txt"
                    # If on Round Resolution (index 23), toggle
                    elif [[ $selected_idx -eq 23 ]]; then
                        if [[ "$ROUND_RESOLUTION" == "yes" ]]; then
                            ROUND_RESOLUTION="no"
                        else
                            ROUND_RESOLUTION="yes"
                        fi
                        echo "$ROUND_RESOLUTION" > "${CACHE_DIR}/round_resolution.txt"
                    fi
                    ;;
                '[D') # Left arrow
                    # If on Parallel Processing (index 4), toggle
                    if [[ $selected_idx -eq 4 ]]; then
                        [[ -f "${CACHE_DIR}/parallel_processing.txt" ]] && PARALLEL_PROCESSING=$(cat "${CACHE_DIR}/parallel_processing.txt")
                        if [[ "$PARALLEL_PROCESSING" == "true" ]]; then
                            PARALLEL_PROCESSING="false"
                        else
                            PARALLEL_PROCESSING="true"
                        fi
                        echo "$PARALLEL_PROCESSING" > "${CACHE_DIR}/parallel_processing.txt"
                    # If on Parallel Jobs Count (index 5), decrease by 1
                    elif [[ $selected_idx -eq 5 ]]; then
                        [[ -f "${CACHE_DIR}/parallel_jobs.txt" ]] && PARALLEL_JOBS=$(cat "${CACHE_DIR}/parallel_jobs.txt")
                        if [[ $PARALLEL_JOBS -gt 2 ]]; then
                            ((PARALLEL_JOBS--))
                            echo "$PARALLEL_JOBS" > "${CACHE_DIR}/parallel_jobs.txt"
                        fi
                    # If on Rolling Queue Mode (index 6), toggle
                    elif [[ $selected_idx -eq 6 ]]; then
                        [[ -f "${CACHE_DIR}/rolling_queue_mode.txt" ]] && ROLLING_QUEUE_MODE=$(cat "${CACHE_DIR}/rolling_queue_mode.txt")
                        if [[ "$ROLLING_QUEUE_MODE" == "true" ]]; then
                            ROLLING_QUEUE_MODE="false"
                        else
                            ROLLING_QUEUE_MODE="true"
                        fi
                        echo "$ROLLING_QUEUE_MODE" > "${CACHE_DIR}/rolling_queue_mode.txt"
                    # If on Parallel Parsing (index 7), toggle
                    elif [[ $selected_idx -eq 7 ]]; then
                        [[ -f "${CACHE_DIR}/parallel_parsing.txt" ]] && PARALLEL_PARSING=$(cat "${CACHE_DIR}/parallel_parsing.txt")
                        if [[ "$PARALLEL_PARSING" == "true" ]]; then
                            PARALLEL_PARSING="false"
                        else
                            PARALLEL_PARSING="true"
                        fi
                        echo "$PARALLEL_PARSING" > "${CACHE_DIR}/parallel_parsing.txt"
                    # If on Parallel Parse Jobs (index 8), decrease by 1
                    elif [[ $selected_idx -eq 8 ]]; then
                        [[ -f "${CACHE_DIR}/parallel_parse_jobs.txt" ]] && PARALLEL_PARSE_JOBS=$(cat "${CACHE_DIR}/parallel_parse_jobs.txt")
                        if [[ $PARALLEL_PARSE_JOBS -gt 2 ]]; then
                            ((PARALLEL_PARSE_JOBS--))
                            echo "$PARALLEL_PARSE_JOBS" > "${CACHE_DIR}/parallel_parse_jobs.txt"
                        fi
                    # If on Parsing Rolling Queue (index 9), toggle
                    elif [[ $selected_idx -eq 9 ]]; then
                        [[ -f "${CACHE_DIR}/parsing_rolling_queue_mode.txt" ]] && PARSING_ROLLING_QUEUE_MODE=$(cat "${CACHE_DIR}/parsing_rolling_queue_mode.txt")
                        if [[ "$PARSING_ROLLING_QUEUE_MODE" == "true" ]]; then
                            PARSING_ROLLING_QUEUE_MODE="false"
                        else
                            PARSING_ROLLING_QUEUE_MODE="true"
                        fi
                        echo "$PARSING_ROLLING_QUEUE_MODE" > "${CACHE_DIR}/parsing_rolling_queue_mode.txt"
                    # If on JSON Database Mode (index 10), cycle backward
                    elif [[ $selected_idx -eq 10 ]]; then
                        [[ -f "${CACHE_DIR}/json_db_mode.txt" ]] && JSON_DB_MODE=$(cat "${CACHE_DIR}/json_db_mode.txt")
                        case "$JSON_DB_MODE" in
                            hybrid) JSON_DB_MODE="api_only" ;;
                            json_only) JSON_DB_MODE="hybrid" ;;
                            api_only) JSON_DB_MODE="json_only" ;;
                        esac
                        echo "$JSON_DB_MODE" > "${CACHE_DIR}/json_db_mode.txt"
                    # If on Debug Level: Movies (index 12), cycle backward
                    elif [[ $selected_idx -eq 12 ]]; then
                        [[ -f "${CACHE_DIR}/debug_mode_movies.txt" ]] && DEBUG_LEVEL_MOVIES=$(cat "${CACHE_DIR}/debug_mode_movies.txt") || DEBUG_LEVEL_MOVIES="off"
                        case "$DEBUG_LEVEL_MOVIES" in
                            off) DEBUG_LEVEL_MOVIES="high" ;;
                            low) DEBUG_LEVEL_MOVIES="off" ;;
                            medium) DEBUG_LEVEL_MOVIES="low" ;;
                            high) DEBUG_LEVEL_MOVIES="medium" ;;
                        esac
                        echo "$DEBUG_LEVEL_MOVIES" > "${CACHE_DIR}/debug_mode_movies.txt"
                        # Update backward compat variable
                        [[ "$DEBUG_LEVEL_MOVIES" != "off" ]] && DEBUG_MODE_MOVIES="true" || DEBUG_MODE_MOVIES="false"
                    # If on Debug Level: TV Shows (index 13), cycle backward
                    elif [[ $selected_idx -eq 13 ]]; then
                        [[ -f "${CACHE_DIR}/debug_mode_tv.txt" ]] && DEBUG_LEVEL_TV=$(cat "${CACHE_DIR}/debug_mode_tv.txt") || DEBUG_LEVEL_TV="off"
                        case "$DEBUG_LEVEL_TV" in
                            off) DEBUG_LEVEL_TV="high" ;;
                            low) DEBUG_LEVEL_TV="off" ;;
                            medium) DEBUG_LEVEL_TV="low" ;;
                            high) DEBUG_LEVEL_TV="medium" ;;
                        esac
                        echo "$DEBUG_LEVEL_TV" > "${CACHE_DIR}/debug_mode_tv.txt"
                        # Update backward compat variable
                        [[ "$DEBUG_LEVEL_TV" != "off" ]] && DEBUG_MODE_TV="true" || DEBUG_MODE_TV="false"
                    # If on Diagnostics Mode (index 14), toggle
                    elif [[ $selected_idx -eq 14 ]]; then
                        [[ -f "${CACHE_DIR}/diagnostics_mode.txt" ]] && DIAGNOSTICS_MODE=$(cat "${CACHE_DIR}/diagnostics_mode.txt")
                        if [[ "$DIAGNOSTICS_MODE" == "true" ]]; then
                            DIAGNOSTICS_MODE="false"
                        else
                            DIAGNOSTICS_MODE="true"
                        fi
                        echo "$DIAGNOSTICS_MODE" > "${CACHE_DIR}/diagnostics_mode.txt"
                    # If on API Delay (index 15), decrease by 0.1 (below/at 2.0) or 0.5 (above 2.0)
                    elif [[ $selected_idx -eq 15 ]]; then
                        [[ -f "${CACHE_DIR}/api_delay.txt" ]] && API_DELAY=$(cat "${CACHE_DIR}/api_delay.txt")
                        local new_delay
                        if command -v bc &> /dev/null; then
                            # Determine decrement based on current value
                            if (( $(echo "$API_DELAY <= 2.0" | bc -l) )); then
                                new_delay=$(echo "$API_DELAY - 0.1" | bc)
                            else
                                new_delay=$(echo "$API_DELAY - 0.5" | bc)
                            fi
                            # Floor at 0.1
                            if (( $(echo "$new_delay < 0.1" | bc -l) )); then
                                new_delay="0.1"
                            fi
                        else
                            # Determine decrement based on current value
                            if (( $(awk "BEGIN {print ($API_DELAY <= 2.0)}") )); then
                                new_delay=$(awk "BEGIN {print $API_DELAY - 0.1}")
                            else
                                new_delay=$(awk "BEGIN {print $API_DELAY - 0.5}")
                            fi
                            if (( $(awk "BEGIN {print ($new_delay < 0.1)}") )); then
                                new_delay="0.1"
                            fi
                        fi
                        API_DELAY=$new_delay
                        # Format to 2 decimal places
                        API_DELAY=$(printf "%.2f" "$API_DELAY")
                        echo "$API_DELAY" > "${CACHE_DIR}/api_delay.txt"
                    # If on AWK Parser (index 16), cycle backward
                    elif [[ $selected_idx -eq 16 ]]; then
                        [[ -f "${CACHE_DIR}/awk_parser.txt" ]] && AWK_PARSER=$(cat "${CACHE_DIR}/awk_parser.txt") || AWK_PARSER="awk"
                        case "$AWK_PARSER" in
                            awk)
                                if command -v mawk &> /dev/null; then
                                    AWK_PARSER="mawk"
                                elif command -v gawk &> /dev/null; then
                                    AWK_PARSER="gawk"
                                fi
                                ;;
                            gawk) AWK_PARSER="awk" ;;
                            mawk)
                                if command -v gawk &> /dev/null; then
                                    AWK_PARSER="gawk"
                                else
                                    AWK_PARSER="awk"
                                fi
                                ;;
                        esac
                        echo "$AWK_PARSER" > "${CACHE_DIR}/awk_parser.txt"
                    # If on Extension Duplicate Mode (index 17), cycle backward
                    elif [[ $selected_idx -eq 17 ]]; then
                        [[ -f "${CACHE_DIR}/extension_dup_mode.txt" ]] && EXTENSION_DUP_MODE=$(cat "${CACHE_DIR}/extension_dup_mode.txt") || EXTENSION_DUP_MODE="off"
                        case "$EXTENSION_DUP_MODE" in
                            off) EXTENSION_DUP_MODE="bitrate" ;;
                            bitrate) EXTENSION_DUP_MODE="resolution" ;;
                            resolution) EXTENSION_DUP_MODE="off" ;;
                            *) EXTENSION_DUP_MODE="off" ;;
                        esac
                        echo "$EXTENSION_DUP_MODE" > "${CACHE_DIR}/extension_dup_mode.txt"
                    # If on TV Extension Duplicate Mode (index 18), cycle backward
                    elif [[ $selected_idx -eq 18 ]]; then
                        [[ -f "${CACHE_DIR}/tv_extension_dup_mode.txt" ]] && TV_EXTENSION_DUP_MODE=$(cat "${CACHE_DIR}/tv_extension_dup_mode.txt") || TV_EXTENSION_DUP_MODE="off"
                        case "$TV_EXTENSION_DUP_MODE" in
                            off) TV_EXTENSION_DUP_MODE="bitrate" ;;
                            bitrate) TV_EXTENSION_DUP_MODE="resolution" ;;
                            resolution) TV_EXTENSION_DUP_MODE="off" ;;
                            *) TV_EXTENSION_DUP_MODE="off" ;;
                        esac
                        echo "$TV_EXTENSION_DUP_MODE" > "${CACHE_DIR}/tv_extension_dup_mode.txt"
                    # If on Image Resizer (index 19), cycle backward
                    elif [[ $selected_idx -eq 19 ]]; then
                        [[ -f "${CACHE_DIR}/image_resizer.txt" ]] && IMAGE_RESIZER=$(cat "${CACHE_DIR}/image_resizer.txt") || IMAGE_RESIZER="auto"
                        # Backward: auto → vips → sips → auto
                        case "$IMAGE_RESIZER" in
                            auto) IMAGE_RESIZER="vips" ;;
                            vips) IMAGE_RESIZER="sips" ;;
                            sips) IMAGE_RESIZER="auto" ;;
                            *) IMAGE_RESIZER="auto" ;;
                        esac
                        echo "$IMAGE_RESIZER" > "${CACHE_DIR}/image_resizer.txt"
                    # If on Round Resolution (index 23), toggle
                    elif [[ $selected_idx -eq 23 ]]; then
                        if [[ "$ROUND_RESOLUTION" == "yes" ]]; then
                            ROUND_RESOLUTION="no"
                        else
                            ROUND_RESOLUTION="yes"
                        fi
                        echo "$ROUND_RESOLUTION" > "${CACHE_DIR}/round_resolution.txt"
                    fi
                    ;;
                *) # ESC pressed (no arrow key) - treat as back/exit
                    tput cnorm 2>/dev/null
                    stty echo 2>/dev/null
                    clear
                    echo ""
                    echo -e "${YELLOW}Are you sure you want to exit? (y/n)${NC}"
                    read -r confirm_exit
                    if [[ "$confirm_exit" =~ ^[Yy]$ ]]; then
                        print_warning "Cancelled"
                        exit 0
                    fi
                    stty -echo 2>/dev/null
                    tput civis 2>/dev/null
                    ;;
            esac
        elif [[ "$key" == "b" ]] || [[ "$key" == "B" ]]; then
            # Go back to dependency check
            tput cnorm 2>/dev/null
            clear
            check_and_install_dependencies
            # After returning from dependency check, continue with menu
            continue
        elif [[ "$key" == "d" ]] || [[ "$key" == "D" ]]; then
            # Alternative dependency key (same as 'b')
            tput cnorm 2>/dev/null
            clear
            check_and_install_dependencies
            # After returning from dependency check, continue with menu
            continue
            clear
            check_and_install_dependencies
            # After returning from dependency check, continue with menu
            continue
        elif [[ "$key" == "" ]]; then
            # Enter - confirm selection
            tput cnorm 2>/dev/null
            clear
            
            if [[ $selected_idx -eq 0 ]]; then
                # Quick Movies - use saved settings, skip to cache selection
                tput civis 2>/dev/null
                
                # Check if required saved settings exist
                if [[ ! -f "${CACHE_DIR}/naming_scheme.txt" ]] || [[ ! -f "${CACHE_DIR}/link_type.txt" ]]; then
                    tput cnorm 2>/dev/null
                    echo ""
                    print_warning "No saved settings found!"
                    echo -e "${YELLOW}Quick Movies requires previously saved settings.${NC}"
                    echo -e "${CYAN}Please use 'Movies (Movie)' option first to configure your preferences.${NC}"
                    echo ""
                    echo -e "${DIM}Press any key to return to main menu...${NC}"
                    read -n 1 -s
                    continue
                fi
                
                # Load all saved settings from cache
                [[ -f "${CACHE_DIR}/naming_scheme.txt" ]] && NAMING_SCHEME=$(cat "${CACHE_DIR}/naming_scheme.txt")
                [[ -f "${CACHE_DIR}/link_type.txt" ]] && LINK_TYPE=$(cat "${CACHE_DIR}/link_type.txt")
                [[ -f "${CACHE_DIR}/extras_option.txt" ]] && EXTRAS_OPTION=$(cat "${CACHE_DIR}/extras_option.txt")
                [[ -f "${CACHE_DIR}/parallel_parsing.txt" ]] && PARALLEL_PARSING=$(cat "${CACHE_DIR}/parallel_parsing.txt")
                [[ -f "${CACHE_DIR}/use_mediainfo.txt" ]] && USE_MEDIAINFO=$(cat "${CACHE_DIR}/use_mediainfo.txt")
                
                # Parse naming scheme to extract folder and file format choices
                if [[ -f "${CACHE_DIR}/naming_scheme.txt" ]]; then
                    NAMING_FOLDER=$(sed -n '1p' "${CACHE_DIR}/naming_scheme.txt")
                    NAMING_FILE=$(sed -n '2p' "${CACHE_DIR}/naming_scheme.txt")
                fi
                
                # Load poster preference
                [[ -f "${CACHE_DIR}/poster_preference.txt" ]] && SHOW_MOVIE_POSTERS=$(cat "${CACHE_DIR}/poster_preference.txt")
                
                # Load link mode settings (copy/hardlink/symlink modes)
                if [[ -f "${CACHE_DIR}/copy_mode.txt" ]]; then
                    local copy_mode=$(cat "${CACHE_DIR}/copy_mode.txt")
                    [[ "$copy_mode" == "true" ]] && COPY_ENTIRE_FOLDER="true" || COPY_ENTIRE_FOLDER="false"
                fi
                if [[ -f "${CACHE_DIR}/extras_mode.txt" ]]; then
                    HARDLINK_EXTRAS=$(cat "${CACHE_DIR}/extras_mode.txt")
                fi
                
                # Load parsing method (AWK parser preference)
                [[ -f "${CACHE_DIR}/awk_parser.txt" ]] && AWK_PARSER=$(cat "${CACHE_DIR}/awk_parser.txt")
                
                # Set link type flags based on saved preference
                case "$LINK_TYPE" in
                    hardlink)
                        USE_HARDLINK="true"
                        USE_SYMLINK="false"
                        USE_COPY="false"
                        ;;
                    symlink)
                        USE_HARDLINK="false"
                        USE_SYMLINK="true"
                        USE_COPY="false"
                        ;;
                    copy)
                        USE_HARDLINK="false"
                        USE_SYMLINK="false"
                        USE_COPY="true"
                        ;;
                esac
                
                # Show movie cache selection
                if select_movie_cache_interactive; then
                    # Cache selected, proceed to drag-and-drop
                    break
                else
                    # User backed out, return to main menu
                    continue
                fi
            elif [[ $selected_idx -eq 1 ]]; then
                # Quick TV Shows - use saved settings, skip to cache selection  
                tput civis 2>/dev/null
                
                # Check if required saved TV settings exist
                if [[ ! -f "${CACHE_DIR}/tv_naming_scheme.txt" ]]; then
                    tput cnorm 2>/dev/null
                    stty echo 2>/dev/null
                    echo ""
                    print_warning "No saved TV settings found!"
                    echo -e "${YELLOW}Quick TV Shows requires previously saved settings.${NC}"
                    echo -e "${CYAN}Please use 'TV Shows (Series)' option first to configure your preferences.${NC}"
                    echo ""
                    echo -e "${DIM}Press any key to return to main menu...${NC}"
                    read -n 1 -s
                    stty -echo 2>/dev/null
                    continue
                fi
                
                # Set TV mode flag
                IS_TV_MODE=true
                
                # Load all saved TV settings from cache
                [[ -f "${CACHE_DIR}/tv_naming_scheme.txt" ]] && TV_NAMING_SCHEME=$(cat "${CACHE_DIR}/tv_naming_scheme.txt")
                [[ -f "${CACHE_DIR}/tv_link_type.txt" ]] && TV_LINK_TYPE=$(cat "${CACHE_DIR}/tv_link_type.txt")
                [[ -f "${CACHE_DIR}/tv_extras_option.txt" ]] && TV_EXTRAS_OPTION=$(cat "${CACHE_DIR}/tv_extras_option.txt")
                [[ -f "${CACHE_DIR}/parallel_parsing.txt" ]] && PARALLEL_PARSING=$(cat "${CACHE_DIR}/parallel_parsing.txt")
                [[ -f "${CACHE_DIR}/use_mediainfo.txt" ]] && USE_MEDIAINFO=$(cat "${CACHE_DIR}/use_mediainfo.txt")
                
                # Source TV naming scheme to load TV_NAMING_FOLDER and TV_NAMING_EPISODE variables
                if [[ -f "${CACHE_DIR}/tv_naming_scheme.txt" ]]; then
                    source "${CACHE_DIR}/tv_naming_scheme.txt"
                fi
                
                # Load poster preference
                [[ -f "${CACHE_DIR}/tv_poster_preference.txt" ]] && SHOW_TV_POSTERS=$(cat "${CACHE_DIR}/tv_poster_preference.txt")
                
                # Load TV episode renaming preference
                [[ -f "${CACHE_DIR}/tv_rename_episodes.txt" ]] && TV_RENAME_EPISODES=$(cat "${CACHE_DIR}/tv_rename_episodes.txt")
                
                # Load TV link mode settings
                if [[ -f "${CACHE_DIR}/tv_extras_mode.txt" ]]; then
                    TV_EXTRAS_HANDLING=$(cat "${CACHE_DIR}/tv_extras_mode.txt")
                fi
                
                # Load parsing method (AWK parser preference)
                [[ -f "${CACHE_DIR}/awk_parser.txt" ]] && AWK_PARSER=$(cat "${CACHE_DIR}/awk_parser.txt")
                
                # Set link type flags based on saved TV preference
                case "$TV_LINK_TYPE" in
                    hardlink)
                        USE_HARDLINK="true"
                        USE_SYMLINK="false"
                        USE_COPY="false"
                        ;;
                    symlink)
                        USE_HARDLINK="false"
                        USE_SYMLINK="true"
                        USE_COPY="false"
                        ;;
                    copy)
                        USE_HARDLINK="false"
                        USE_SYMLINK="false"
                        USE_COPY="true"
                        ;;
                esac
                
                # Show TV cache selection
                if select_tv_cache_interactive; then
                    # Cache selected, now run TV interactive mode in quick mode (skip settings prompts)
                    tput civis 2>/dev/null
                    if interactive_tv_mode "true"; then
                        # TV mode completed successfully, exit
                        exit 0
                    fi
                    # TV mode was cancelled, return to main menu
                    continue
                else
                    # User backed out, return to main menu
                    continue
                fi
            elif [[ $selected_idx -eq 2 ]]; then
                # Movie mode - continue with movie flow
                tput civis 2>/dev/null
                # Menu navigation loop for movies
                local movie_setup_done=false
                local current_menu="naming"
                local naming_start_step=1  # Track which step to start naming scheme at
                
                while true; do
                    case "$current_menu" in
                        naming)
                            # Select naming scheme (start at specified step)
                            if ! select_naming_scheme "$naming_start_step"; then
                                # User backed out from naming scheme, return to main menu
                                movie_setup_done=false
                                break
                            fi
                            naming_start_step=1  # Reset for next iteration
                            current_menu="link_type"
                            ;;
                        
                        link_type)
                            # Select link type
                            if ! select_link_type; then
                                # User backed out, go back to naming scheme at step 4 (cache - last step)
                                naming_start_step=4
                                current_menu="naming"
                            else
                                current_menu="mode"
                            fi
                            ;;
                        
                        mode)
                            # Show mode-specific menus based on link type
                            local mode_result=true
                            if [[ "$USE_COPY" == "true" ]]; then
                                # Copy mode menu
                                if ! select_copy_mode; then
                                    mode_result=false
                                fi
                            elif [[ "$USE_SYMLINK" == "true" ]]; then
                                # Symlink mode menu
                                if ! select_symlink_mode; then
                                    mode_result=false
                                fi
                            else
                                # Hardlink mode menu (default)
                                if ! select_hardlink_mode; then
                                    mode_result=false
                                fi
                            fi
                            
                            if [[ "$mode_result" == "false" ]]; then
                                # User backed out, go back to link type
                                current_menu="link_type"
                            else
                                # Hardlink/Symlink modes already set extras preferences, skip extras menu
                                # Copy mode with entire folder also skips extras menu
                                if [[ "$USE_COPY" == "true" ]] && [[ "$COPY_ENTIRE_FOLDER" != "true" ]]; then
                                    # Copy mode with individual files - show extras menu
                                    current_menu="extras"
                                else
                                    # Hardlink/Symlink modes or Copy entire folder - skip extras menu
                                    current_menu="parsing"
                                fi
                            fi
                            ;;
                        
                        extras)
                            # Select extras/bonus options (only for copy mode with individual files)
                            if ! select_extras_options; then
                                # User backed out, go back to the mode menu
                                current_menu="mode"
                            else
                                current_menu="parsing"
                            fi
                            ;;
                        
                        parsing)
                            # Select parsing mode
                            if ! select_parsing_mode; then
                                # User backed out, check if extras menu was shown
                                if [[ "$USE_COPY" == "true" ]] && [[ "$COPY_ENTIRE_FOLDER" != "true" ]]; then
                                    # Copy mode showed extras menu, go back to it
                                    current_menu="extras"
                                else
                                    # Extras was skipped, go back to mode menu
                                    current_menu="mode"
                                fi
                            else
                                current_menu="mediainfo"
                            fi
                            ;;
                        
                        mediainfo)
                            # Select MediaInfo tool
                            if select_mediainfo_tool; then
                                # All selections completed successfully
                                movie_setup_done=true
                                break
                            else
                                # User backed out, go back to parsing mode
                                current_menu="parsing"
                            fi
                            ;;
                    esac
                done
                
                # Check if movie setup was completed or user backed out
                if [[ "$movie_setup_done" != "true" ]]; then
                    # User backed out to main menu, continue mode selection loop
                    continue
                fi
                
                # Movie setup completed, proceed to file processing
                break
            elif [[ $selected_idx -eq 3 ]]; then
                # TV Show mode - run TV interactive mode
                tput civis 2>/dev/null
                if interactive_tv_mode; then
                    # TV mode completed successfully, exit
                    exit 0
                fi
                # TV mode was cancelled (user pressed back), return to mode selection
                # Loop will restart and show mode selection again
            elif [[ $selected_idx -eq 4 ]]; then
                # Parallel Processing - instant toggle without screen change
                # Load current setting
                [[ -f "${CACHE_DIR}/parallel_processing.txt" ]] && PARALLEL_PROCESSING=$(cat "${CACHE_DIR}/parallel_processing.txt")
                # Toggle
                if [[ "$PARALLEL_PROCESSING" == "true" ]]; then
                    PARALLEL_PROCESSING="false"
                    echo "false" > "${CACHE_DIR}/parallel_processing.txt"
                else
                    PARALLEL_PROCESSING="true"
                    echo "true" > "${CACHE_DIR}/parallel_processing.txt"
                fi
                # Menu will refresh automatically on next loop iteration
            elif [[ $selected_idx -eq 5 ]]; then
                # Parallel Jobs Count
                tput cnorm 2>/dev/null
                clear
                echo ""
                echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                echo -e "${CYAN}Set Parallel Jobs Count${NC}"
                echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                echo ""
                [[ -f "${CACHE_DIR}/parallel_jobs.txt" ]] && PARALLEL_JOBS=$(cat "${CACHE_DIR}/parallel_jobs.txt")
                echo -e "${DIM}Current: ${PARALLEL_JOBS} jobs${NC}"
                echo ""
                echo -e "${YELLOW}Enter number of parallel jobs (minimum: 2, recommended: 4-16):${NC}"
                stty echo
                read -r input_jobs
                stty -echo
                
                if [[ "$input_jobs" =~ ^[0-9]+$ ]] && [[ $input_jobs -ge 2 ]]; then
                    PARALLEL_JOBS=$input_jobs
                    echo "$PARALLEL_JOBS" > "${CACHE_DIR}/parallel_jobs.txt"
                    echo ""
                    if [[ $input_jobs -gt 64 ]]; then
                        echo -e "${YELLOW}⚠ Warning: ${input_jobs} jobs may consume significant system resources${NC}"
                    fi
                    echo -e "${GREEN}✓ Parallel jobs set to: ${PARALLEL_JOBS}${NC}"
                else
                    echo ""
                    echo -e "${RED}✗ Invalid input. Must be 2 or greater.${NC}"
                fi
                echo ""
                echo -e "${DIM}Press any key to continue...${NC}"
                read -rsn1
                tput civis 2>/dev/null
            elif [[ $selected_idx -eq 6 ]]; then
                # Rolling Queue Mode - instant toggle
                [[ -f "${CACHE_DIR}/rolling_queue_mode.txt" ]] && ROLLING_QUEUE_MODE=$(cat "${CACHE_DIR}/rolling_queue_mode.txt")
                if [[ "$ROLLING_QUEUE_MODE" == "true" ]]; then
                    ROLLING_QUEUE_MODE="false"
                    echo "false" > "${CACHE_DIR}/rolling_queue_mode.txt"
                else
                    ROLLING_QUEUE_MODE="true"
                    echo "true" > "${CACHE_DIR}/rolling_queue_mode.txt"
                fi
                # Menu will refresh automatically
            elif [[ $selected_idx -eq 7 ]]; then
                # Parallel Parsing - instant toggle
                [[ -f "${CACHE_DIR}/parallel_parsing.txt" ]] && PARALLEL_PARSING=$(cat "${CACHE_DIR}/parallel_parsing.txt")
                if [[ "$PARALLEL_PARSING" == "true" ]]; then
                    PARALLEL_PARSING="false"
                    echo "false" > "${CACHE_DIR}/parallel_parsing.txt"
                else
                    PARALLEL_PARSING="true"
                    echo "true" > "${CACHE_DIR}/parallel_parsing.txt"
                fi
                # Menu will refresh automatically
            elif [[ $selected_idx -eq 8 ]]; then
                # Parallel Parse Jobs Count
                tput cnorm 2>/dev/null
                clear
                echo ""
                echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                echo -e "${CYAN}Set Parallel Parse Jobs Count${NC}"
                echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                echo ""
                [[ -f "${CACHE_DIR}/parallel_parse_jobs.txt" ]] && PARALLEL_PARSE_JOBS=$(cat "${CACHE_DIR}/parallel_parse_jobs.txt")
                echo -e "${DIM}Current: ${PARALLEL_PARSE_JOBS} parse jobs${NC}"
                echo ""
                echo -e "${YELLOW}Enter number of parallel parse jobs (minimum: 2, recommended: 4-16):${NC}"
                stty echo
                read -r input_parse_jobs
                stty -echo
                
                if [[ "$input_parse_jobs" =~ ^[0-9]+$ ]] && [[ $input_parse_jobs -ge 2 ]]; then
                    PARALLEL_PARSE_JOBS=$input_parse_jobs
                    echo "$PARALLEL_PARSE_JOBS" > "${CACHE_DIR}/parallel_parse_jobs.txt"
                    echo ""
                    if [[ $input_parse_jobs -gt 64 ]]; then
                        echo -e "${YELLOW}⚠ Warning: ${input_parse_jobs} jobs may consume significant system resources${NC}"
                    fi
                    echo -e "${GREEN}✓ Parallel parse jobs set to: ${PARALLEL_PARSE_JOBS}${NC}"
                else
                    echo ""
                    echo -e "${RED}✗ Invalid input. Must be 2 or greater.${NC}"
                fi
                echo ""
                echo -e "${DIM}Press any key to continue...${NC}"
                read -rsn1
                tput civis 2>/dev/null
            elif [[ $selected_idx -eq 9 ]]; then
                # Parsing Rolling Queue - toggle (instant)
                [[ -f "${CACHE_DIR}/parsing_rolling_queue_mode.txt" ]] && PARSING_ROLLING_QUEUE_MODE=$(cat "${CACHE_DIR}/parsing_rolling_queue_mode.txt")
                if [[ "$PARSING_ROLLING_QUEUE_MODE" == "true" ]]; then
                    PARSING_ROLLING_QUEUE_MODE="false"
                else
                    PARSING_ROLLING_QUEUE_MODE="true"
                fi
                echo "$PARSING_ROLLING_QUEUE_MODE" > "${CACHE_DIR}/parsing_rolling_queue_mode.txt"
                # Menu will refresh automatically
            elif [[ $selected_idx -eq 10 ]]; then
                # JSON Database Mode - cycle through modes (instant)
                [[ -f "${CACHE_DIR}/json_db_mode.txt" ]] && JSON_DB_MODE=$(cat "${CACHE_DIR}/json_db_mode.txt")
                
                case "$JSON_DB_MODE" in
                    hybrid)
                        JSON_DB_MODE="json_only"
                        ;;
                    json_only)
                        JSON_DB_MODE="api_only"
                        ;;
                    api_only)
                        JSON_DB_MODE="hybrid"
                        ;;
                    *)
                        JSON_DB_MODE="hybrid"
                        ;;
                esac
                echo "$JSON_DB_MODE" > "${CACHE_DIR}/json_db_mode.txt"
                # Menu will refresh automatically
            elif [[ $selected_idx -eq 11 ]]; then
                # Cache Management
                tput civis 2>/dev/null
                show_cache_management_menu
                # Return to main menu after cache management
            elif [[ $selected_idx -eq 12 ]]; then
                # Debug Mode: Movies - cycle through off/low/medium/high (instant)
                # Load current setting
                local current_level="off"
                if [[ -f "${CACHE_DIR}/debug_mode_movies.txt" ]]; then
                    local value=$(cat "${CACHE_DIR}/debug_mode_movies.txt")
                    case "$value" in
                        true) current_level="high" ;;
                        false) current_level="off" ;;
                        off|low|medium|high) current_level="$value" ;;
                    esac
                fi
                # Cycle to next level: off → low → medium → high → off
                case "$current_level" in
                    off) DEBUG_LEVEL_MOVIES="low" ;;
                    low) DEBUG_LEVEL_MOVIES="medium" ;;
                    medium) DEBUG_LEVEL_MOVIES="high" ;;
                    high) DEBUG_LEVEL_MOVIES="off" ;;
                esac
                echo "$DEBUG_LEVEL_MOVIES" > "${CACHE_DIR}/debug_mode_movies.txt"
                # Update backward compat variable
                [[ "$DEBUG_LEVEL_MOVIES" != "off" ]] && DEBUG_MODE_MOVIES="true" || DEBUG_MODE_MOVIES="false"
                # Menu will refresh automatically
            elif [[ $selected_idx -eq 13 ]]; then
                # Debug Mode: TV Shows - cycle through off/low/medium/high (instant)
                # Load current setting
                local current_level="off"
                if [[ -f "${CACHE_DIR}/debug_mode_tv.txt" ]]; then
                    local value=$(cat "${CACHE_DIR}/debug_mode_tv.txt")
                    case "$value" in
                        true) current_level="high" ;;
                        false) current_level="off" ;;
                        off|low|medium|high) current_level="$value" ;;
                    esac
                fi
                # Cycle to next level: off → low → medium → high → off
                case "$current_level" in
                    off) DEBUG_LEVEL_TV="low" ;;
                    low) DEBUG_LEVEL_TV="medium" ;;
                    medium) DEBUG_LEVEL_TV="high" ;;
                    high) DEBUG_LEVEL_TV="off" ;;
                esac
                echo "$DEBUG_LEVEL_TV" > "${CACHE_DIR}/debug_mode_tv.txt"
                # Update backward compat variable
                [[ "$DEBUG_LEVEL_TV" != "off" ]] && DEBUG_MODE_TV="true" || DEBUG_MODE_TV="false"
                # Menu will refresh automatically
            elif [[ $selected_idx -eq 14 ]]; then
                # Diagnostics Mode - instant toggle
                # Load current setting
                [[ -f "${CACHE_DIR}/diagnostics_mode.txt" ]] && DIAGNOSTICS_MODE=$(cat "${CACHE_DIR}/diagnostics_mode.txt")
                # Toggle
                if [[ "$DIAGNOSTICS_MODE" == "true" ]]; then
                    DIAGNOSTICS_MODE="false"
                    echo "false" > "${CACHE_DIR}/diagnostics_mode.txt"
                else
                    DIAGNOSTICS_MODE="true"
                    echo "true" > "${CACHE_DIR}/diagnostics_mode.txt"
                fi
                # Menu will refresh automatically
            elif [[ $selected_idx -eq 15 ]]; then
                # API Delay - same as in settings menu
                tput cnorm 2>/dev/null
                clear
                echo ""
                echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                echo -e "${CYAN}API DELAY CONFIGURATION${NC}"
                echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                echo ""
                echo -e "${DIM}Current delay: ${API_DELAY}s${NC}"
                echo ""
                echo -e "${YELLOW}Delay between API calls (in seconds):${NC}"
                echo -e "${DIM}  • 0.25 = Fast (recommended for personal use)${NC}"
                echo -e "${DIM}  • 0.5  = Moderate${NC}"
                echo -e "${DIM}  • 1.0  = Safe (conservative)${NC}"
                echo ""
                echo -e "${YELLOW}Enter delay (0.1-5.0 seconds):${NC}"
                stty echo
                read -r input_delay
                stty -echo
                
                if [[ "$input_delay" =~ ^[0-9]+\.?[0-9]*$ ]]; then
                    if command -v bc &> /dev/null; then
                        if (( $(echo "$input_delay >= 0.1" | bc -l) )) && (( $(echo "$input_delay <= 5.0" | bc -l) )); then
                            API_DELAY=$input_delay
                            echo "$API_DELAY" > "${CACHE_DIR}/api_delay.txt"
                            echo ""
                            echo -e "${GREEN}✓ API delay set to: ${API_DELAY}s${NC}"
                        else
                            echo ""
                            echo -e "${RED}✗ Invalid input. Must be between 0.1 and 5.0 seconds.${NC}"
                        fi
                    else
                        API_DELAY=$input_delay
                        echo "$API_DELAY" > "${CACHE_DIR}/api_delay.txt"
                        echo ""
                        echo -e "${GREEN}✓ API delay set to: ${API_DELAY}s${NC}"
                    fi
                else
                    echo ""
                    echo -e "${RED}✗ Invalid input. Please enter a number.${NC}"
                fi
                echo ""
                echo -e "${DIM}Press any key to continue...${NC}"
                read -rsn1
                tput civis 2>/dev/null
            elif [[ $selected_idx -eq 16 ]]; then
                # AWK Parser - toggle cycle through installed parsers (instant)
                [[ -f "${CACHE_DIR}/awk_parser.txt" ]] && AWK_PARSER=$(cat "${CACHE_DIR}/awk_parser.txt") || AWK_PARSER="awk"
                
                # Cycle forward through available parsers
                case "$AWK_PARSER" in
                    awk)
                        if command -v gawk &> /dev/null; then
                            AWK_PARSER="gawk"
                        elif command -v mawk &> /dev/null; then
                            AWK_PARSER="mawk"
                        fi
                        ;;
                    gawk)
                        if command -v mawk &> /dev/null; then
                            AWK_PARSER="mawk"
                        else
                            AWK_PARSER="awk"
                        fi
                        ;;
                    mawk) AWK_PARSER="awk" ;;
                esac
                echo "$AWK_PARSER" > "${CACHE_DIR}/awk_parser.txt"
                # Menu will refresh automatically
            elif [[ $selected_idx -eq 17 ]]; then
                # Extension Duplicate Mode - cycle through off/resolution/bitrate
                [[ -f "${CACHE_DIR}/extension_dup_mode.txt" ]] && EXTENSION_DUP_MODE=$(cat "${CACHE_DIR}/extension_dup_mode.txt") || EXTENSION_DUP_MODE="off"
                
                # Cycle forward through modes
                case "$EXTENSION_DUP_MODE" in
                    off) EXTENSION_DUP_MODE="resolution" ;;
                    resolution) EXTENSION_DUP_MODE="bitrate" ;;
                    bitrate) EXTENSION_DUP_MODE="off" ;;
                    *) EXTENSION_DUP_MODE="off" ;;
                esac
                echo "$EXTENSION_DUP_MODE" > "${CACHE_DIR}/extension_dup_mode.txt"
                # Menu will refresh automatically
            elif [[ $selected_idx -eq 18 ]]; then
                # TV Extension Duplicate Mode - cycle through off/resolution/bitrate
                [[ -f "${CACHE_DIR}/tv_extension_dup_mode.txt" ]] && TV_EXTENSION_DUP_MODE=$(cat "${CACHE_DIR}/tv_extension_dup_mode.txt") || TV_EXTENSION_DUP_MODE="off"
                
                # Cycle forward through modes
                case "$TV_EXTENSION_DUP_MODE" in
                    off) TV_EXTENSION_DUP_MODE="resolution" ;;
                    resolution) TV_EXTENSION_DUP_MODE="bitrate" ;;
                    bitrate) TV_EXTENSION_DUP_MODE="off" ;;
                    *) TV_EXTENSION_DUP_MODE="off" ;;
                esac
                echo "$TV_EXTENSION_DUP_MODE" > "${CACHE_DIR}/tv_extension_dup_mode.txt"
                # Menu will refresh automatically
            elif [[ $selected_idx -eq 19 ]]; then
                # Image Resizer - toggle cycle through available tools (instant)
                [[ -f "${CACHE_DIR}/image_resizer.txt" ]] && IMAGE_RESIZER=$(cat "${CACHE_DIR}/image_resizer.txt") || IMAGE_RESIZER="auto"
                
                # Cycle forward through tools: auto → sips → vips
                case "$IMAGE_RESIZER" in
                    auto) IMAGE_RESIZER="sips" ;;
                    sips) IMAGE_RESIZER="vips" ;;
                    vips) IMAGE_RESIZER="auto" ;;
                    *) IMAGE_RESIZER="auto" ;;
                esac
                echo "$IMAGE_RESIZER" > "${CACHE_DIR}/image_resizer.txt"
                # Menu will refresh automatically
            elif [[ $selected_idx -eq 20 ]]; then
                # Test API Connection
                tput cnorm 2>/dev/null
                clear
                echo ""
                echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                echo -e "${CYAN}TEST API CONNECTION${NC}"
                echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                echo ""
                echo -e "${YELLOW}Testing TMDb API connection...${NC}"
                echo ""
                
                # Array of popular movies for random testing
                local -a test_movies=(
                    "Avatar|2009"
                    "The Shawshank Redemption|1994"
                    "The Godfather|1972"
                    "The Dark Knight|2008"
                    "Inception|2010"
                    "Fight Club|1999"
                    "Forrest Gump|1994"
                    "The Matrix|1999"
                    "Interstellar|2014"
                    "Pulp Fiction|1994"
                    "The Lord of the Rings|2001"
                    "Titanic|1997"
                    "Jurassic Park|1993"
                    "Star Wars|1977"
                    "Back to the Future|1985"
                )
                
                # Select random movie
                local random_idx=$((RANDOM % ${#test_movies[@]}))
                local test_movie="${test_movies[$random_idx]}"
                local test_query=$(echo "$test_movie" | cut -d'|' -f1)
                local test_year=$(echo "$test_movie" | cut -d'|' -f2)
                
                echo -e "${DIM}Testing with: ${test_query} (${test_year})${NC}"
                echo ""
                
                local test_start=$SECONDS
                local test_result=$(curl -s --connect-timeout 10 --max-time 30 "${TMDB_API_BASE}/search/movie?api_key=${TMDB_API_KEY}&query=$(echo "$test_query" | sed 's/ /%20/g')&year=${test_year}" 2>/dev/null)
                local test_time=$((SECONDS - test_start))
                
                if [[ -n "$test_result" ]] && echo "$test_result" | grep -q '"id"'; then
                    echo -e "${GREEN}✓ API connection successful!${NC}"
                    echo ""
                    echo -e "${DIM}Response time: ${test_time}s${NC}"
                    
                    local movie_id=$(echo "$test_result" | grep -oE '"id":[0-9]+' | head -1 | grep -oE '[0-9]+')
                    local movie_title=$(echo "$test_result" | grep -oE '"title":"[^"]+' | head -1 | cut -d'"' -f4)
                    
                    if [[ -n "$movie_id" && -n "$movie_title" ]]; then
                        echo -e "${DIM}Test search found: ${movie_title} (TMDb ID: ${movie_id})${NC}"
                    fi
                elif echo "$test_result" | grep -q "Invalid API key"; then
                    echo -e "${RED}✗ API key invalid!${NC}"
                    echo ""
                    echo -e "${YELLOW}Please update your TMDb API key.${NC}"
                else
                    echo -e "${RED}✗ API connection failed!${NC}"
                    echo ""
                    echo -e "${YELLOW}Please check:${NC}"
                    echo -e "${DIM}  • Your internet connection${NC}"
                    echo -e "${DIM}  • Your API key is valid${NC}"
                    echo -e "${DIM}  • TMDb service is online${NC}"
                fi
                
                echo ""
                echo -e "${DIM}Press any key to continue...${NC}"
                read -rsn1
                tput civis 2>/dev/null
            elif [[ $selected_idx -eq 21 ]]; then
                # API Settings
                tput civis 2>/dev/null
                show_settings_menu
                # Return to main menu after settings
            elif [[ $selected_idx -eq 22 ]]; then
                # OS Settings
                tput civis 2>/dev/null
                clear
                echo ""
                echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                echo -e "${CYAN}CHANGE OPERATING SYSTEM${NC}"
                echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                echo ""
                
                # Load current OS
                if [[ -f "${CACHE_DIR}/selected_os.txt" ]]; then
                    SELECTED_OS=$(cat "${CACHE_DIR}/selected_os.txt")
                    echo -e "${DIM}Current OS: ${CYAN}${SELECTED_OS}${NC}"
                else
                    echo -e "${DIM}No OS selected yet${NC}"
                fi
                echo ""
                echo -e "${YELLOW}Would you like to change your operating system selection? (y/n)${NC}"
                echo -e "${DIM}This will affect which package manager and dependencies are shown.${NC}"
                echo ""
                
                tput cnorm 2>/dev/null
                stty echo
                read -r change_os
                stty -echo
                
                if [[ "$change_os" =~ ^[Yy]$ ]]; then
                    # Remove saved OS to force selection
                    rm -f "${CACHE_DIR}/selected_os.txt" 2>/dev/null
                    # Call OS selection menu
                    select_operating_system
                    # Restore terminal state after OS selection
                    stty -echo
                    tput civis 2>/dev/null
                    echo ""
                    echo -e "${GREEN}✓ OS updated to: ${SELECTED_OS}${NC}"
                    echo ""
                    echo -e "${DIM}Press any key to return to main menu...${NC}"
                    read -rsn1
                fi
                tput civis 2>/dev/null
            elif [[ $selected_idx -eq 23 ]]; then
                # Round Resolution - toggle setting
                if [[ "$ROUND_RESOLUTION" == "yes" ]]; then
                    ROUND_RESOLUTION="no"
                else
                    ROUND_RESOLUTION="yes"
                fi
                echo "$ROUND_RESOLUTION" > "${CACHE_DIR}/round_resolution.txt"
            fi
        fi
    done
    
    # Cache selection is now handled within the menu loop for Quick options
    # Regular Movies/TV Shows options handle cache selection within their own flows
    
    stty echo 2>/dev/null
    print_info "Drag and drop source(s) - multiple files/folders and press (ENTER/RETURN) multiple sources separated by spaces automatically:"
    read -r SOURCE_INPUT
    
    print_info "Drag and drop only ONE destination folder and press ENTER/RETURN:"
    read -r DESTINATION
    DESTINATION=$(echo "$DESTINATION" | sed "s/^['\"]//;s/['\"]$//;s/\\\\ / /g;s/\\\\$//;s/[[:space:]]*$//")
    
    if [[ ! -d "$DESTINATION" ]]; then
        print_error "Destination must be a directory"
        exit 1
    fi
    
    # Parse multiple sources from input
    local -a SOURCES=()
    
    # Remove leading/trailing whitespace
    SOURCE_INPUT="${SOURCE_INPUT#"${SOURCE_INPUT%%[![:space:]]*}"}"
    SOURCE_INPUT="${SOURCE_INPUT%"${SOURCE_INPUT##*[![:space:]]}"}"
    
    # Remove quotes if present
    SOURCE_INPUT="${SOURCE_INPUT#\"}"
    SOURCE_INPUT="${SOURCE_INPUT%\"}"
    SOURCE_INPUT="${SOURCE_INPUT#\'}"
    SOURCE_INPUT="${SOURCE_INPUT%\'}"
    
    # Check if input contains backslash-escaped spaces (drag-and-drop)
    if [[ "$SOURCE_INPUT" =~ \\\  ]]; then
        should_debug high && echo "[DEBUG] SOURCE_INPUT with escaped spaces: '$SOURCE_INPUT'" >&2
        
        # Split on unescaped spaces (spaces not preceded by backslash)
        # This separates multiple files while preserving spaces within filenames
        local temp_input="$SOURCE_INPUT"
        local current_part=""
        local i=0
        
        while [[ $i -lt ${#temp_input} ]]; do
            local char="${temp_input:$i:1}"
            local next_char="${temp_input:$((i+1)):1}"
            
            if [[ "$char" == "\\" && -n "$next_char" ]]; then
                # Escaped character - check what it is
                if [[ "$next_char" == " " ]]; then
                    # Escaped space - separates multiple paths, so add space to current part
                    current_part+=" "
                    ((i+=2))
                else
                    # Other escaped character (like \( or \)) - just add the character without backslash
                    current_part+="$next_char"
                    ((i+=2))
                fi
            elif [[ "$char" == " " ]]; then
                # Unescaped space - end of current path
                if [[ -n "$current_part" ]]; then
                    # Remove quotes if present
                    current_part="${current_part#\"}"
                    current_part="${current_part%\"}"
                    current_part="${current_part#\'}"
                    current_part="${current_part%\'}"
                    should_debug high && echo "[DEBUG] Found source: '$current_part'" >&2
                    SOURCES+=("$current_part")
                    current_part=""
                fi
                ((i++))
            else
                # Regular character
                current_part+="$char"
                ((i++))
            fi
        done
        
        # Add the last part
        if [[ -n "$current_part" ]]; then
            current_part="${current_part#\"}"
            current_part="${current_part%\"}"
            current_part="${current_part#\'}"
            current_part="${current_part%\'}"
            should_debug high && echo "[DEBUG] Found source: '$current_part'" >&2
            SOURCES+=("$current_part")
        fi
    else
        # Pasted path: treat as single path (may contain spaces)
        if [[ -e "$SOURCE_INPUT" ]]; then
            # Single path exists
            SOURCES+=("$SOURCE_INPUT")
        else
            # Might be multiple space-separated paths, try splitting
            IFS=' ' read -ra temp_sources <<< "$SOURCE_INPUT"
            for source in "${temp_sources[@]}"; do
                [[ -z "$source" ]] && continue
                source="${source#\"}"
                source="${source%\"}"
                source="${source#\'}"
                source="${source%\'}"
                [[ -n "$source" ]] && SOURCES+=("$source")
            done
        fi
    fi
    
    if [[ ${#SOURCES[@]} -eq 0 ]]; then
        print_error "No sources provided"
        exit 1
    fi
    
    print_success "Found ${#SOURCES[@]} source(s) to process"
    echo ""
    
    # Ask once for auto-processing mode
    stty echo 2>/dev/null
    print_info "Process all files automatically? (y/n):"
    read -r AUTO_MODE
    echo ""
    
    # Array to track failed ID lookups
    local -a FAILED_LOOKUPS=()
    
    # Array to track failed hardlinks
    local -a FAILED_HARDLINKS=()
    
    # Array to track files that couldn't be parsed (no title/year detected)
    local -a FAILED_PARSE=()
    
    # Array to track rejected files with reasons (format: "file_path|||reason")
    # Note: NOT using 'local' so it's accessible across function calls and in statistics
    REJECTED_FILES=()
    
    # Array to track all duplicate files across all sources
    local -a ALL_DUPLICATE_FILES=()
    
    # Array to collect all video files from all sources
    local -a ALL_VIDEO_FILES=()
    
    # First pass: collect all video files from all sources
    print_info "Collecting video files from all sources..."
    echo ""
    
    # Set cache file BEFORE capturing the before count
    set_cache_by_resolution ""
    
    # Track cache entries before processing
    local cache_entries_before=0
    [[ -f "$CACHE_FILE" ]] && cache_entries_before=$(awk 'NF' "$CACHE_FILE" 2>/dev/null | wc -l | tr -d ' ' || echo 0)
    echo "$cache_entries_before" > "${CACHE_DIR}/movie_cache_before.txt"
    
    # Track overall statistics across all sources
    local overall_start_time=$SECONDS
    local overall_size=0
    local overall_success=0
    local overall_failed=0
    
    for SOURCE in "${SOURCES[@]}"; do
        # Sources are already properly parsed above, no need for additional sed
        
        if [[ ! -e "$SOURCE" ]]; then
            print_error "Source not found: $SOURCE"
            ((total_failed++))
            continue
        fi
        
        print_info "========================================="
        print_info "Processing source: $SOURCE"
        print_info "========================================="
        echo ""
        
        # Skip if SOURCE itself is an extras/bonus/featurettes folder
        if [[ "$SOURCE" =~ (extras|extra|bonus|bonuses|featurette|featurettes|behind.?the.?scenes|bts|interviews?|deleted.?scenes|sample|samples|proof) ]]; then
            print_warning "Skipping extras/bonus folder: $(basename "$SOURCE")"
            ((total_skipped++))
            continue
        fi
        
        # Handle copy entire folder mode
        if [[ "$COPY_ENTIRE_FOLDER" == "true" ]] && [[ -d "$SOURCE" ]]; then
            local source_basename=$(basename "$SOURCE")
            local dest_folder="$DESTINATION/$source_basename"
            
            print_info "Copying entire folder: $source_basename"
            print_info "Destination: $dest_folder"
            
            # Create destination if it doesn't exist
            if [[ ! -d "$dest_folder" ]]; then
                mkdir -p "$dest_folder"
            fi
            
            # Copy entire folder recursively with verbose output
            if cp -Rv "$SOURCE/" "$dest_folder/"; then
                print_success "Successfully copied folder and all contents"
                ((total_success++))
            else
                print_error "Failed to copy folder"
                ((total_failed++))
            fi
            
            echo ""
            continue
        fi
        
        # Handle hardlink entire folder mode
        if [[ "$HARDLINK_ENTIRE_FOLDER" == "true" ]] && [[ -d "$SOURCE" ]]; then
            local source_basename=$(basename "$SOURCE")
            local dest_folder="$DESTINATION/$source_basename"
            
            print_info "Hardlinking entire folder structure: $source_basename"
            print_info "Destination: $dest_folder"
            
            # Create destination if it doesn't exist
            if [[ ! -d "$dest_folder" ]]; then
                mkdir -p "$dest_folder"
            fi
            
            # Recursively hardlink all files, preserving directory structure (skip sample files)
            local hardlink_count=0
            local hardlink_failed=0
            local hardlink_skipped=0
            while IFS= read -r -d '' source_file; do
                # Skip sample files
                local lowercase_basename=$(basename "$source_file" | tr '[:upper:]' '[:lower:]')
                if [[ "$lowercase_basename" =~ sample ]]; then
                    ((hardlink_skipped++))
                    continue
                fi
                
                # Get relative path from source root
                local rel_path="${source_file#$SOURCE/}"
                local dest_file="$dest_folder/$rel_path"
                local dest_dir=$(dirname "$dest_file")
                
                # Create destination directory if needed
                if [[ ! -d "$dest_dir" ]]; then
                    mkdir -p "$dest_dir"
                fi
                
                # Try to hardlink the file
                if ln "$source_file" "$dest_file" 2>/dev/null; then
                    ((hardlink_count++))
                else
                    print_warning "Failed to hardlink: $rel_path"
                    ((hardlink_failed++))
                fi
            done < <(find "$SOURCE" -type f -print0)
            
            if [[ $hardlink_count -gt 0 ]]; then
                print_success "Successfully hardlinked $hardlink_count files"
                if [[ $hardlink_failed -gt 0 ]]; then
                    print_warning "$hardlink_failed files failed to hardlink"
                fi
                ((total_success++))
            else
                print_error "Failed to hardlink folder"
                ((total_failed++))
            fi
            
            echo ""
            continue
        fi
        
        # Handle symlink entire folder mode
        if [[ "$SYMLINK_ENTIRE_FOLDER" == "true" ]] && [[ -d "$SOURCE" ]]; then
            local source_basename=$(basename "$SOURCE")
            local dest_folder="$DESTINATION/$source_basename"
            
            print_info "Symlinking entire folder structure: $source_basename"
            print_info "Destination: $dest_folder"
            
            # Create destination if it doesn't exist
            if [[ ! -d "$dest_folder" ]]; then
                mkdir -p "$dest_folder"
            fi
            
            # Recursively symlink all files, preserving directory structure (skip sample files)
            local symlink_count=0
            local symlink_failed=0
            local symlink_skipped=0
            while IFS= read -r -d '' source_file; do
                # Skip sample files
                local lowercase_basename=$(basename "$source_file" | tr '[:upper:]' '[:lower:]')
                if [[ "$lowercase_basename" =~ sample ]]; then
                    ((symlink_skipped++))
                    continue
                fi
                
                # Get relative path from source root
                local rel_path="${source_file#$SOURCE/}"
                local dest_file="$dest_folder/$rel_path"
                local dest_dir=$(dirname "$dest_file")
                
                # Create destination directory if needed
                if [[ ! -d "$dest_dir" ]]; then
                    mkdir -p "$dest_dir"
                fi
                
                # Create symlink
                if ln -s "$source_file" "$dest_file" 2>/dev/null; then
                    ((symlink_count++))
                else
                    print_warning "Failed to symlink: $rel_path"
                    ((symlink_failed++))
                fi
            done < <(find "$SOURCE" -type f -print0)
            
            if [[ $symlink_count -gt 0 ]]; then
                print_success "Successfully symlinked $symlink_count files"
                if [[ $symlink_skipped -gt 0 ]]; then
                    print_info "Skipped $symlink_skipped sample files"
                fi
                if [[ $symlink_failed -gt 0 ]]; then
                    print_warning "$symlink_failed files failed to symlink"
                fi
                ((total_success++))
            else
                print_error "Failed to symlink folder"
                ((total_failed++))
            fi
            
            echo ""
            continue
        fi
        
        # Check if source is directory or file
        if [[ -f "$SOURCE" ]]; then
            # Single file provided
            print_info "Processing single file: $SOURCE"
            VIDEO_FILES=("$SOURCE")
            print_success "Found 1 video file"
            
            # Add to global array
            ALL_VIDEO_FILES+=("${VIDEO_FILES[@]}")
        elif [[ -d "$SOURCE" ]]; then
            print_info "Processing directory: $SOURCE"
            
            # Build find command with optional extras folder exclusions
            local find_cmd="find \"$SOURCE\""
            
            # If extras linking is disabled, exclude extras folders from scan entirely (case-insensitive)
            if [[ "$HARDLINK_EXTRAS" == "false" ]]; then
                print_info "Searching for video files (excluding Extras/Bonus/Featurettes subfolders)..."
                find_cmd+=" \\( -ipath \"*/behind the scenes\" -o"
                find_cmd+=" -ipath \"*/behind the scenes/*\" -o"
                find_cmd+=" -ipath \"*/behind the scene\" -o"
                find_cmd+=" -ipath \"*/behind the scene/*\" -o"
                find_cmd+=" -ipath \"*/deleted scenes\" -o"
                find_cmd+=" -ipath \"*/deleted scenes/*\" -o"
                find_cmd+=" -ipath \"*/deleted scene\" -o"
                find_cmd+=" -ipath \"*/deleted scene/*\" -o"
                find_cmd+=" -ipath \"*/interviews\" -o"
                find_cmd+=" -ipath \"*/interviews/*\" -o"
                find_cmd+=" -ipath \"*/interview\" -o"
                find_cmd+=" -ipath \"*/interview/*\" -o"
                find_cmd+=" -ipath \"*/scenes\" -o"
                find_cmd+=" -ipath \"*/scenes/*\" -o"
                find_cmd+=" -ipath \"*/samples\" -o"
                find_cmd+=" -ipath \"*/samples/*\" -o"
                find_cmd+=" -ipath \"*/sample\" -o"
                find_cmd+=" -ipath \"*/sample/*\" -o"
                find_cmd+=" -ipath \"*/shorts\" -o"
                find_cmd+=" -ipath \"*/shorts/*\" -o"
                find_cmd+=" -ipath \"*/short\" -o"
                find_cmd+=" -ipath \"*/short/*\" -o"
                find_cmd+=" -ipath \"*/featurettes\" -o"
                find_cmd+=" -ipath \"*/featurettes/*\" -o"
                find_cmd+=" -ipath \"*/featurette\" -o"
                find_cmd+=" -ipath \"*/featurette/*\" -o"
                find_cmd+=" -ipath \"*/clips\" -o"
                find_cmd+=" -ipath \"*/clips/*\" -o"
                find_cmd+=" -ipath \"*/clip\" -o"
                find_cmd+=" -ipath \"*/clip/*\" -o"
                find_cmd+=" -ipath \"*/other\" -o"
                find_cmd+=" -ipath \"*/other/*\" -o"
                find_cmd+=" -ipath \"*/extras\" -o"
                find_cmd+=" -ipath \"*/extras/*\" -o"
                find_cmd+=" -ipath \"*/extra\" -o"
                find_cmd+=" -ipath \"*/extra/*\" -o"
                find_cmd+=" -ipath \"*/bonus\" -o"
                find_cmd+=" -ipath \"*/bonus/*\" -o"
                find_cmd+=" -ipath \"*/bonuses\" -o"
                find_cmd+=" -ipath \"*/bonuses/*\" -o"
                find_cmd+=" -ipath \"*/trailers\" -o"
                find_cmd+=" -ipath \"*/trailers/*\" -o"
                find_cmd+=" -ipath \"*/trailer\" -o"
                find_cmd+=" -ipath \"*/trailer/*\" \\) -prune -o"
            else
                print_info "Searching for video files..."
            fi
            
            find_cmd+=" -type f \\( -iname \"*.mkv\" -o -iname \"*.mp4\" -o -iname \"*.avi\" -o -iname \"*.m4v\" -o -iname \"*.mov\" -o -iname \"*.vob\" -o -iname \"*.wmv\" -o -iname \"*.flv\" -o -iname \"*.webm\" -o -iname \"*.ts\" -o -iname \"*.m2ts\" -o -iname \"*.mpg\" -o -iname \"*.mpeg\" -o -iname \"*.divx\" -o -iname \"*.xvid\" -o -iname \"*.iso\" \\) -print0"
            
            # Find video files - skip samples and extras from main processing
            VIDEO_FILES=()
            local skipped_samples=0
            local skipped_extras=0
            while IFS= read -r -d '' file; do
                # Check for interrupt every few files
                check_interrupt
                
                local lowercase_path=$(echo "$file" | tr '[:upper:]' '[:lower:]')
                local lowercase_basename=$(basename "$file" | tr '[:upper:]' '[:lower:]')
                
                # Skip Subs/Subtitles folders - subtitle files are handled separately
                if [[ "$lowercase_path" =~ /subs?/ ]] || [[ "$lowercase_path" =~ /subtitles/ ]]; then
                    continue
                fi
                
                # Skip sample files
                if [[ "$lowercase_basename" =~ sample ]]; then
                    echo "  ✗ Skipping sample file: $(basename "$file") (in: $(dirname "$file"))" >&2
                    ((skipped_samples++))
                    continue
                fi
                
                # Skip extras/featurettes/bonus content from main movie processing
                # Check if path contains extras-related folder names (case-insensitive)
                # Use word boundaries to avoid false positives like "Extractors" or "The Interview"
                if [[ "$lowercase_path" =~ /extras[-_.]?[^/]*/ ]] || \
                   [[ "$lowercase_path" =~ /extras$ ]] || \
                   [[ "$lowercase_path" =~ [^a-z]extras[-_.]?[^/]*/ ]] || \
                   [[ "$lowercase_path" =~ /featurettes?[-_.]?[^/]*/ ]] || \
                   [[ "$lowercase_path" =~ /featurettes?$ ]] || \
                   [[ "$lowercase_path" =~ /bonus(es)?[-_.]?[^/]*/ ]] || \
                   [[ "$lowercase_path" =~ /bonus(es)?$ ]] || \
                   [[ "$lowercase_path" =~ /deleted[[:space:]]scenes?/ ]] || \
                   [[ "$lowercase_path" =~ /behind[[:space:]]the[[:space:]]scenes?/ ]] || \
                   [[ "$lowercase_path" =~ /interviews[-_.]?[^/]*/ ]] || \
                   [[ "$lowercase_path" =~ /interviews$ ]] || \
                   [[ "$lowercase_path" =~ /trailers?[-_.]?[^/]*/ ]] || \
                   [[ "$lowercase_path" =~ /trailers?$ ]] || \
                   [[ "$lowercase_path" =~ /clips?[-_.]?[^/]*/ ]] || \
                   [[ "$lowercase_path" =~ /clips?$ ]] || \
                   [[ "$lowercase_path" =~ /shorts?[-_.]?[^/]*/ ]] || \
                   [[ "$lowercase_path" =~ /shorts?$ ]] || \
                   [[ "$lowercase_basename" =~ ^trailer ]] || \
                   [[ "$lowercase_basename" =~ [.-]trailer[.-] ]]; then
                    echo "  ✗ Skipping extras file: $(basename "$file") (in: $(dirname "$file"))" >&2
                    ((skipped_extras++))
                    continue
                fi
                
                VIDEO_FILES+=("$file")
            done < <(eval "$find_cmd")
            
            # Show skip statistics
            if [ $skipped_samples -gt 0 ]; then
                echo "" >&2
                echo "[SKIP SUMMARY] Skipped $skipped_samples sample file(s)" >&2
            fi
            if [ $skipped_extras -gt 0 ]; then
                echo "[SKIP SUMMARY] Skipped $skipped_extras extras/featurettes file(s)" >&2
            fi
            
            if [[ ${#VIDEO_FILES[@]} -eq 0 ]]; then
                print_warning "No video files found in: $SOURCE"
                continue
            fi
            
            print_success "Found ${#VIDEO_FILES[@]} video file(s) in $(basename "$SOURCE")"
            should_debug high && echo "[DEBUG] Files found in source '$SOURCE':" >&2
            should_debug high && for vf in "${VIDEO_FILES[@]}"; do echo "[DEBUG]   - $vf" >&2; done
            
            # Add to global array
            ALL_VIDEO_FILES+=("${VIDEO_FILES[@]}")
        else
            print_error "Source is neither a file nor a directory: $SOURCE"
            continue
        fi
    done
    
    # Check if we collected any files at all
    if [[ ${#ALL_VIDEO_FILES[@]} -eq 0 ]]; then
        print_error "No video files found in any source"
        exit 1
    fi
    
    # Sort files alphabetically by basename (filename only), case-insensitive
    IFS=$'\n' ALL_VIDEO_FILES=($(for f in "${ALL_VIDEO_FILES[@]}"; do echo "$f"; done | awk -F'/' '{print $NF"\t"$0}' | sort -f -k1 | cut -f2-))
    unset IFS
    
    echo ""
    print_success "Total video files collected from all sources: ${#ALL_VIDEO_FILES[@]}"
    
    # Filter out .ia files if non-.ia version exists
    # Internet Archive often creates .ia.mp4 duplicates alongside .mp4 originals
    local -a FILTERED_FILES=()
    local skipped_ia_count=0
    for file in "${ALL_VIDEO_FILES[@]}"; do
        if [[ "$file" =~ \.ia\.[^.]+$ ]]; then
            # This is a .ia file - check if non-.ia version exists
            local non_ia_file="${file/.ia./.}"
            if [[ -f "$non_ia_file" ]]; then
                should_debug low && echo "[DEBUG] Filtering out .ia duplicate: $file" >&2
                ((skipped_ia_count++))
                continue
            fi
        fi
        FILTERED_FILES+=("$file")
    done
    # Sort filtered files alphabetically by basename before reassigning
    IFS=$'\n' FILTERED_FILES=($(for f in "${FILTERED_FILES[@]}"; do echo "$f"; done | awk -F'/' '{print $NF"\t"$0}' | sort -f -k1 | cut -f2-))
    unset IFS
    ALL_VIDEO_FILES=("${FILTERED_FILES[@]}")
    
    if [[ $skipped_ia_count -gt 0 ]]; then
        print_info "Filtered out $skipped_ia_count Internet Archive duplicate(s) (.ia files)"
    fi
    
    echo ""
    
    # Save original count before any filtering
    local ORIGINAL_FILE_COUNT=${#ALL_VIDEO_FILES[@]}
    
    # Determine cache mode for work file naming from the actual CACHE_FILE path
    # Extract the distinctive part between "MOVIE"/"SHOWS" and "CACHE.txt"
    # Examples: "MOVIE 4K CACHE.txt" -> "4k", "MOVIE 1080p SOFTCORE CACHE.txt" -> "1080p_softcore"
    local cache_mode=""
    if [[ -n "$CACHE_FILE" ]]; then
        # Extract cache name from file path
        local cache_basename=$(basename "$CACHE_FILE" .txt)
        
        # Remove "MOVIE " or "SHOWS " prefix and " CACHE" suffix
        cache_mode=$(echo "$cache_basename" | sed -E 's/^(MOVIE|SHOWS) //;s/ CACHE$//')
        
        # Replace spaces with underscores for valid filename
        cache_mode=$(echo "$cache_mode" | tr ' ' '_')
        
        # Convert to lowercase for consistency
        cache_mode=$(echo "$cache_mode" | tr '[:upper:]' '[:lower:]')
        
        print_info "Detected cache mode: '$cache_mode' (from: $(basename "$CACHE_FILE"))"
    else
        print_error "CACHE_FILE is not set - cannot determine cache mode"
        exit 1
    fi
    
    # Create instance-specific work tracking
    local INSTANCE_WORK_DIR="/tmp/movie_instance_work"
    mkdir -p "$INSTANCE_WORK_DIR" 2>/dev/null
    local INSTANCE_WORK_FILE="${INSTANCE_WORK_DIR}/working_${cache_mode}_$$.txt"
    
    # Check for other instances working on the same cache
    echo ""
    print_info "Checking for other instances using '${cache_mode}' cache..."
    local -a OTHER_INSTANCE_FILES=()
    local other_count=0
    
    while IFS= read -r -d '' work_file; do
        [[ -z "$work_file" ]] && continue
        local other_pid=$(basename "$work_file" .txt | sed "s/working_${cache_mode}_//")
        
        # Skip our own PID
        [[ "$other_pid" == "$$" ]] && continue
        
        # Check if process is still alive
        if kill -0 "$other_pid" 2>/dev/null; then
            OTHER_INSTANCE_FILES+=("$work_file")
            ((other_count++))
            echo "  Found active instance: PID $other_pid"
        else
            # Clean up stale work file from dead process
            echo "  Cleaning stale work file from dead PID $other_pid"
            rm -f "$work_file" 2>/dev/null
        fi
    done < <(find "$INSTANCE_WORK_DIR" -maxdepth 1 -name "working_${cache_mode}_*.txt" -print0 2>/dev/null)
    
    # Filter out files already claimed by other instances
    if [[ ${#OTHER_INSTANCE_FILES[@]} -gt 0 ]]; then
        print_info "Found ${#OTHER_INSTANCE_FILES[@]} other instance(s) - filtering claimed files..."
        local -a AVAILABLE_FILES=()
        local claimed_count=0
        
        for file in "${ALL_VIDEO_FILES[@]}"; do
            local is_claimed=false
            
            # Check if this file is claimed by any other instance
            for other_work_file in "${OTHER_INSTANCE_FILES[@]}"; do
                if grep -Fxq "$file" "$other_work_file" 2>/dev/null; then
                    is_claimed=true
                    ((claimed_count++))
                    break
                fi
            done
            
            # Only add if not claimed
            if [[ "$is_claimed" == "false" ]]; then
                AVAILABLE_FILES+=("$file")
            fi
        done
        
        print_info "Files already claimed: $claimed_count"
        print_info "Files available for this instance: ${#AVAILABLE_FILES[@]}"
        
        # Sort available files alphabetically by basename before reassigning
        IFS=$'\n' AVAILABLE_FILES=($(for f in "${AVAILABLE_FILES[@]}"; do echo "$f"; done | awk -F'/' '{print $NF"\t"$0}' | sort -f -k1 | cut -f2-))
        unset IFS
        
        # Update our file list
        ALL_VIDEO_FILES=("${AVAILABLE_FILES[@]}")
        
        if [[ ${#ALL_VIDEO_FILES[@]} -eq 0 ]]; then
            echo ""
            print_warning "No files available - all files already claimed by other instances"
            print_info "Other instances are handling all work for this cache"
            rm -f "$INSTANCE_WORK_FILE" 2>/dev/null
            exit 0
        fi
    else
        print_success "No other instances detected - claiming all ${#ALL_VIDEO_FILES[@]} files"
    fi
    
    # Save our claimed file list and track total for statistics
    printf '%s\n' "${ALL_VIDEO_FILES[@]}" > "$INSTANCE_WORK_FILE"
    local FILES_AFTER_CLAIMING=${#ALL_VIDEO_FILES[@]}
    local PROCESSING_START_TIME=$(date '+%Y-%m-%d %H:%M:%S')
    echo ""
    print_success "Instance PID $$ claimed ${#ALL_VIDEO_FILES[@]} files in: $(basename "$INSTANCE_WORK_FILE")"
    print_info "Start time: $PROCESSING_START_TIME"
    
    # Set up cleanup trap for work file
    trap "rm -f '$INSTANCE_WORK_FILE' 2>/dev/null; trap - EXIT INT TERM" EXIT INT TERM
    
    # Check parsing mode
    local parse_mode_file="$CACHE_DIR/parsing_mode.txt"
    local parsing_mode="fast"
    [[ -f "$parse_mode_file" ]] && parsing_mode=$(cat "$parse_mode_file")
    
    print_info "Parsing mode: $parsing_mode (using ${AWK_PARSER:-awk} parser)"
    
    # Show parallel parsing status
    if [[ "$PARALLEL_PARSING" == "true" ]]; then
        print_info "Parallel parsing: ${GREEN}ENABLED${NC} (${PARALLEL_PARSE_JOBS} concurrent jobs)"
    fi
    
    # All modes do duplicate detection (just implemented differently)
    # Fast or Thorough modes (with or without cache): Do duplicate detection
        
        # Now detect duplicates across ALL sources
        print_info "Scanning for duplicate movies across all sources..."
        should_debug high && echo "[DEBUG] HARDLINK_EXTRAS setting: '$HARDLINK_EXTRAS'" >&2
        print_info "Total video files to check: ${#ALL_VIDEO_FILES[@]}"
        local -a NON_DUPLICATE_FILES=()
        local -a DUPLICATE_FILES=()
        local temp_dup_detect="/tmp/movie_dup_detect_$$"
        local temp_parse_cache="/tmp/movie_parse_cache_$$"
        > "$temp_dup_detect"
        
        # Clean up only OUR temp files from previous runs (if this PID was reused)
        # DO NOT delete other running instances' temp files
        rm -f "/tmp/movie_dup_detect_$$" "/tmp/movie_parse_cache_$$" 2>/dev/null
        
        # Set up trap to clean up temp files on exit/cancel/error
        trap "rm -f '$temp_dup_detect' '$temp_parse_cache' 2>/dev/null" EXIT INT TERM
        
        # Create parse cache in fast and thorough modes (not no-cache modes)
        if [[ "$parsing_mode" == "fast" ]]; then
            > "$temp_parse_cache"
            should_debug high && echo "[DEBUG] Fast mode: Parse caching enabled" >&2
        elif [[ "$parsing_mode" == "thorough" ]]; then
            > "$temp_parse_cache"
            should_debug high && echo "[DEBUG] Thorough mode: Parse caching enabled, will re-parse at each stage" >&2
        elif [[ "$parsing_mode" == "fast-nocache" ]]; then
            should_debug high && echo "[DEBUG] Fast No-Cache mode: Duplicate detection enabled, temp cache disabled" >&2
        elif [[ "$parsing_mode" == "thorough-nocache" ]]; then
            should_debug high && echo "[DEBUG] Thorough No-Cache mode: Duplicate detection enabled, temp cache and cache sorting disabled" >&2
        fi
    
    # Parse all files ONCE and store results for reuse
    # Format: filepath<TAB>title<TAB>year<TAB>normalized_title
    
    # Check if parallel parsing is enabled
    if [[ "$PARALLEL_PARSING" == "true" && ${#ALL_VIDEO_FILES[@]} -ge 2 ]]; then
        # Adaptive: use minimum of total files and PARALLEL_PARSE_JOBS
        local actual_jobs=$PARALLEL_PARSE_JOBS
        [[ ${#ALL_VIDEO_FILES[@]} -lt $actual_jobs ]] && actual_jobs=${#ALL_VIDEO_FILES[@]}
        
        print_info "Parallel parsing enabled: ${actual_jobs} concurrent parse jobs"
        
        # Create temp files for parallel parsing with file locks
        local temp_parse_lock="/tmp/movie_parse_lock_$$"
        local temp_dup_lock="/tmp/movie_dup_lock_$$"
        
        # Parse files in batches
        local batch_size=$actual_jobs
        local total_files=${#ALL_VIDEO_FILES[@]}
        local parsed_count=0
        
        for ((batch_start=0; batch_start<total_files; batch_start+=batch_size)); do
            local batch_pids=()
            
            # Start batch of parallel parse jobs
            for ((i=0; i<batch_size && (batch_start+i)<total_files; i++)); do
                local file_index=$((batch_start + i))
                local file="${ALL_VIDEO_FILES[$file_index]}"
                
                # Run parsing in background subshell
                (
                    # Check for interrupt
                    check_interrupt
                    
                    # Parse parent folder first
                    local parent_folder=$(dirname "$file")
                    local folder_name=$(basename "$parent_folder")
                    parse_filename "$parent_folder" "folder"
                    local folder_title="$PARSED_TITLE"
                    local folder_year="$PARSED_YEAR"
                    
                    # Parse the actual filename
                    parse_filename "$file"
                    
                    # Use folder info if filename parsing failed
                    if [[ -z "$PARSED_TITLE" && -n "$folder_title" ]]; then
                        PARSED_TITLE="$folder_title"
                    fi
                    if [[ -z "$PARSED_YEAR" && -n "$folder_year" ]]; then
                        PARSED_YEAR="$folder_year"
                    fi
                    
                    if [[ -n "$PARSED_TITLE" ]]; then
                        # Normalize title for comparison
                        local normalized_title=$(normalize_title_for_comparison "$PARSED_TITLE")
                        local key="${normalized_title}|${PARSED_YEAR:-unknown}"
                        
                        # Get file size
                        local size=0
                        if [[ -f "$file" ]]; then
                            size=$(stat -f "%z" "$file" 2>/dev/null || stat -c "%s" "$file" 2>/dev/null || echo "0")
                        fi
                        
                        should_debug high && echo "[DEBUG] Parsed: '$(basename "$file")' (folder: '$folder_name') -> key='$key' (normalized from '$PARSED_TITLE')" >&2
                        
                        # Use atomic mkdir for cross-platform file locking (macOS compatible)
                        while ! mkdir "$temp_dup_lock" 2>/dev/null; do
                            sleep 0.01
                        done
                        printf "%s\t%s\t%s\n" "$key" "$file" "$size" >> "$temp_dup_detect"
                        rmdir "$temp_dup_lock"
                        
                        while ! mkdir "$temp_parse_lock" 2>/dev/null; do
                            sleep 0.01
                        done
                        printf "%s\t%s\t%s\t%s\n" "$file" "$PARSED_TITLE" "${PARSED_YEAR:--}" "$normalized_title" >> "$temp_parse_cache"
                        rmdir "$temp_parse_lock"
                    else
                        should_debug high && echo "[DEBUG] Cannot parse (no title/year): '$(basename "$file")' -> NON_DUPLICATE" >&2
                        # Use atomic mkdir for cross-platform file locking
                        while ! mkdir "$temp_parse_lock" 2>/dev/null; do
                            sleep 0.01
                        done
                        printf "%s\t-\t-\t-\n" "$file" >> "$temp_parse_cache"
                        rmdir "$temp_parse_lock"
                    fi
                ) &
                
                batch_pids+=($!)
            done
            
            # Wait for batch to complete
            for pid in "${batch_pids[@]}"; do
                wait "$pid" 2>/dev/null || true
            done
            
            # Update progress (use newline in debug mode to avoid mixing with debug output)
            parsed_count=$((parsed_count + batch_size))
            if [[ $parsed_count -gt $total_files ]]; then
                parsed_count=$total_files
            fi
            if should_debug high || should_debug medium; then
                # In debug mode, use newline so debug output doesn't overwrite progress
                echo -e "${CYAN}Parsed: ${parsed_count}/${total_files} files${NC}" >&2
            else
                # Normal mode, use carriage return for in-place update
                echo -ne "\r${CYAN}Parsed: ${parsed_count}/${total_files} files${NC}" >&2
            fi
        done
        
        echo "" >&2
        print_success "Parallel parsing complete: ${total_files} files parsed"
        
        # Clean up lock directories
        rmdir "$temp_parse_lock" "$temp_dup_lock" 2>/dev/null || true
        
    else
        # Sequential parsing (original code)
        if [[ "$PARALLEL_PARSING" == "true" ]]; then
            print_info "Parallel parsing disabled: too few files (need > $((PARALLEL_PARSE_JOBS * 2)))"
        fi
        
#        # DEBUG: Show file order before processing
#        if should_debug high; then
#            echo "[DEBUG] Files in processing order:" >&2
#            local debug_idx=1
#            for debug_file in "${ALL_VIDEO_FILES[@]}"; do
#                echo "[DEBUG]   $debug_idx. $(basename "$debug_file")" >&2
#                ((debug_idx++))
#            done
#        fi
        
        for file in "${ALL_VIDEO_FILES[@]}"; do
            # Check for interrupt at start of each file
            check_interrupt
            
            # Parse parent folder first (same logic as process_file)
            local parent_folder=$(dirname "$file")
            local folder_name=$(basename "$parent_folder")
            parse_filename "$parent_folder" "folder"
            local folder_title="$PARSED_TITLE"
            local folder_year="$PARSED_YEAR"
            
            # Now parse the actual filename
            parse_filename "$file"
            
            # Use folder info if filename parsing failed or is incomplete
            if [[ -z "$PARSED_TITLE" && -n "$folder_title" ]]; then
                PARSED_TITLE="$folder_title"
            fi
            if [[ -z "$PARSED_YEAR" && -n "$folder_year" ]]; then
                PARSED_YEAR="$folder_year"
            fi
            
            if [[ -n "$PARSED_TITLE" ]]; then
                # Regular movie files - check for duplicates (year is optional)
                # Normalize title for comparison (remove apostrophes, punctuation, etc.)
                local normalized_title=$(normalize_title_for_comparison "$PARSED_TITLE")
                local key="${normalized_title}|${PARSED_YEAR:-unknown}"
                
                # Get file size (with additional safety check)
                local size=0
                if [[ -f "$file" ]]; then
                    size=$(stat -f "%z" "$file" 2>/dev/null || stat -c "%s" "$file" 2>/dev/null || echo "0")
                fi
                
                should_debug high && echo "[DEBUG] Parsed: '$(basename "$file")' (folder: '$folder_name') -> key='$key' (normalized from '$PARSED_TITLE')" >&2
                
                # Store in duplicate detection file
                printf "%s\t%s\t%s\n" "$key" "$file" "$size" >> "$temp_dup_detect"
                
                # Store parsed results for reuse in ALL modes (not just fast/thorough)
                # This eliminates redundant parsing during processing
                # Use "-" placeholder for empty year to preserve tab structure (bash IFS=$'\t' doesn't handle empty fields)
                printf "%s\t%s\t%s\t%s\n" "$file" "$PARSED_TITLE" "${PARSED_YEAR:--}" "$normalized_title" >> "$temp_parse_cache"
            else
                # Can't parse, treat as non-duplicate (likely not a movie file)
                should_debug high && echo "[DEBUG] Cannot parse (no title/year): '$(basename "$file")' -> NON_DUPLICATE" >&2
                NON_DUPLICATE_FILES+=("$file")
                # Store entry with "-" placeholders so we know it was checked (in ALL modes)
                printf "%s\t-\t-\t-\n" "$file" >> "$temp_parse_cache"
            fi
        done
    fi  # End parallel/sequential parsing
    
    # Load parse cache into memory arrays for instant lookups (bash 3.x compatible)
        if [[ "$parsing_mode" == "fast" ]] || [[ "$parsing_mode" == "thorough" ]]; then
            if [[ -f "$temp_parse_cache" ]]; then
                print_info "Loading parse cache into memory arrays..."
                PARSE_CACHE_COUNT=0
                while IFS=$'\t' read -r filepath title year normalized; do
                    # Convert "-" placeholder back to empty string for year
                    [[ "$year" == "-" ]] && year=""
                    PARSE_CACHE_PATHS[$PARSE_CACHE_COUNT]="$filepath"
                    PARSE_CACHE_TITLES[$PARSE_CACHE_COUNT]="$title"
                    PARSE_CACHE_YEARS[$PARSE_CACHE_COUNT]="$year"
                    PARSE_CACHE_NORMALIZED[$PARSE_CACHE_COUNT]="$normalized"
                    ((PARSE_CACHE_COUNT++))
                done < "$temp_parse_cache"
                print_info "Loaded $PARSE_CACHE_COUNT entries into memory arrays"
            fi
        fi
        
        # Identify duplicates using sort/uniq (case-insensitive)
        if [[ -s "$temp_dup_detect" ]]; then
            # Debug: Check if temp_dup_detect has duplicate entries (same file listed multiple times)
            should_debug high && {
                local total_lines=$(wc -l < "$temp_dup_detect" | tr -d ' ')
                local unique_files=$(cut -f2 "$temp_dup_detect" | sort | uniq | wc -l | tr -d ' ')
                echo "[DEBUG] temp_dup_detect: $total_lines total lines, $unique_files unique files" >&2
                if [[ $total_lines -ne $unique_files ]]; then
                    echo "[DEBUG] WARNING: File(s) appear multiple times in temp_dup_detect!" >&2
                    # Show which files are duplicated
                    cut -f2 "$temp_dup_detect" | sort | uniq -d | while read -r dup_file; do
                        echo "[DEBUG]   Duplicated: $dup_file" >&2
                    done
                fi
            }
            
            # Find duplicate keys (appears more than once)
            local temp_keys="/tmp/movie_keys_$$.txt"
            cut -f1 "$temp_dup_detect" | sort -f | uniq -d -i > "$temp_keys"
            
            print_info "Scanning for duplicates (same title/year)..."
            print_info "Extension duplicate handling: ${CYAN}Same folder + same name + different extension${NC} → Keep best quality"
            print_info "Selection criteria: ${CYAN}Highest resolution 1st${NC}, ${YELLOW}then highest bitrate if resolution is the same/tied 2nd${NC}"
            echo -e "${DIM}  Example: ${GREEN}movienamethesame.mkv (1080p, 375 KB/s)${NC} ${DIM}>${NC} ${YELLOW}movienamethesame.mp4 (720p, 1.00 MB/s)${NC} ${CYAN}[resolution wins]${NC}" >&2
            echo -e "${DIM}           ${GREEN}movienamethesame.mkv (1080p, 1.00 MB/s)${NC} ${DIM}>${NC} ${YELLOW}movienamethesame.mp4 (1080p, 375 KB/s)${NC} ${CYAN}[bitrate wins when tied]${NC}" >&2
            
            # FIRST: Filter out lower resolution/bitrate duplicates (same basename, different extension)
            # This prevents marking both files as duplicates when we should just keep the best one
            local temp_filtered="/tmp/movie_filtered_$$.txt"
            local temp_groups="/tmp/movie_groups_$$.txt"
            > "$temp_filtered"
            > "$temp_groups"
            
            # Create group file: group_key TAB file TAB size TAB key
            while IFS=$'\t' read -r key file size; do
                local parent_dir=$(dirname "$file")
                local base_name="${file%.*}"
                local group_key="${parent_dir}/$(basename "$base_name")"
                printf "%s\t%s\t%s\t%s\n" "$group_key" "$file" "$size" "$key" >> "$temp_groups"
            done < "$temp_dup_detect"
            
            # Sort by group_key to group files together
            sort -t$'\t' -k1,1 "$temp_groups" > "${temp_groups}.sorted"
            mv "${temp_groups}.sorted" "$temp_groups"
            
            # Process each group
            local current_group=""
            local group_files_list="/tmp/movie_group_files_$$.txt"
            local skipped_extension_dups=0
            
            # Track which files were kept vs rejected
            local extension_dup_log="/tmp/movie_extension_dups_$$.txt"
            > "$extension_dup_log"
            
            while IFS=$'\t' read -r group_key file size key; do
                if [[ "$group_key" != "$current_group" ]]; then
                    # New group started - process previous group if it had files
                    if [[ -f "$group_files_list" && -s "$group_files_list" ]]; then
                        local file_count=$(wc -l < "$group_files_list" | tr -d ' ')
                        
                        if [[ $file_count -gt 1 ]]; then
                            # Multiple files with same basename - compare resolution first (fast)
                            local best_file=""
                            local best_resolution=0
                            local best_bitrate=0
                            local best_size=0
                            local best_key=""
                            
                            print_info "Checking resolution for files in group: $current_group"
                            
                            # FIRST PASS: Get resolution for all files (fast)
                            local -a group_resolutions=()
                            local -a group_files_array=()
                            local -a group_sizes_array=()
                            local -a group_keys_array=()
                            local index=0
                            
                            while IFS=$'\t' read -r gfile gsize gkey; do
                                local resolution=$(get_video_resolution_height "$gfile")
                                group_resolutions[$index]=$resolution
                                group_files_array[$index]="$gfile"
                                group_sizes_array[$index]=$gsize
                                group_keys_array[$index]="$gkey"
                                echo -e "${CYAN}  File: $(basename "$gfile") - ${resolution}p (${gsize} bytes)${NC}" >&2
                                
                                if [[ $resolution -gt $best_resolution ]] || 
                                   [[ $resolution -eq $best_resolution && $gsize -gt $best_size ]]; then
                                    best_resolution=$resolution
                                    best_size=$gsize
                                    best_file="$gfile"
                                    best_key="$gkey"
                                fi
                                ((index++))
                            done < "$group_files_list"
                            
                            # SECOND PASS: Only check bitrate if multiple files have the same best resolution
                            local resolution_tie_count=0
                            for res in "${group_resolutions[@]}"; do
                                [[ $res -eq $best_resolution ]] && ((resolution_tie_count++))
                            done
                            
                            if [[ $resolution_tie_count -gt 1 ]]; then
                                echo -e "${CYAN}  Resolution tie detected (${best_resolution}p) - checking bitrate...${NC}" >&2
                                best_bitrate=0
                                best_size=0
                                best_file=""
                                best_key=""
                                
                                for ((i=0; i<${#group_resolutions[@]}; i++)); do
                                    if [[ ${group_resolutions[$i]} -eq $best_resolution ]]; then
                                        local bitrate=$(get_video_bitrate "${group_files_array[$i]}")
                                        local bitrate_formatted=$(format_bitrate "$bitrate")
                                        echo -e "${CYAN}    Bitrate for $(basename "${group_files_array[$i]}"): ${bitrate_formatted}${NC}" >&2
                                        
                                        if [[ $bitrate -gt $best_bitrate ]] || 
                                           [[ $bitrate -eq $best_bitrate && ${group_sizes_array[$i]} -gt $best_size ]]; then
                                            best_bitrate=$bitrate
                                            best_size=${group_sizes_array[$i]}
                                            best_file="${group_files_array[$i]}"
                                            best_key="${group_keys_array[$i]}"
                                        fi
                                    fi
                                done
                            fi

                            
                            # Keep only the best file
                            if [[ -n "$best_file" ]]; then
                                if [[ $resolution_tie_count -gt 1 ]]; then
                                    local bitrate_formatted=$(format_bitrate "$best_bitrate")
                                    echo -e "${GREEN}  ✓ Keeping best: $(basename "$best_file") (${best_resolution}p, ${bitrate_formatted})${NC}" >&2
                                else
                                    echo -e "${GREEN}  ✓ Keeping best: $(basename "$best_file") (${best_resolution}p)${NC}" >&2
                                fi
                                
                                # Show rejected files
                                for ((i=0; i<${#group_files_array[@]}; i++)); do
                                    if [[ "${group_files_array[$i]}" != "$best_file" ]]; then
                                        echo -e "${RED}  ✗ Rejected: $(basename "${group_files_array[$i]}") (${group_resolutions[$i]}p)${NC}" >&2
                                    fi
                                done
                                
                                printf "%s\t%s\t%s\n" "$best_key" "$best_file" "$best_size" >> "$temp_filtered"
                                
                                # Log kept vs rejected files with reason
                                local selection_reason="resolution"
                                if [[ $resolution_tie_count -gt 1 ]]; then
                                    selection_reason="bitrate"
                                fi
                                
                                for ((i=0; i<${#group_files_array[@]}; i++)); do
                                    if [[ "${group_files_array[$i]}" == "$best_file" ]]; then
                                        # Get bitrate for kept file if not already calculated
                                        if [[ $best_bitrate -eq 0 ]]; then
                                            best_bitrate=$(get_video_bitrate "$best_file")
                                        fi
                                        echo "KEPT|$best_file|${best_resolution}p|${best_bitrate}|$selection_reason" >> "$extension_dup_log"
                                    else
                                        # Always get bitrate for rejected files
                                        local rejected_bitrate=$(get_video_bitrate "${group_files_array[$i]}")
                                        echo "REJECTED|${group_files_array[$i]}|${group_resolutions[$i]}p|${rejected_bitrate}|$selection_reason" >> "$extension_dup_log"
                                    fi
                                done
                                
                                ((skipped_extension_dups += file_count - 1))
                            fi
                        else
                            # Only one file in group, keep it
                            while IFS=$'\t' read -r gfile gsize gkey; do
                                printf "%s\t%s\t%s\n" "$gkey" "$gfile" "$gsize" >> "$temp_filtered"
                            done < "$group_files_list"
                        fi
                    fi
                    
                    # Start new group
                    current_group="$group_key"
                    > "$group_files_list"
                fi
                
                # Add file to current group
                printf "%s\t%s\t%s\n" "$file" "$size" "$key" >> "$group_files_list"
            done < "$temp_groups"
            
            # Process last group
            if [[ -f "$group_files_list" && -s "$group_files_list" ]]; then
                local file_count=$(wc -l < "$group_files_list" | tr -d ' ')
                
                if [[ $file_count -gt 1 ]]; then
                    local best_file=""
                    local best_resolution=0
                    local best_bitrate=0
                    local best_size=0
                    local best_key=""
                    
                    print_info "Checking resolution for files in group: $current_group"
                    
                    # FIRST PASS: Get resolution for all files (fast)
                    local -a group_resolutions=()
                    local -a group_files_array=()
                    local -a group_sizes_array=()
                    local -a group_keys_array=()
                    local index=0
                    
                    while IFS=$'\t' read -r gfile gsize gkey; do
                        local resolution=$(get_video_resolution_height "$gfile")
                        group_resolutions[$index]=$resolution
                        group_files_array[$index]="$gfile"
                        group_sizes_array[$index]=$gsize
                        group_keys_array[$index]="$gkey"
                        local size_display=$(format_bytes "$gsize")
                        echo -e "${CYAN}  File: $(basename "$gfile") - ${resolution}p ($size_display)${NC}" >&2
                        
                        if [[ $resolution -gt $best_resolution ]] || 
                           [[ $resolution -eq $best_resolution && $gsize -gt $best_size ]]; then
                            best_resolution=$resolution
                            best_size=$gsize
                            best_file="$gfile"
                            best_key="$gkey"
                        fi
                        ((index++))
                    done < "$group_files_list"
                    
                    # SECOND PASS: Only check bitrate if multiple files have the same best resolution
                    local resolution_tie_count=0
                    for res in "${group_resolutions[@]}"; do
                        [[ $res -eq $best_resolution ]] && ((resolution_tie_count++))
                    done
                    
                    if [[ $resolution_tie_count -gt 1 ]]; then
                        echo -e "${CYAN}  Resolution tie detected (${best_resolution}p) - checking bitrate...${NC}" >&2
                        best_bitrate=0
                        best_size=0
                        best_file=""
                        best_key=""
                        
                        for ((i=0; i<${#group_resolutions[@]}; i++)); do
                            if [[ ${group_resolutions[$i]} -eq $best_resolution ]]; then
                                local bitrate=$(get_video_bitrate "${group_files_array[$i]}")
                                echo -e "${CYAN}    Bitrate for $(basename "${group_files_array[$i]}"): ${bitrate} kbps${NC}" >&2
                                
                                if [[ $bitrate -gt $best_bitrate ]] || 
                                   [[ $bitrate -eq $best_bitrate && ${group_sizes_array[$i]} -gt $best_size ]]; then
                                    best_bitrate=$bitrate
                                    best_size=${group_sizes_array[$i]}
                                    best_file="${group_files_array[$i]}"
                                    best_key="${group_keys_array[$i]}"
                                fi
                            fi
                        done
                    fi
                    
                    if [[ -n "$best_file" ]]; then
                        if [[ $resolution_tie_count -gt 1 ]]; then
                            local bitrate_formatted=$(format_bitrate "$best_bitrate")
                            echo -e "${GREEN}  ✓ Keeping best: $(basename "$best_file") (${best_resolution}p, ${bitrate_formatted})${NC}" >&2
                        else
                            echo -e "${GREEN}  ✓ Keeping best: $(basename "$best_file") (${best_resolution}p)${NC}" >&2
                        fi
                        
                        # Show rejected files
                        for ((i=0; i<${#group_files_array[@]}; i++)); do
                            if [[ "${group_files_array[$i]}" != "$best_file" ]]; then
                                echo -e "${RED}  ✗ Rejected: $(basename "${group_files_array[$i]}") (${group_resolutions[$i]}p)${NC}" >&2
                            fi
                        done
                        
                        printf "%s\t%s\t%s\n" "$best_key" "$best_file" "$best_size" >> "$temp_filtered"
                        
                        # Log kept vs rejected files with reason
                        local selection_reason="resolution"
                        if [[ $resolution_tie_count -gt 1 ]]; then
                            selection_reason="bitrate"
                        fi
                        
                        for ((i=0; i<${#group_files_array[@]}; i++)); do
                            if [[ "${group_files_array[$i]}" == "$best_file" ]]; then
                                # Get bitrate for kept file if not already calculated
                                if [[ $best_bitrate -eq 0 ]]; then
                                    best_bitrate=$(get_video_bitrate "$best_file")
                                fi
                                echo "KEPT|$best_file|${best_resolution}p|${best_bitrate}|$selection_reason" >> "$extension_dup_log"
                            else
                                # Always get bitrate for rejected files
                                local rejected_bitrate=$(get_video_bitrate "${group_files_array[$i]}")
                                echo "REJECTED|${group_files_array[$i]}|${group_resolutions[$i]}p|${rejected_bitrate}|$selection_reason" >> "$extension_dup_log"
                            fi
                        done
                        
                        ((skipped_extension_dups += file_count - 1))
                    fi
                else
                    while IFS=$'\t' read -r gfile gsize gkey; do
                        printf "%s\t%s\t%s\n" "$gkey" "$gfile" "$gsize" >> "$temp_filtered"
                    done < "$group_files_list"
                fi
            fi
            
            # Clean up temp files
            rm -f "$temp_groups" "$group_files_list" 2>/dev/null
            
            # Show how many extension duplicates were filtered
            if [[ $skipped_extension_dups -gt 0 ]]; then
                echo ""
                print_info "Filtered out ${YELLOW}$skipped_extension_dups${NC} extension duplicate(s) - keeping only best quality from each group"
            fi
            
            # Use filtered list for duplicate detection
            mv "$temp_filtered" "$temp_dup_detect"
            
            # Regenerate duplicate keys from filtered list (not original list)
            rm -f "$temp_keys" 2>/dev/null
            cut -f1 "$temp_dup_detect" | sort -f | uniq -d -i > "$temp_keys"
            
            echo ""
            print_info "Title duplicates (same movie, different folders/files):"
            if [[ -s "$temp_keys" ]]; then
                # Sort keys alphabetically for display
                while IFS= read -r dup_key; do
                    local dup_title="${dup_key%%|*}"
                    local dup_year="${dup_key##*|}"
                    echo -e "${CYAN}  - Title: '$dup_title' Year: $dup_year${NC}" >&2
                done < <(sort -f < "$temp_keys")
            else
                echo -e "${CYAN}  (none)${NC}" >&2
            fi
            
            # Separate duplicates from non-duplicates (case-insensitive matching)
            # Use process substitution to avoid subshell that would lose array assignments
            while IFS=$'\t' read -r key file size; do
                if grep -Fixq "$key" "$temp_keys" 2>/dev/null; then
                    should_debug high && echo "[DEBUG] Marked as DUPLICATE: key='$key' file='$(basename "$file")'" >&2
                    DUPLICATE_FILES+=("$file")
                else
                    NON_DUPLICATE_FILES+=("$file")
                fi
            done < <(cat "$temp_dup_detect")
            
            rm -f "$temp_keys" 2>/dev/null
        fi
        
    rm -f "$temp_dup_detect" 2>/dev/null
    # Keep temp_parse_cache for reuse in cache sorting and processing
    
    # Combine and sort arrays alphabetically by basename before reassigning
    local -a COMBINED_FILES=("${NON_DUPLICATE_FILES[@]}" "${DUPLICATE_FILES[@]}")
    IFS=$'\n' COMBINED_FILES=($(for f in "${COMBINED_FILES[@]}"; do echo "$f"; done | awk -F'/' '{print $NF"\t"$0}' | sort -f -k1 | cut -f2-))
    unset IFS
    
    # Update ALL_VIDEO_FILES array to match filtered list
    ALL_VIDEO_FILES=("${COMBINED_FILES[@]}")
    
    # Show final count after filtering
    local final_file_count=${#ALL_VIDEO_FILES[@]}
    if [[ $skipped_extension_dups -gt 0 ]]; then
        echo ""
        print_success "Processing ${final_file_count} video file(s) (${#NON_DUPLICATE_FILES[@]} unique + ${#DUPLICATE_FILES[@]} title duplicates)"
    fi
    
    if [[ ${#DUPLICATE_FILES[@]} -gt 0 ]]; then
        print_warning "Found ${#DUPLICATE_FILES[@]} duplicate file(s) - will process ${#NON_DUPLICATE_FILES[@]} non-duplicates first"
        should_debug high && {
            echo "[DEBUG] Duplicate files detected:" >&2
            # Sort filenames alphabetically for display (with full paths to distinguish same names in different folders)
            for dup_file in "${DUPLICATE_FILES[@]}"; do
                # Show relative path from qtest folder to distinguish duplicates with same basename
                local relative_path="${dup_file#*/qtest/}"
                echo "$relative_path"
            done | sort -f | while read -r sorted_path; do
                echo "[DEBUG]   - $sorted_path" >&2
            done
        }
        # Add to global duplicate tracking array
        ALL_DUPLICATE_FILES=("${DUPLICATE_FILES[@]}")
    fi
    
    # Process non-duplicate files first (or all files in thorough-nocache mode)
    local total_success=0
    local total_failed=0
    
    # All modes: process non-duplicates first
    if [[ ${#NON_DUPLICATE_FILES[@]} -eq 0 ]]; then
        print_warning "No non-duplicate files to process"
        if [[ ${#DUPLICATE_FILES[@]} -eq 0 ]]; then
            print_error "No files to process at all"
            exit 1
        fi
    fi
    
    # All modes use NON_DUPLICATE_FILES
    VIDEO_FILES=("${NON_DUPLICATE_FILES[@]}")
    
    # Track duplicate count for statistics
    local DUPLICATES_DETECTED=$((FILES_AFTER_CLAIMING - ${#NON_DUPLICATE_FILES[@]}))
    local TOTAL_FILES_FOUND=${#NON_DUPLICATE_FILES[@]}
    export FILTERED_FILE_COUNT=${final_file_count:-$ORIGINAL_FILE_COUNT}
    export EXTENSION_DUPLICATES_FILTERED=${skipped_extension_dups:-0}
    export EXTENSION_DUP_LOG="${extension_dup_log:-}"
    
    if [[ ${#VIDEO_FILES[@]} -gt 0 ]]; then
            # Skip cache sorting in no-cache modes
            if [[ "$parsing_mode" == "fast-nocache" ]] || [[ "$parsing_mode" == "thorough-nocache" ]]; then
                echo ""
                print_success "Processing ${#VIDEO_FILES[@]} video file(s) in no-cache mode"
                echo ""
            else
                # Separate files into cached and non-cached for optimized processing
                echo ""
                print_info "Sorting files by cache status (cached files will be processed first)..."
            
            local -a CACHED_FILES=()
            local -a NON_CACHED_FILES=()
            
            # Use parallel cache lookups if enabled and enough files
            if [[ "$PARALLEL_PARSING" == "true" && ${#VIDEO_FILES[@]} -gt $((PARALLEL_PARSE_JOBS * 2)) ]]; then
                print_info "Parallel cache sorting enabled: ${PARALLEL_PARSE_JOBS} concurrent lookup jobs"
                
                # Create temp files for results
                local temp_cached_list="/tmp/movie_cached_$$"
                local temp_noncached_list="/tmp/movie_noncached_$$"
                local temp_cached_lock="/tmp/movie_cached_lock_$$"
                local temp_noncached_lock="/tmp/movie_noncached_lock_$$"
                > "$temp_cached_list"
                > "$temp_noncached_list"
                
                # Process in batches
                local batch_size=$PARALLEL_PARSE_JOBS
                local total_files=${#VIDEO_FILES[@]}
                local sorted_count=0
                
                for ((batch_start=0; batch_start<total_files; batch_start+=batch_size)); do
                    local batch_pids=()
                    
                    for ((i=0; i<batch_size && (batch_start+i)<total_files; i++)); do
                        local file_index=$((batch_start + i))
                        local file="${VIDEO_FILES[$file_index]}"
                        
                        # Run cache lookup in background
                        (
                            check_interrupt
                            
                            # Skip if file no longer exists
                            if [[ ! -f "$file" ]]; then
                                exit 0
                            fi
                            
                            local file_title=""
                            local file_year=""
                            
                            # Try in-memory cache first
                            local cached_data=$(lookup_parse_cache "$file")
                            if [[ -n "$cached_data" ]]; then
                                file_title="${cached_data%%|*}"
                                file_year="${cached_data#*|}"
                                should_debug high && echo "[DEBUG] Using cached parse results for: $(basename "$file") -> '$file_title' ($file_year)" >&2
                            else
                                # Cache miss: parse the file
                                should_debug high && echo "[DEBUG] Cache miss - parsing: $(basename "$file")" >&2
                                local parent_folder=$(dirname "$file")
                                parse_filename "$parent_folder"
                                local folder_title="$PARSED_TITLE"
                                local folder_year="$PARSED_YEAR"
                                
                                parse_filename "$file"
                                
                                if [[ -z "$PARSED_TITLE" && -n "$folder_title" ]]; then
                                    PARSED_TITLE="$folder_title"
                                fi
                                if [[ -z "$PARSED_YEAR" && -n "$folder_year" ]]; then
                                    PARSED_YEAR="$folder_year"
                                fi
                                
                                file_title="$PARSED_TITLE"
                                file_year="$PARSED_YEAR"
                            fi
                            
                            # Check if in cache and write to appropriate list
                            if [[ -n "$file_title" && -n "$file_year" ]]; then
                                local cached_movie=$(get_cached_movie "$file_title" "$file_year")
                                if [[ -n "$cached_movie" ]]; then
                                    # Write to cached list with atomic lock
                                    while ! mkdir "$temp_cached_lock" 2>/dev/null; do
                                        sleep 0.01
                                    done
                                    echo "$file" >> "$temp_cached_list"
                                    rmdir "$temp_cached_lock"
                                else
                                    # Write to non-cached list with atomic lock
                                    while ! mkdir "$temp_noncached_lock" 2>/dev/null; do
                                        sleep 0.01
                                    done
                                    echo "$file" >> "$temp_noncached_list"
                                    rmdir "$temp_noncached_lock"
                                fi
                            else
                                # No title/year, treat as non-cached
                                while ! mkdir "$temp_noncached_lock" 2>/dev/null; do
                                    sleep 0.01
                                done
                                echo "$file" >> "$temp_noncached_list"
                                rmdir "$temp_noncached_lock"
                            fi
                        ) &
                        
                        batch_pids+=($!)
                    done
                    
                    # Wait for batch to complete
                    for pid in "${batch_pids[@]}"; do
                        wait "$pid" 2>/dev/null || true
                    done
                    
                    # Update progress
                    sorted_count=$((sorted_count + batch_size))
                    if [[ $sorted_count -gt $total_files ]]; then
                        sorted_count=$total_files
                    fi
                    
                    # Use newlines in debug mode to avoid overlapping with debug output
                    if should_debug high || should_debug medium; then
                        echo -e "${CYAN}Sorted: ${sorted_count}/${total_files} files${NC}" >&2
                    else
                        echo -ne "\r${CYAN}Sorted: ${sorted_count}/${total_files} files${NC}" >&2
                    fi
                done
                
                echo "" >&2
                
                # Load results into arrays
                if [[ -f "$temp_cached_list" ]]; then
                    while IFS= read -r file; do
                        CACHED_FILES+=("$file")
                    done < "$temp_cached_list"
                fi
                
                if [[ -f "$temp_noncached_list" ]]; then
                    while IFS= read -r file; do
                        NON_CACHED_FILES+=("$file")
                    done < "$temp_noncached_list"
                fi
                
                # Cleanup
                rm -f "$temp_cached_list" "$temp_noncached_list" 2>/dev/null
                rmdir "$temp_cached_lock" "$temp_noncached_lock" 2>/dev/null || true
                
                print_success "Parallel cache sorting complete: ${#CACHED_FILES[@]} cached, ${#NON_CACHED_FILES[@]} non-cached"
                
            else
                # Sequential cache sorting (original code)
                if [[ "$PARALLEL_PARSING" == "true" ]]; then
                    print_info "Parallel cache sorting disabled: too few files (need > $((PARALLEL_PARSE_JOBS * 2)))"
                fi
            
            for file in "${VIDEO_FILES[@]}"; do
                # Check for interrupt during file processing
                check_interrupt
                
                # Skip if file no longer exists (may have been moved by another instance)
                if [[ ! -f "$file" ]]; then
                    should_debug high && echo "[DEBUG] File disappeared during cache sorting, skipping: $(basename "$file")" >&2
                    continue
                fi
                
                local file_title=""
                local file_year=""
                
                # Always try in-memory cache first (eliminates redundant parsing)
                local cached_data=$(lookup_parse_cache "$file")
                if [[ -n "$cached_data" ]]; then
                    file_title="${cached_data%%|*}"
                    file_year="${cached_data#*|}"
                    should_debug high && echo "[DEBUG] Using cached parse results for: $(basename "$file") -> '$file_title' ($file_year)" >&2
                else
                    # Cache miss: parse the file (should be rare since duplicate scan caches everything)
                    should_debug high && echo "[DEBUG] Cache miss - parsing: $(basename "$file")" >&2
                    local parent_folder=$(dirname "$file")
                    parse_filename "$parent_folder"
                    local folder_title="$PARSED_TITLE"
                    local folder_year="$PARSED_YEAR"
                    
                    parse_filename "$file"
                    
                    # Use folder info if filename parsing failed
                    if [[ -z "$PARSED_TITLE" && -n "$folder_title" ]]; then
                        PARSED_TITLE="$folder_title"
                    fi
                    if [[ -z "$PARSED_YEAR" && -n "$folder_year" ]]; then
                        PARSED_YEAR="$folder_year"
                    fi
                    
                    file_title="$PARSED_TITLE"
                    file_year="$PARSED_YEAR"
                fi
                
                # Check if in cache
                if [[ -n "$file_title" && -n "$file_year" ]]; then
                    local cached_data=$(get_cached_movie "$file_title" "$file_year")
                    if [[ -n "$cached_data" ]]; then
                        CACHED_FILES+=("$file")
                    else
                        NON_CACHED_FILES+=("$file")
                    fi
                else
                    # No title/year, treat as non-cached
                    NON_CACHED_FILES+=("$file")
                fi
            done
            fi  # End parallel/sequential cache sorting
            
            # Sort each group alphabetically by basename
            if [[ ${#CACHED_FILES[@]} -gt 0 ]]; then
                IFS=$'\n' CACHED_FILES=($(for f in "${CACHED_FILES[@]}"; do echo "$f"; done | awk -F'/' '{print $NF"\t"$0}' | sort -f -k1 | cut -f2-))
                unset IFS
            fi
            if [[ ${#NON_CACHED_FILES[@]} -gt 0 ]]; then
                IFS=$'\n' NON_CACHED_FILES=($(for f in "${NON_CACHED_FILES[@]}"; do echo "$f"; done | awk -F'/' '{print $NF"\t"$0}' | sort -f -k1 | cut -f2-))
                unset IFS
            fi
            
            # Combine: cached first, then non-cached
            VIDEO_FILES=("${CACHED_FILES[@]}" "${NON_CACHED_FILES[@]}")
            
            # Sort VIDEO_FILES alphabetically by basename to ensure consistent processing order
            IFS=$'\n' VIDEO_FILES=($(for f in "${VIDEO_FILES[@]}"; do echo "$f"; done | awk -F'/' '{print $NF"\t"$0}' | sort -f -k1 | cut -f2-))
            unset IFS
            
            echo ""
            if [[ ${#CACHED_FILES[@]} -gt 0 ]]; then
                print_success "Found ${#CACHED_FILES[@]} file(s) in cache (will process first)"
            fi
            if [[ ${#NON_CACHED_FILES[@]} -gt 0 ]]; then
                print_info "Found ${#NON_CACHED_FILES[@]} file(s) not in cache (will require API lookups)"
            fi
            echo ""
            
            # Show comprehensive processing info
            if [[ ${#DUPLICATE_FILES[@]} -gt 0 ]]; then
                local total_after_dups=$((${#VIDEO_FILES[@]} + ${#DUPLICATE_FILES[@]}))
                print_success "Processing ${#VIDEO_FILES[@]} non-duplicate file(s) | ${#DUPLICATE_FILES[@]} duplicate(s) queued for post-processing | ${#ALL_VIDEO_FILES[@]} total files | Expected ${total_after_dups} after duplicate processing"
            else
                print_success "Processing ${#VIDEO_FILES[@]} non-duplicate file(s) | ${#ALL_VIDEO_FILES[@]} total files"
            fi
            echo ""
            fi
            # End of cache sorting block (skipped in thorough-nocache mode)
            
            # Reset poster display flag for this batch
            unset POSTER_SHOWN
            
            # Track processing time
            local batch_start_time=$SECONDS
            
            # Set cache file based on cache mode before counting
            set_cache_by_resolution ""
            
            # Count cache entries before processing
            local cache_entries_before=0
            if [[ -f "$CACHE_FILE" ]]; then
                cache_entries_before=$(wc -l < "$CACHE_FILE" | tr -d ' ')
            fi
            
            # Initialize cache counter for this batch
            CACHE_COUNT=0
            
            # Set up Ctrl+C handler for immediate exit
            # Save current trap state to restore later
            local old_trap=$(trap -p INT)
            local old_exit_trap=$(trap -p EXIT)
            
            # More aggressive interrupt handler
            interrupt_handler() {
                INTERRUPTED=true
                echo "" >&2
                echo -e "\n${YELLOW:-}Ctrl+C detected - stopping...${NC:-}" >&2
                
                # Kill all child processes aggressively
                pkill -P $$ 2>/dev/null || true
                jobs -p | xargs kill -9 2>/dev/null || true
                
                trap - INT  # Restore default
                trap - EXIT
                exit 130  # Standard exit code for Ctrl+C
            }
            
            # Function to detect unexpected early exit
            exit_handler() {
                local exit_code=$?
                # Exit codes 0, 2, 3, 4, 130 are expected (success, already linked, locked, already processed, Ctrl+C)
                if [[ $exit_code -ne 0 && $exit_code -ne 2 && $exit_code -ne 3 && $exit_code -ne 4 && $exit_code -ne 130 ]]; then
                    echo ""
                    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                    echo "⚠️  DEBUG: Instance PID $$ exiting unexpectedly with code $exit_code"
                    echo "   Current file index: ${current_index:-${file_index:-0}} / $total_files"
                    if [[ "$ROLLING_QUEUE_MODE" == "true" ]]; then
                        echo "   Processed so far: ${success_count:-0} successful, ${failed_count:-0} failed"
                        echo "   Already linked: $((${skipped_count:-0} + ${already_processed_count:-0})), Locked: ${locked_count:-0}"
                    else
                        echo "   Processed so far: $success successful, $failed failed"
                        echo "   Already linked: $already_linked_count, Locked: $locked_count"
                    fi
                    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                    echo ""
                fi
            }
            
            trap interrupt_handler INT
            trap exit_handler EXIT
            
            # Process each file
            local success=0
            local failed=0
            local current_index=0
            local total_files=${#VIDEO_FILES[@]}
            local locked_count=0
            local already_linked_count=0
            local lower_bitrate_count=0
            
            # Debug: Show what we're about to process
            echo ""
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "🔍 DEBUG: Instance PID $$ starting to process $total_files files"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo ""
            
            # Initialize API counter file for parallel processing
            export API_COUNTER_FILE="${CACHE_DIR}/.api_counter_$$.tmp"
            > "$API_COUNTER_FILE"  # Create empty file
            
            # Check if parallel processing is enabled
            if [[ "$PARALLEL_PROCESSING" == "true" && "$AUTO_MODE" == "y" ]]; then
                # Load rolling queue mode setting
                [[ -f "${CACHE_DIR}/rolling_queue_mode.txt" ]] && ROLLING_QUEUE_MODE=$(cat "${CACHE_DIR}/rolling_queue_mode.txt")
                
                if [[ "$ROLLING_QUEUE_MODE" == "true" ]]; then
                    print_success "Parallel processing enabled: ${PARALLEL_JOBS} simultaneous jobs (rolling queue)"
                else
                    print_success "Parallel processing enabled: ${PARALLEL_JOBS} simultaneous jobs (batch mode)"
                fi
                echo ""
                
                if [[ "$ROLLING_QUEUE_MODE" == "true" ]]; then
                    # Use rolling queue approach - start new jobs as soon as slots open
                    local -a active_pids=()
                    local -a active_files=()
                    local -a active_indices=()
                    local file_index=0
                    local success_count=0
                    local failed_count=0
                    local skipped_count=0
                    local already_processed_count=0
                    
                    # Disable posters during parallel processing to prevent terminal corruption
                    export DISABLE_IMAGES="true"
                    
                    # Main processing loop
                    while [[ $file_index -lt $total_files ]] || [[ ${#active_pids[@]} -gt 0 ]]; do
                        # Check for completed jobs (non-blocking) - collect completed indices first
                        local -a completed_indices=()
                        
                        for i in "${!active_pids[@]}"; do
                            local pid="${active_pids[$i]}"
                            if ! kill -0 "$pid" 2>/dev/null; then
                                local completed_idx="${active_indices[$i]}"
                                
                                # Capture exit code without triggering set -e
                                wait "$pid" 2>/dev/null || local exit_code=$?
                                local exit_code=${exit_code:-0}
                                
                                case $exit_code in
                                    0) ((success_count++)) ;;
                                    1) ((failed_count++)) ;;
                                    2) ((skipped_count++)) ;;
                                    3) ((locked_count++)) ;;
                                    4) ((already_processed_count++)) ;;
                                    *) ((failed_count++)) ;;
                                esac
                                
                                if [[ "$DIAGNOSTICS_MODE" == "true" ]]; then
                                    echo "[DIAG] Parallel job END: PID=$pid Index=$completed_idx ExitCode=$exit_code Time=$(date '+%Y-%m-%d %H:%M:%S')" >&2
                                fi
                                
                                # Mark for removal
                                completed_indices+=("$i")
                            fi
                        done
                        
                        # Remove completed jobs from arrays (in reverse order to preserve indices)
                        for ((idx=${#completed_indices[@]}-1; idx>=0; idx--)); do
                            local i="${completed_indices[$idx]}"
                            unset 'active_pids[$i]'
                            unset 'active_files[$i]'
                            unset 'active_indices[$i]'
                        done
                        
                        # Compact arrays to remove gaps from unset elements
                        active_pids=("${active_pids[@]}")
                        active_files=("${active_files[@]}")
                        active_indices=("${active_indices[@]}")
                        
                        # Start new jobs for available slots
                        while [[ ${#active_pids[@]} -lt $PARALLEL_JOBS ]] && [[ $file_index -lt $total_files ]]; do
                            local video_file="${VIDEO_FILES[$file_index]}"
                            local display_index=$((file_index + 1))
                            ((file_index++))
                            
                            echo -e "${DIM}[QUEUE] Starting job ${display_index}/${total_files} (active: ${#active_pids[@]}/${PARALLEL_JOBS})${NC}" >&2
                            
                            if [[ "$DIAGNOSTICS_MODE" == "true" ]]; then
                                echo "[DIAG] Parallel job START: File='$(basename "$video_file")' Index=$display_index Time=$(date '+%Y-%m-%d %H:%M:%S')" >&2
                            fi
                            
                            (
                                local job_pid=$$
                                
                                if [[ ! -f "$video_file" ]]; then
                                    echo ""
                                    print_info "========================================="
                                    print_info "Movie ${display_index}/${total_files}: $(basename "$video_file")"
                                    print_info "========================================="
                                    echo "⏭️  File no longer exists (moved/processed by another instance)"
                                    exit 4
                                fi
                                
                                echo ""
                                print_info "========================================="
                                print_info "Movie ${display_index}/${total_files}: $(basename "$video_file")"
                                print_info "========================================="
                                
                                set_cache_by_resolution "$video_file"
                                
                                process_file "$video_file" "$AUTO_MODE" || exit_code=$?
                                exit ${exit_code:-0}
                            ) &
                            
                            local job_pid=$!
                            active_pids+=("$job_pid")
                            active_files+=("$video_file")
                            active_indices+=("$display_index")
                        done
                        
                        # Small sleep if jobs are running
                        if [[ ${#active_pids[@]} -gt 0 ]]; then
                            sleep 0.1
                        fi
                    done
                    
                    # Transfer rolling queue counters to main counters
                    success=$success_count
                    failed=$failed_count
                    already_linked_count=$((skipped_count + already_processed_count))
                    
                else
                    # Batch mode - original behavior
                    # Process files in parallel batches
                    local batch_size=$PARALLEL_JOBS
                    local file_index=0
                    
                    # Disable posters during parallel processing to prevent terminal corruption
                    export DISABLE_IMAGES="true"
                
                while [[ $file_index -lt $total_files ]]; do
                    # Start batch of parallel jobs
                    local batch_pids=()
                    local batch_files=()
                    local batch_start=$file_index
                    
                    for ((i=0; i<batch_size && file_index<total_files; i++)); do
                        local video_file="${VIDEO_FILES[$file_index]}"
                        local display_index=$((file_index + 1))  # Calculate display index
                        ((file_index++))
                        batch_files+=("$video_file")

                        # Diagnostics: Log job start
                        if [[ "$DIAGNOSTICS_MODE" == "true" ]]; then
                            local job_start_time=$(date '+%Y-%m-%d %H:%M:%S')
                            echo "[DIAG] Parallel job START: PID=$$ File='$(basename "$video_file")' Index=$display_index Time=$job_start_time" >&2
                        fi

                        (
                            local job_pid=$$
                            
                            if [[ "$DIAGNOSTICS_MODE" == "true" ]]; then
                                local job_start_time=$(date '+%Y-%m-%d %H:%M:%S')
                                echo "[DIAG] [PID $job_pid] Job started: File='$(basename "$video_file")' Index=$display_index Time=$job_start_time" >&2

                                # Diagnostics: Log resource usage at job start
                                echo "[DIAG] [PID $job_pid] Resource usage at start:" >&2
                                top -l 1 | head -n 10 >&2
                            fi

                            # Check if file still exists (may have been moved/deleted by another instance)
                            if [[ ! -f "$video_file" ]]; then
                                echo ""
                                print_info "========================================="
                                print_info "Movie ${display_index}/${total_files}: $(basename "$video_file")"
                                print_info "========================================="
                                echo "⏭️  File no longer exists (moved/processed by another instance)"
                                exit 4  # Exit code 4: already processed
                            fi

                            echo ""
                            print_info "========================================="
                            print_info "Movie ${display_index}/${total_files}: $(basename "$video_file")"
                            print_info "========================================="

                            # Set appropriate cache file based on video resolution
                            set_cache_by_resolution "$video_file"

                            # Diagnostics: Log lock acquisition
                            if [[ "$DIAGNOSTICS_MODE" == "true" ]]; then
                                echo "[DIAG] [PID $job_pid] Attempting to acquire file lock for '$video_file' at $(date '+%Y-%m-%d %H:%M:%S')" >&2
                            fi

                            # Capture exit code without triggering set -e
                            process_file "$video_file" "$AUTO_MODE" || exit_code=$?
                            local exit_code=${exit_code:-0}

                            # Diagnostics: Log job finish
                            if [[ "$DIAGNOSTICS_MODE" == "true" ]]; then
                                local job_finish_time=$(date '+%Y-%m-%d %H:%M:%S')
                                echo "[DIAG] [PID $job_pid] Job finished: File='$(basename "$video_file")' Index=$display_index Time=$job_finish_time ExitCode=$exit_code" >&2

                                # Diagnostics: Log resource usage at job finish
                                echo "[DIAG] [PID $job_pid] Resource usage at finish:" >&2
                                top -l 1 | head -n 10 >&2
                            fi

                            # Exit with the same code so parent can track it
                            exit $exit_code
                        ) &
                        batch_pids+=($!)
                    done
                    
                    # Wait for all jobs in this batch to complete and track exit codes
                    for pid in "${batch_pids[@]}"; do
                        # Use || true to prevent set -e from exiting on non-zero wait codes
                        wait "$pid" || local exit_code=$?
                        local exit_code=${exit_code:-0}
                        
                        case $exit_code in
                            0)
                                # Successfully processed
                                ((success++))
                                ;;
                            2)
                                # Already linked before lock
                                ((already_linked_count++))
                                ;;
                            3)
                                # Locked by another instance
                                ((locked_count++))
                                ;;
                            4)
                                # Already linked after lock
                                ((already_linked_count++))
                                ;;
                            *)
                                # Failed to process
                                ((failed++))
                                ;;
                        esac
                    done
                done
                
                    # Read failed files from temp file (populated by parallel jobs)
                    if [[ -f "${CACHE_DIR}/.failed_parse_$$.tmp" ]]; then
                        while IFS= read -r failed_file; do
                            FAILED_PARSE+=("$failed_file")
                        done < "${CACHE_DIR}/.failed_parse_$$.tmp"
                        rm -f "${CACHE_DIR}/.failed_parse_$$.tmp"
                    fi
                fi  # End of batch mode
                
                # Read failed files from temp file (populated by parallel jobs)
                if [[ -f "${CACHE_DIR}/.failed_parse_$$.tmp" ]]; then
                    while IFS= read -r failed_file; do
                        FAILED_PARSE+=("$failed_file")
                    done < "${CACHE_DIR}/.failed_parse_$$.tmp"
                    rm -f "${CACHE_DIR}/.failed_parse_$$.tmp"
                fi
            else
                # Sequential processing (original behavior)
                for video_file in "${VIDEO_FILES[@]}"; do
                    # Check for interrupt before processing each file
                    check_interrupt
                    
                    ((current_index++))
                    echo ""
                    print_info "========================================="
                    print_info "Movie ${current_index}/${total_files}: $(basename "$video_file")"
                    print_info "========================================="
                    
                    # Check if file still exists (may have been moved/deleted by another instance)
                    if [[ ! -f "$video_file" ]]; then
                        echo "⏭️  File no longer exists (moved/processed by another instance)"
                        ((already_linked_count++))
                        continue
                    fi
                    
                    # Set appropriate cache file based on video resolution
                    set_cache_by_resolution "$video_file"
                    
                    process_file "$video_file" "$AUTO_MODE"
                    local exit_code=$?
                    
                    case $exit_code in
                        0)
                            # Successfully processed
                            ((success++))
                            
                            # Check if TMDb ID or IMDb ID is missing in the created folder
                            # Use the LAST_CREATED_FOLDER variable set by process_file
                            if [[ "$LAST_CREATED_FOLDER" =~ \[tmdbid-\] ]] || [[ "$LAST_CREATED_FOLDER" =~ \[imdbid-\] ]]; then
                                # Extract title and year for tracking (use in-memory cache)
                                local cached_data=$(lookup_parse_cache "$video_file")
                                if [[ -n "$cached_data" ]]; then
                                    PARSED_TITLE="${cached_data%%|*}"
                                    PARSED_YEAR="${cached_data#*|}"
                                else
                                    # Fallback: parse if not in cache
                                    parse_filename "$video_file"
                                fi
                                
                                # Check which IDs are missing
                                local missing_imdb=""
                                local missing_tmdb=""
                                [[ "$LAST_CREATED_FOLDER" =~ \[imdbid-\] ]] && missing_imdb="yes"
                                [[ "$LAST_CREATED_FOLDER" =~ \[tmdbid-\] ]] && missing_tmdb="yes"
                                
                                # Store the destination path for renaming later
                                local dest_path="${DESTINATION}/${LAST_CREATED_FOLDER}"
                                FAILED_LOOKUPS+=("$dest_path|||$PARSED_TITLE|||$PARSED_YEAR|||$missing_imdb|||$missing_tmdb")
                            fi
                            ;;
                        2)
                            # Already linked before lock
                            ((already_linked_count++))
                            ;;
                        3)
                            # Lower bitrate duplicate or locked by another instance
                            # Check the actual message to determine which
                            ((lower_bitrate_count++))
                            ;;
                        4)
                            # Already linked after lock (processed while waiting)
                            ((already_linked_count++))
                            ;;
                        *)
                            # Failed to process
                            ((failed++))
                            print_warning "Skipped: $(basename "$video_file")"
                            
                            # Parse the file to determine if it has title/year
                            parse_filename "$video_file"
                            
                            # If we have title and year, this is a missing ID issue (add to FAILED_LOOKUPS)
                            # Otherwise it's a parse failure (add to FAILED_PARSE)
                            if [[ -n "$PARSED_TITLE" && -n "$PARSED_YEAR" ]]; then
                                # File was parsed but IDs are missing - add to post-processing
                                FAILED_LOOKUPS+=("$video_file|||$PARSED_TITLE|||$PARSED_YEAR|||yes|||yes")
                                should_debug high && echo "[DEBUG] Added to FAILED_LOOKUPS: $PARSED_TITLE ($PARSED_YEAR)" >&2
                            else
                                # File couldn't be parsed at all - add to FAILED_PARSE
                                FAILED_PARSE+=("$video_file")
                                should_debug high && echo "[DEBUG] Added to FAILED_PARSE: $(basename "$video_file")" >&2
                            fi
                            ;;
                    esac
                done
            fi
            
            # Restore previous traps
            if [[ -n "$old_trap" ]]; then
                eval "$old_trap"
            else
                trap - INT
            fi
            
            if [[ -n "$old_exit_trap" ]]; then
                eval "$old_exit_trap"
            else
                trap - EXIT
            fi
            
            # Debug: Show processing results
            local PROCESSING_FINISH_TIME=$(date '+%Y-%m-%d %H:%M:%S')
            
            # Calculate elapsed time
            local processing_elapsed=0
            if [[ -n "$PROCESSING_START_TIME" ]]; then
                local start_epoch=$(date -j -f "%Y-%m-%d %H:%M:%S" "$PROCESSING_START_TIME" "+%s" 2>/dev/null || echo 0)
                local finish_epoch=$(date -j -f "%Y-%m-%d %H:%M:%S" "$PROCESSING_FINISH_TIME" "+%s" 2>/dev/null || echo 0)
                if [[ $start_epoch -gt 0 && $finish_epoch -gt 0 ]]; then
                    processing_elapsed=$((finish_epoch - start_epoch))
                fi
            fi
            local processing_minutes=$((processing_elapsed / 60))
            local processing_seconds=$((processing_elapsed % 60))
            
            echo ""
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "🔍 DEBUG: Instance PID $$ finished processing"
            echo "   Start time: ${PROCESSING_START_TIME:-unknown}"
            echo "   Finish time: $PROCESSING_FINISH_TIME"
            if [[ $processing_elapsed -gt 0 ]]; then
                echo "   Elapsed time: ${processing_minutes}m ${processing_seconds}s"
            fi
            echo "   Total files in array: $total_files"
            echo "   Successfully processed: $success"
            echo "   Lower bitrate duplicates skipped: $lower_bitrate_count"
            echo "   Failed to process: $failed"
            echo "   Already linked (skipped): $already_linked_count"
            echo "   Locked by other instance: $locked_count"
            if [[ ${#FAILED_LOOKUPS[@]} -gt 0 ]]; then
                echo "   With missing IDs: ${#FAILED_LOOKUPS[@]} (processed but ID fetch failed)"
            fi
            echo "   Accounted for: $((success + failed + already_linked_count + locked_count + lower_bitrate_count))/$total_files"
            if [[ $((success + failed + already_linked_count + locked_count + lower_bitrate_count)) -ne $total_files ]]; then
                echo "   ⚠️  WARNING: Numbers don't add up! Missing $((total_files - success - failed - already_linked_count - locked_count - lower_bitrate_count)) files!"
            fi
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo ""
            
            # Show adjusted file count after lower bitrate filtering
            if [[ $lower_bitrate_count -gt 0 ]]; then
                local actual_processed=$((total_files - lower_bitrate_count))
                echo ""
                print_info "Actual unique files processed: $actual_processed (excluded $lower_bitrate_count lower bitrate duplicate(s))"
                echo ""
            fi
            
            # Calculate elapsed time for this source
            local batch_elapsed=$((SECONDS - batch_start_time))
            local batch_minutes=$((batch_elapsed / 60))
            local batch_seconds=$((batch_elapsed % 60))
            
            # Calculate statistics for this source with 2 decimal places
            local avg_time_per_file="0.00"
            if [[ $success -gt 0 ]]; then
                if command -v bc &> /dev/null; then
                    avg_time_per_file=$(echo "scale=2; $batch_elapsed / $success" | bc)
                else
                    avg_time_per_file=$(awk "BEGIN {printf \"%.2f\", $batch_elapsed / $success}")
                fi
            fi
            
            # Calculate total size processed for this source
            local source_size=0
            for video_file in "${VIDEO_FILES[@]}"; do
                # Check for interrupt during size calculation
                check_interrupt
                
                local file_size=$(stat -f "%z" "$video_file" 2>/dev/null || stat -c "%s" "$video_file" 2>/dev/null)
                source_size=$((source_size + file_size))
            done
            overall_size=$((overall_size + source_size))
            local size_gb=$((source_size / 1073741824))
            local size_mb=$(((source_size % 1073741824) / 1048576))
            
            # Count cache entries using the already-set CACHE_FILE variable
            local total_cache_entries=0
            [[ -f "$CACHE_FILE" ]] && total_cache_entries=$(wc -l < "$CACHE_FILE" | tr -d ' ')
            
            # Determine cache name for display
            local cache_name=""
            case "$CACHE_FILE" in
                *"UNIFIED CACHE.txt") cache_name="Unified cache" ;;
                *"4K CACHE.txt") cache_name="4K cache" ;;
                *"1080p CACHE.txt") cache_name="1080p cache" ;;
                *"1080p SOFTCORE CACHE.txt") cache_name="1080p Softcore cache" ;;
                *"4K SOFTCORE CACHE.txt") cache_name="4K Softcore cache" ;;
                *"CARTOONS CACHE.txt") cache_name="Cartoons cache" ;;
                *"ANIME CACHE.txt") cache_name="Anime cache" ;;
                *) cache_name="cache" ;;
            esac
            
            echo ""
            # Combine newly processed and already-linked for display
            local total_completed=$((success + already_linked_count))
            print_success "Completed: $total_completed successful ($success new, $already_linked_count already linked), $failed skipped"
            print_info "Hardlinking/Batch time: ${batch_minutes}m ${batch_seconds}s (avg ${avg_time_per_file}s per file)"
            print_info "Data processed: ${size_gb}.$(printf "%03d" $size_mb) GB"
            local new_entries=$((total_cache_entries - cache_entries_before))
            print_info "Cache entries: $cache_entries_before → $total_cache_entries (+$new_entries new)"
            [[ -n "$cache_name" ]] && print_info "  • Using: $cache_name"
            total_success=$((total_success + success))
            total_failed=$((total_failed + failed))
            overall_success=$((overall_success + success + already_linked_count))
            overall_failed=$((overall_failed + failed))
        fi
    
   
    
    # Calculate overall statistics
    local overall_elapsed=$((SECONDS - overall_start_time))
    local overall_minutes=$((overall_elapsed / 60))
    local overall_seconds=$((overall_elapsed % 60))
    
    local overall_avg_time="0.00"
    if [[ $overall_success -gt 0 ]]; then
        # Calculate with 2 decimal places using bc or awk
        if command -v bc &> /dev/null; then
            overall_avg_time=$(echo "scale=2; $overall_elapsed / $overall_success" | bc)
        else
            # Fallback to awk if bc not available
            overall_avg_time=$(awk "BEGIN {printf \"%.2f\", $overall_elapsed / $overall_success}")
        fi
    fi
    
    local overall_size_gb=$((overall_size / 1073741824))
    local overall_size_mb=$(((overall_size % 1073741824) / 1048576))
    
    # Read API call count from file (for parallel processing)
    if [[ -f "$API_COUNTER_FILE" ]]; then
        API_CALL_COUNT=$(wc -l < "$API_COUNTER_FILE" | tr -d ' ')
        rm -f "$API_COUNTER_FILE"
    fi
    
    # Get cache statistics
    local overall_cache_after=0
    [[ -f "$CACHE_FILE" ]] && overall_cache_after=$(awk 'NF' "$CACHE_FILE" 2>/dev/null | wc -l | tr -d ' ' || echo 0)
    local cache_entries_before=0
    local new_cache_entries=0
    if [[ -f "${CACHE_DIR}/movie_cache_before.txt" ]]; then
        cache_entries_before=$(cat "${CACHE_DIR}/movie_cache_before.txt")
        new_cache_entries=$((overall_cache_after - cache_entries_before))
        rm -f "${CACHE_DIR}/movie_cache_before.txt"
    fi
    
    # Summary with detailed statistics
    echo ""
    local STATISTICS_TIME=$(date '+%Y-%m-%d %H:%M:%S')
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${CYAN}MOVIE PROCESSING STATISTICS${NC}"
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
    print_info "Instance PID: $$"
    print_info "Started: ${PROCESSING_START_TIME:-unknown}"
    print_info "Finished: $STATISTICS_TIME"
    echo ""
    print_info "Files found: $ORIGINAL_FILE_COUNT total"
    if [[ ${EXTENSION_DUPLICATES_FILTERED:-0} -gt 0 ]]; then
        print_info "Extension duplicates filtered: $EXTENSION_DUPLICATES_FILTERED (lower bitrate/resolution)"
        
        # Show details of kept vs rejected files in table format
        if [[ -f "$EXTENSION_DUP_LOG" ]]; then
            echo ""
            echo -e "${CYAN}Extension Duplicate Details:${NC}"
            echo -e "${DIM}────────────────────────────────────────────────────────────────────────────────${NC}"
            
            # Group by folder for table display
            local current_folder=""
            local folder_files=()
            local folder_statuses=()
            local folder_resolutions=()
            local folder_bitrates=()
            local folder_sizes=()
            local folder_reasons=()
            
            while IFS='|' read -r status filepath resolution bitrate reason; do
                local folder=$(dirname "$filepath")
                
                # If we hit a new folder, print the previous folder's table
                if [[ -n "$current_folder" && "$folder" != "$current_folder" ]]; then
                    # Print table for this folder
                    local parent_folder=$(basename "$current_folder")
                    echo -e "${CYAN}Folder: ${parent_folder}${NC}"
                    printf "%-51s %-13s %-16s %-13s %-15s %-25s\n" "File" "Status" "Resolution" "Bitrate" "Size" "Reason"
                    printf "%-51s %-13s %-16s %-13s %-15s %-25s\n" "$(printf '%.0s─' {1..51})" "$(printf '%.0s─' {1..13})" "$(printf '%.0s─' {1..16})" "$(printf '%.0s─' {1..13})" "$(printf '%.0s─' {1..15})" "$(printf '%.0s─' {1..25})"
                    
                    for i in "${!folder_files[@]}"; do
                        local filename=$(basename "${folder_files[$i]}")
                        local status_display=""
                        local color=""
                        local reason_text=""
                        
                        if [[ "${folder_statuses[$i]}" == "KEPT" ]]; then
                            status_display="✓ Kept"
                            color="${GREEN}"
                            if [[ "${folder_reasons[$i]}" == "bitrate" ]]; then
                                reason_text="Higher bitrate"
                            else
                                reason_text="Higher resolution"
                            fi
                        else
                            status_display="✗ Rejected"
                            color="${RED}"
                            if [[ "${folder_reasons[$i]}" == "bitrate" ]]; then
                                reason_text="Lower bitrate"
                            else
                                reason_text="Lower resolution"
                            fi
                        fi
                        
                        # Print filename in color, then reset and print rest without color interference
                        local bitrate_formatted=$(format_bitrate "${folder_bitrates[$i]}")
                        printf "${color}%-51s${NC} ${color}%-13s${NC} %-16s %-13s %-15s %-25s\n" \
                            "${filename:0:49}" \
                            "$status_display" \
                            "${folder_resolutions[$i]}" \
                            "$bitrate_formatted" \
                            "${folder_sizes[$i]}" \
                            "$reason_text"
                    done
                    echo ""
                    
                    # Reset arrays
                    folder_files=()
                    folder_statuses=()
                    folder_resolutions=()
                    folder_bitrates=()
                    folder_sizes=()
                    folder_reasons=()
                fi
                
                current_folder="$folder"
                
                # Get file size
                local file_size="N/A"
                if [[ -f "$filepath" ]]; then
                    local size_bytes=$(stat -f%z "$filepath" 2>/dev/null || stat -c%s "$filepath" 2>/dev/null || echo 0)
                    file_size=$(format_bytes "$size_bytes")
                fi
                
                # Add to arrays
                folder_files+=("$filepath")
                folder_statuses+=("$status")
                folder_resolutions+=("$resolution")
                folder_bitrates+=("$bitrate")
                folder_sizes+=("$file_size")
                folder_reasons+=("$reason")
            done < "$EXTENSION_DUP_LOG"
            
            # Print last folder's table
            if [[ -n "$current_folder" ]]; then
                local parent_folder=$(basename "$current_folder")
                echo -e "${CYAN}Folder: ${parent_folder}${NC}"
                printf "%-51s %-13s %-16s %-13s %-15s %-25s\n" "File" "Status" "Resolution" "Bitrate" "Size" "Reason"
                printf "%-51s %-13s %-16s %-13s %-15s %-25s\n" "$(printf '%.0s─' {1..51})" "$(printf '%.0s─' {1..13})" "$(printf '%.0s─' {1..16})" "$(printf '%.0s─' {1..13})" "$(printf '%.0s─' {1..15})" "$(printf '%.0s─' {1..25})"
                
                for i in "${!folder_files[@]}"; do
                    local filename=$(basename "${folder_files[$i]}")
                    local status_display=""
                    local color=""
                    local reason_text=""
                    
                    if [[ "${folder_statuses[$i]}" == "KEPT" ]]; then
                        status_display="✓ Kept"
                        color="${GREEN}"
                        if [[ "${folder_reasons[$i]}" == "bitrate" ]]; then
                            reason_text="Higher bitrate"
                        else
                            reason_text="Higher resolution"
                        fi
                    else
                        status_display="✗ Rejected"
                        color="${RED}"
                        if [[ "${folder_reasons[$i]}" == "bitrate" ]]; then
                            reason_text="Lower bitrate"
                        else
                            reason_text="Lower resolution"
                        fi
                    fi
                    
                    # Print filename in color, then reset and print rest without color interference
                    local bitrate_formatted=$(format_bitrate "${folder_bitrates[$i]}")
                    printf "${color}%-51s${NC} ${color}%-13s${NC} %-16s %-13s %-15s %-25s\n" \
                        "${filename:0:49}" \
                        "$status_display" \
                        "${folder_resolutions[$i]}" \
                        "$bitrate_formatted" \
                        "${folder_sizes[$i]}" \
                        "$reason_text"
                done
                echo ""
            fi
            
            echo -e "${DIM}────────────────────────────────────────────────────────────────────────────────${NC}"
        fi
    fi
        
    print_info "Files after filtering: $FILTERED_FILE_COUNT"
    
    if [[ ${FILES_AFTER_CLAIMING:-$ORIGINAL_FILE_COUNT} -lt $ORIGINAL_FILE_COUNT ]]; then
        local claimed_by_others=$((ORIGINAL_FILE_COUNT - FILES_AFTER_CLAIMING))
        print_info "Files claimed by other instances: $claimed_by_others"
        print_info "Files claimed by this instance: $FILES_AFTER_CLAIMING"
    fi
    if [[ ${EXTENSION_DUPLICATES_FILTERED:-0} -gt 0 ]]; then
        local other_duplicates=$((${DUPLICATES_DETECTED:-0} - ${EXTENSION_DUPLICATES_FILTERED:-0}))
        if [[ $other_duplicates -gt 0 ]]; then
            print_info "Extension duplicates filtered: ${EXTENSION_DUPLICATES_FILTERED:-0}"
            print_info "Other duplicates detected: $other_duplicates file(s)"
            print_info "Total duplicates: $DUPLICATES_DETECTED file(s)"
        else
            print_info "Extension duplicates filtered: ${EXTENSION_DUPLICATES_FILTERED:-0} (all duplicates were extension-based)"
        fi
        print_info "Unique files to process: $TOTAL_FILES_FOUND"
    elif [[ ${DUPLICATES_DETECTED:-0} -gt 0 ]]; then
        print_info "Duplicates detected: $DUPLICATES_DETECTED file(s) (non-extension based)"
        print_info "Unique files to process: $TOTAL_FILES_FOUND"
    fi
    print_success "Files processed: $overall_success/${FILTERED_FILE_COUNT:-$ORIGINAL_FILE_COUNT} successful, $total_failed failed"
    print_info "Total processing time: ${overall_minutes}m ${overall_seconds}s (avg ${overall_avg_time}s per file)"
    print_info "  └─ Includes: file scanning, duplicate detection, filtering, hardlinking, and post-processing"
    
    # Calculate files per second (rounded to 2 decimal places)
    local files_per_second="0.00"
    if [[ $overall_elapsed -gt 0 && $overall_success -gt 0 ]]; then
        if command -v bc &> /dev/null; then
            files_per_second=$(echo "scale=2; $overall_success / $overall_elapsed" | bc)
        else
            files_per_second=$(awk "BEGIN {printf \"%.2f\", $overall_success / $overall_elapsed}")
        fi
    fi
    print_info "Processing rate: $files_per_second files/sec"
    
    print_info "Data processed: ${overall_size_gb}.$(printf "%03d" $overall_size_mb) GB"
    if [[ $new_cache_entries -gt 0 ]]; then
        print_info "Movie cache entries: $cache_entries_before → $overall_cache_after (+$new_cache_entries new)"
    fi
    
    # Display cache mode
    local cache_display="${CACHE_MODE:-unified}"
    case "$cache_display" in
        unified) cache_display="Unified cache" ;;
        4k) cache_display="4K cache" ;;
        1080p) cache_display="1080p cache" ;;
        1080p_softcore) cache_display="1080p Softcore cache" ;;
        4k_softcore) cache_display="4K Softcore cache" ;;
        cartoons) cache_display="Cartoons cache" ;;
        anime) cache_display="Anime cache" ;;
    esac
    print_info "  • Using: ${CYAN}${cache_display}${NC}"
    
    # API call statistics
    if [[ $API_CALL_COUNT -gt 0 ]]; then
        local api_rate="0.00"
        if [[ $overall_elapsed -gt 0 ]]; then
            # Use bash arithmetic: multiply by 100, divide, then format
            local rate_calc=$(( (API_CALL_COUNT * 100) / overall_elapsed ))
            api_rate=$(printf "%d.%02d" $((rate_calc / 100)) $((rate_calc % 100)))
        fi
        print_info "API calls: $API_CALL_COUNT total (${api_rate}/sec average)"
    else
        print_info "API calls: 0 (all files found in cache)"
    fi
    
    # ID fetch statistics
    if [[ ${#FAILED_LOOKUPS[@]} -gt 0 ]]; then
        echo ""
        local missing_both=0
        local missing_imdb_only=0
        local missing_tmdb_only=0
        
        for entry in "${FAILED_LOOKUPS[@]}"; do
            IFS='|||' read -r file title year missing_imdb missing_tmdb <<< "$entry"
            if [[ "$missing_imdb" == "yes" && "$missing_tmdb" == "yes" ]]; then
                ((missing_both++))
            elif [[ "$missing_imdb" == "yes" ]]; then
                ((missing_imdb_only++))
            elif [[ "$missing_tmdb" == "yes" ]]; then
                ((missing_tmdb_only++))
            fi
        done
        
        print_warning "ID fetch issues: ${#FAILED_LOOKUPS[@]} file(s) processed with missing IDs"
        if [[ $missing_both -gt 0 ]]; then
            print_info "  • Missing both IMDb & TMDb: $missing_both file(s)"
        fi
        if [[ $missing_imdb_only -gt 0 ]]; then
            print_info "  • Missing IMDb only: $missing_imdb_only file(s)"
        fi
        if [[ $missing_tmdb_only -gt 0 ]]; then
            print_info "  • Missing TMDb only: $missing_tmdb_only file(s)"
        fi
        print_info "  ${DIM}(Files were processed successfully but with placeholder IDs)${NC}"
    fi
    echo ""
    
    # Show rejected files (files that parsed but were rejected for other reasons)
    # Read from temp file to ensure cross-function persistence
    local rejected_temp_file="${CACHE_DIR}/.rejected_files_$$.tmp"
    if [[ -f "$rejected_temp_file" ]]; then
        local rejected_count=$(wc -l < "$rejected_temp_file" | tr -d ' ')
        if [[ $rejected_count -gt 0 ]]; then
            echo ""
            echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
            echo -e "${YELLOW}⚠  ${rejected_count} FILE(S) REJECTED${NC}"
            echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
            echo ""
            while IFS= read -r line; do
                local rejected_file="${line%|||*}"
                local reject_reason="${line#*|||}"
                echo -e "  ${YELLOW}⚠${NC} ${reject_reason}"
                echo -e "     ${DIM}Location: $rejected_file${NC}"
                echo ""
            done < "$rejected_temp_file"
            echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
            echo ""
        fi
        # Clean up temp file
        rm -f "$rejected_temp_file"
    fi
    
    # Show files that couldn't be parsed (DISPLAY FIRST - before interactive prompts)
    if [[ ${#FAILED_PARSE[@]} -gt 0 ]]; then
        echo ""
        echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${RED}⚠  ${#FAILED_PARSE[@]} FILE(S) COULD NOT BE PARSED${NC}"
        echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
        echo -e "${YELLOW}These files could not be processed because the title and/or year could not be detected:${NC}"
        echo -e "${CYAN}━━━ FOLDER/FILENAME EXAMPLES ━━━${NC}"
        echo -e "  ${GREEN}✓ Good:${NC} ${DIM}Weird.science.1985.REMASTERED/ → watchable-sd.mkv${NC} ${GREEN}(folder has title+year)${NC}"
        echo -e "  ${GREEN}✓ Good:${NC} ${DIM}Movie.Title.2020.1080p.mkv${NC} ${GREEN}(filename has title+year)${NC}"
        echo -e "  ${GREEN}✓ Good:${NC} ${DIM}The.Matrix.1999/ → movie.mkv${NC} ${GREEN}(folder has title+year)${NC}"
        echo -e "  ${RED}✗ Bad:${NC}  ${DIM}downloads/ → watchable-moviename-sd.mkv${NC} ${YELLOW}(no year anywhere)${NC}"
        echo -e "  ${RED}✗ Bad:${NC}  ${DIM}unsorted/ → movie.mkv${NC} ${YELLOW}(no title or year anywhere)${NC}"
        echo ""
        for failed_file in "${FAILED_PARSE[@]}"; do
            echo -e "  ${RED}✗${NC} $(basename "$failed_file")"
            echo -e "     ${DIM}Full path: $failed_file${NC}"
        done
        echo ""
        echo -e "${CYAN}━━━ WHY THIS HAPPENED ━━━${NC}"
        echo -e "The script requires ${YELLOW}either the folder name OR filename${NC} to contain both:"
        echo -e "  ${YELLOW}1.${NC} Movie title"
        echo -e "  ${YELLOW}2.${NC} Year (4 digits: 1900-2099)"
        echo -e "${DIM}(Script checks folder name first, then filename as fallback)${NC}"
        echo -e "${DIM}(Script checks folder name first, then filename as fallback)${NC}"
        echo ""
        echo -e "${CYAN}━━━ FOLDER/FILENAME EXAMPLES ━━━${NC}"
        echo -e "  ${GREEN}✓ Good:${NC} ${DIM}Guts.Of.A.Virgin.1986.REMASTERED/ → watchable-sd.mkv${NC} ${GREEN}(folder has title+year)${NC}"
        echo -e "  ${GREEN}✓ Good:${NC} ${DIM}Movie.Title.2020.1080p.mkv${NC} ${GREEN}(filename has title+year)${NC}"
        echo -e "  ${GREEN}✓ Good:${NC} ${DIM}The.Matrix.1999/ → movie.mkv${NC} ${GREEN}(folder has title+year)${NC}"
        echo -e "  ${RED}✗ Bad:${NC}  ${DIM}downloads/ → watchable-moviename-sd.mkv${NC} ${YELLOW}(no year anywhere)${NC}"
        echo -e "  ${RED}✗ Bad:${NC}  ${DIM}unsorted/ → movie.mkv${NC} ${YELLOW}(no title or year anywhere)${NC}"
        echo ""
        echo -e "${CYAN}━━━ HOW TO FIX ━━━${NC}"
        echo -e "${GREEN}Option 1:${NC} Rename the files to include title and year"
        echo -e "  ${DIM}The mv command in Unix/Linux systems is used to move or rename files and directories${NC}"
        echo -e "  ${DIM}Rename Example: mv 'watchable-weirdscience-sd.mkv' 'Weird.Science.1985.mkv'${NC}"
        echo ""
        echo -e "${GREEN}Option 2:${NC} Process these files now by manually entering title and year"
        echo -e "  ${DIM}You'll be prompted for each file individually${NC}"
        echo ""
        echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
        
        # Ask if user wants to manually process unparseable files
        print_info "Would you like to manually enter title/year for these files now? (y/n):"
        read -r process_failed_parse
        
        if [[ "$process_failed_parse" =~ ^[Yy]$ ]]; then
            echo ""
            print_info "Processing unparseable files with manual entry..."
            echo ""
            
            local parse_success=0
            local parse_failed=0
            
            for failed_file in "${FAILED_PARSE[@]}"; do
                echo ""
                echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                echo -e "${CYAN}File:${NC} $(basename "$failed_file")"
                echo -e "${DIM}Path: $failed_file${NC}"
                echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                echo ""
                
                # Ask if user wants to process this specific file
                print_info "Process this file? (y/n/q to quit):"
                read -r process_this_file
                
                if [[ "$process_this_file" =~ ^[Qq]$ ]]; then
                    print_info "Skipping remaining files"
                    break
                elif [[ ! "$process_this_file" =~ ^[Yy]$ ]]; then
                    print_info "Skipping this file"
                    ((parse_failed++))
                    continue
                fi
                
                # Temporarily disable auto mode for manual entry
                local old_auto_mode="$AUTO_MODE"
                AUTO_MODE="false"
                
                if process_file "$failed_file" "$AUTO_MODE"; then
                    ((parse_success++))
                    print_success "Successfully processed"
                else
                    ((parse_failed++))
                    print_warning "Failed to process"
                fi
                
                # Restore auto mode
                AUTO_MODE="$old_auto_mode"
            done
            
            echo ""
            print_success "Manual processing complete: $parse_success successful, $parse_failed skipped"
        else
            print_info "Skipping manual entry for unparseable files"
        fi
    fi
    
    # POST-PROCESSING PHASE 0: Review extension duplicate selections (FIRST)
    if [[ ${EXTENSION_DUPLICATES_FILTERED:-0} -gt 0 && -f "$EXTENSION_DUP_LOG" && "$EXTENSION_DUP_MODE" == "manual" ]]; then
        echo ""
        print_info "========================================="
        print_info "Post-Processing: Review Extension Duplicates in Same Folder"
        print_info "========================================="
        echo ""
        
        print_warning "The script automatically selected files based on resolution/bitrate"
        print_info "You can review and change these selections if needed"
        echo ""
        
        # Ask if user wants to review selections
        local review_dupes=""
        read -r -p "$(print_info "Do you want to review extension duplicate selections? (y/n): ")" review_dupes
        echo ""
        
        if [[ "$review_dupes" =~ ^[Yy]$ ]]; then
            echo ""
            print_info "Reviewing extension duplicate selections..."
            echo ""
            
            # Parse the log file and group by folder (Bash 3.2 compatible)
            # Format: folder_path<TAB>KEPT<TAB>filepath|resolution|bitrate|reason
            # Format: folder_path<TAB>REJECTED<TAB>filepath|resolution|bitrate
            local temp_grouped="/tmp/movie_ext_dup_grouped_$$"
            > "$temp_grouped"
            
            while IFS='|' read -r status filepath resolution bitrate reason; do
                [[ -z "$filepath" ]] && continue
                local folder=$(dirname "$filepath")
                if [[ "$status" == "KEPT" ]]; then
                    echo "$folder"$'\t'"KEPT"$'\t'"$filepath|$resolution|$bitrate|$reason" >> "$temp_grouped"
                elif [[ "$status" == "REJECTED" ]]; then
                    echo "$folder"$'\t'"REJECTED"$'\t'"$filepath|$resolution|$bitrate" >> "$temp_grouped"
                fi
            done < "$EXTENSION_DUP_LOG"
            
            # Get unique folders
            local -a unique_folders=()
            while IFS=$'\t' read -r folder rest; do
                local already_added=false
                for existing in "${unique_folders[@]}"; do
                    [[ "$existing" == "$folder" ]] && already_added=true && break
                done
                [[ "$already_added" == "false" ]] && unique_folders+=("$folder")
            done < "$temp_grouped"
            
            # Review each folder group
            for folder in "${unique_folders[@]}"; do
                [[ -z "$folder" ]] && continue
                
                # Get kept file for this folder
                local kept_path="" kept_res="" kept_bitrate="" kept_reason=""
                while IFS=$'\t' read -r grp_folder status data; do
                    if [[ "$grp_folder" == "$folder" ]] && [[ "$status" == "KEPT" ]]; then
                        IFS='|' read -r kept_path kept_res kept_bitrate kept_reason <<< "$data"
                        break
                    fi
                done < "$temp_grouped"
                
                [[ -z "$kept_path" ]] && continue
                
                # Get rejected files for this folder
                local -a rejected_paths=()
                local -a rejected_resolutions=()
                local -a rejected_bitrates=()
                while IFS=$'\t' read -r grp_folder status data; do
                    if [[ "$grp_folder" == "$folder" ]] && [[ "$status" == "REJECTED" ]]; then
                        local rej_path rej_res rej_bitrate
                        IFS='|' read -r rej_path rej_res rej_bitrate <<< "$data"
                        rejected_paths+=("$rej_path")
                        rejected_resolutions+=("$rej_res")
                        rejected_bitrates+=("$rej_bitrate")
                    fi
                done < "$temp_grouped"
                
                echo ""
                echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                echo -e "${CYAN}Folder: $(basename "$folder")${NC}"
                echo -e "${DIM}$folder${NC}"
                echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                echo ""
                echo -e "${GREEN}Currently selected (kept):${NC}"
                echo -e "  ${GREEN}✓${NC} $(basename "$kept_path")"
                
                # Get file size for kept file
                local kept_size=$(stat -f%z "$kept_path" 2>/dev/null || stat -c%s "$kept_path" 2>/dev/null || echo 0)
                local kept_size_display=$(format_bytes "$kept_size")
                
                echo -e "    Resolution: $kept_res | Bitrate: $kept_bitrate | Size: $kept_size_display"
                if [[ "$kept_reason" == "bitrate" ]]; then
                    echo -e "    ${CYAN}Reason: Higher bitrate (same resolution)${NC}"
                else
                    echo -e "    ${CYAN}Reason: Higher resolution${NC}"
                fi
                
                if [[ ${#rejected_paths[@]} -gt 0 ]]; then
                    echo ""
                    echo -e "${YELLOW}Rejected files:${NC}"
                    for i in "${!rejected_paths[@]}"; do
                        # Get file size for rejected file
                        local rej_size=$(stat -f%z "${rejected_paths[$i]}" 2>/dev/null || stat -c%s "${rejected_paths[$i]}" 2>/dev/null || echo 0)
                        local rej_size_display=$(format_bytes "$rej_size")
                        
                        echo -e "  ${RED}✗${NC} $(basename "${rejected_paths[$i]}")"
                        echo -e "    Resolution: ${rejected_resolutions[$i]} | Bitrate: ${rejected_bitrates[$i]} | Size: $rej_size_display"
                    done
                fi
                
                echo ""
                echo -e "${YELLOW}Do you want to change the selection for this group? (y/n):${NC}"
                read -r change_selection
                
                if [[ "$change_selection" =~ ^[Yy]$ ]]; then
                    # Build array of all files (kept + rejected)
                    local -a all_files=("$kept_path")
                    local -a all_resolutions=("$kept_res")
                    local -a all_bitrates=("$kept_bitrate")
                    local -a all_sizes=()
                    
                    # Get file size for kept file
                    local kept_size=$(stat -f%z "$kept_path" 2>/dev/null || stat -c%s "$kept_path" 2>/dev/null || echo 0)
                    all_sizes+=("$kept_size")
                    
                    for i in "${!rejected_paths[@]}"; do
                        all_files+=("${rejected_paths[$i]}")
                        all_resolutions+=("${rejected_resolutions[$i]}")
                        all_bitrates+=("${rejected_bitrates[$i]}")
                        
                        # Get file size for rejected file
                        local rej_size=$(stat -f%z "${rejected_paths[$i]}" 2>/dev/null || stat -c%s "${rejected_paths[$i]}" 2>/dev/null || echo 0)
                        all_sizes+=("$rej_size")
                    done
                    
                    echo ""
                    echo -e "${CYAN}Select which file to keep:${NC}"
                    
                    for i in "${!all_files[@]}"; do
                        local idx=$((i + 1))
                        local file="${all_files[$i]}"
                        local is_current=""
                        [[ "$file" == "$kept_path" ]] && is_current=" ${GREEN}(current)${NC}"
                        
                        # Format file size and bitrate using format functions
                        local size_bytes="${all_sizes[$i]}"
                        local size_display=$(format_bytes "$size_bytes")
                        local bitrate_display=$(format_bitrate "${all_bitrates[$i]}")
                        
                        echo -e "  ${CYAN}$idx)${NC} $(basename "$file")$is_current"
                        echo -e "     Resolution: ${all_resolutions[$i]} | Bitrate: ${bitrate_display} | Size: ${size_display}"
                    done
                    
                    echo ""
                    echo -e "${YELLOW}Enter number (1-${#all_files[@]}):${NC}"
                    read -r selection_num
                    
                    if [[ "$selection_num" =~ ^[0-9]+$ ]] && [[ $selection_num -ge 1 ]] && [[ $selection_num -le ${#all_files[@]} ]]; then
                        local selected_idx=$((selection_num - 1))
                        local selected_file="${all_files[$selected_idx]}"
                        
                        if [[ "$selected_file" != "$kept_path" ]]; then
                            echo ""
                            print_info "Switching selection to: $(basename "$selected_file")"
                            
                            # Step 1: Remove the kept file's hardlink from destination
                            local kept_filename=$(basename "$kept_path")
                            local dest_file=""
                            local dest_folder=""
                            
                            print_info "Searching for existing kept file in destination..."
                            
                            # Get the inode of the kept file to find its hardlinks
                            if [[ -f "$kept_path" ]]; then
                                local kept_inode=$(ls -i "$kept_path" | awk '{print $1}')
                                
                                # Search destination for files with same inode (hardlinks)
                                while IFS= read -r -d '' potential_link; do
                                    local link_inode=$(ls -i "$potential_link" | awk '{print $1}')
                                    if [[ "$link_inode" == "$kept_inode" ]]; then
                                        dest_file="$potential_link"
                                        dest_folder=$(dirname "$dest_file")
                                        print_info "Found kept file: $(basename "$dest_folder")/$(basename "$dest_file")"
                                        print_info "Removing: $(basename "$dest_file")"
                                        rm -f "$dest_file"
                                        break
                                    fi
                                done < <(find "$DESTINATION" -type f -print0 2>/dev/null)
                            fi
                            
                            # Step 2: Remove any existing hardlinks of the newly selected file
                            print_info "Checking for existing hardlinks of selected file..."
                            if [[ -f "$selected_file" ]]; then
                                local selected_inode=$(ls -i "$selected_file" | awk '{print $1}')
                                local removed_count=0
                                
                                # Find and remove all hardlinks of the selected file in destination
                                while IFS= read -r -d '' existing_link; do
                                    print_info "Removing existing hardlink: $(basename "$(dirname "$existing_link")")/$(basename "$existing_link")"
                                    rm -f "$existing_link"
                                    ((removed_count++))
                                done < <(find "$DESTINATION" -type f -inum "$selected_inode" -print0 2>/dev/null)
                                
                                [[ $removed_count -gt 0 ]] && print_info "Removed $removed_count existing hardlink(s)"
                            fi
                            
                            # Step 3: Process the newly selected file through normal pipeline
                            echo ""
                            print_info "Processing newly selected file..."
                            
                            # Process the file normally, bypassing duplicate check (third parameter = true)
                            # This allows the manually selected file to be processed even if it's lower quality
                            if process_file "$selected_file" "$AUTO_MODE" "true"; then
                                print_success "Successfully processed: $(basename "$selected_file")"
                            else
                                print_error "Failed to process selected file"
                                
                                # If processing failed and we removed the old file, try to restore it
                                if [[ -n "$dest_file" && -n "$dest_folder" && -d "$dest_folder" ]]; then
                                    print_warning "Attempting to restore original file..."
                                    if ln "$kept_path" "$dest_file" 2>/dev/null; then
                                        print_info "Restored: $(basename "$dest_file")"
                                    fi
                                fi
                            fi
                        else
                            print_info "No change - keeping current selection"
                        fi
                    else
                        print_error "Invalid selection"
                    fi
                else
                    print_info "Keeping current selection"
                fi
            done
            
            # Clean up temp file
            rm -f "$temp_grouped" 2>/dev/null
            
            echo ""
            print_success "Extension duplicate review complete"
        else
            print_info "Skipping extension duplicate review"
        fi
    fi
    
    # POST-PROCESSING PHASE 1: Handle files with missing IDs (FIRST)
    if [[ ${#FAILED_LOOKUPS[@]} -gt 0 ]]; then
        handle_missing_ids_post_processing
    fi
    
    # POST-PROCESSING PHASE 2: Handle duplicate movies (process AFTER missing IDs)
    if [[ ${#ALL_DUPLICATE_FILES[@]} -gt 0 ]]; then
        echo ""
        print_info "========================================="
        print_info "Post-Processing: Duplicate Movies in Different Folders"
        print_info "========================================="
        echo ""
        
        print_warning "Found ${#ALL_DUPLICATE_FILES[@]} duplicate file(s) that were skipped during initial processing"
        print_info "These files have the same title and year as other files in the source"
        echo ""
        
        # Ask if user wants to process duplicates now
        local process_dupes=""
        stty echo 2>/dev/null
        read -r -p "$(print_info "Do you want to review and process duplicate movies now? (y/n): ")" process_dupes
        stty -echo 2>/dev/null
        echo ""
        
        if [[ "$process_dupes" =~ ^[Yy]$ ]]; then
            echo ""
            print_info "Processing duplicate movies..."
            echo ""
            
            # Set cache file based on cache mode before processing
            set_cache_by_resolution ""
            
            # Use the interactive duplicate selection
            local -a SELECTED_DUPES=()
            while IFS= read -r file; do
                [[ -n "$file" ]] && SELECTED_DUPES+=("$file")
            done < <(select_duplicates_to_process "${ALL_DUPLICATE_FILES[@]}")
            
            if [[ ${#SELECTED_DUPES[@]} -gt 0 ]]; then
                print_success "Processing ${#SELECTED_DUPES[@]} selected duplicate(s)"
                echo ""
                
                local dup_success=0
                local dup_failed=0
                local dup_start_time=$SECONDS
                local dup_cache_entries_before=0
                
                # Count cache entries before duplicate processing
                local cache_mode_file="$CACHE_DIR/cache_mode.txt"
                local cache_mode="4k"
                [[ -f "$cache_mode_file" ]] && cache_mode=$(cat "$cache_mode_file")
                
                case "$cache_mode" in
                    unified)
                        [[ -f "$CACHE_DIR/MOVIE UNIFIED CACHE.txt" ]] && dup_cache_entries_before=$(wc -l < "$CACHE_DIR/MOVIE UNIFIED CACHE.txt" | tr -d ' ')
                        ;;
                    4k)
                        [[ -f "$CACHE_DIR/MOVIE 4K CACHE.txt" ]] && dup_cache_entries_before=$(wc -l < "$CACHE_DIR/MOVIE 4K CACHE.txt" | tr -d ' ')
                        ;;
                    1080p)
                        [[ -f "$CACHE_DIR/MOVIE 1080p CACHE.txt" ]] && dup_cache_entries_before=$(wc -l < "$CACHE_DIR/MOVIE 1080p CACHE.txt" | tr -d ' ')
                        ;;
                    1080p_softcore)
                        [[ -f "$CACHE_DIR/MOVIE 1080p SOFTCORE CACHE.txt" ]] && dup_cache_entries_before=$(wc -l < "$CACHE_DIR/MOVIE 1080p SOFTCORE CACHE.txt" | tr -d ' ')
                        ;;
                    4k_softcore)
                        [[ -f "$CACHE_DIR/MOVIE 4K SOFTCORE CACHE.txt" ]] && dup_cache_entries_before=$(wc -l < "$CACHE_DIR/MOVIE 4K SOFTCORE CACHE.txt" | tr -d ' ')
                        ;;
                esac
                
                # Check if parallel processing is enabled for duplicates
                echo -e "${YELLOW}[DIAG] Parallel check: PARALLEL_PROCESSING='${PARALLEL_PROCESSING}' AUTO_MODE='${AUTO_MODE}' DUPES=${#SELECTED_DUPES[@]}${NC}" >&2
                
                if [[ "$PARALLEL_PROCESSING" == "true" && "$AUTO_MODE" == "y" && ${#SELECTED_DUPES[@]} -ge 2 ]]; then
                    # Load rolling queue mode setting
                    [[ -f "${CACHE_DIR}/rolling_queue_mode.txt" ]] && ROLLING_QUEUE_MODE=$(cat "${CACHE_DIR}/rolling_queue_mode.txt")
                    
                    echo -e "${YELLOW}[DIAG] Entering parallel processing: ROLLING_QUEUE_MODE='${ROLLING_QUEUE_MODE}'${NC}" >&2
                    
                    if [[ "$ROLLING_QUEUE_MODE" == "true" ]]; then
                        print_success "Parallel processing enabled for duplicates: ${PARALLEL_JOBS} simultaneous jobs (rolling queue)"
                    else
                        print_success "Parallel processing enabled for duplicates: ${PARALLEL_JOBS} simultaneous jobs (batch mode)"
                    fi
                    echo ""
                    
                    if [[ "$ROLLING_QUEUE_MODE" == "true" ]]; then
                        # Use rolling queue approach - start new jobs as soon as slots open
                        local -a active_pids=()
                        local -a active_files=()
                        local -a active_indices=()
                        local dup_index=0
                        local dup_total=${#SELECTED_DUPES[@]}
                        
                        # Disable posters during parallel processing to prevent terminal corruption
                        export DISABLE_IMAGES="true"
                        
                        # Main processing loop - continuously check for completed jobs and start new ones
                        while [[ $dup_index -lt $dup_total ]] || [[ ${#active_pids[@]} -gt 0 ]]; do
                            # First, check for completed jobs (non-blocking)
                            for i in "${!active_pids[@]}"; do
                                local pid="${active_pids[$i]}"
                                if ! kill -0 "$pid" 2>/dev/null; then
                                    # Job completed
                                    local completed_file="${active_files[$i]}"
                                    local completed_idx="${active_indices[$i]}"
                                    
                                    # Check exit status
                                    wait "$pid" 2>/dev/null
                                    local exit_status=$?
                                    
                                    if [[ $exit_status -eq 0 ]]; then
                                        ((dup_success++))
                                        ((total_success++))
                                    else
                                        ((dup_failed++))
                                        ((total_failed++))
                                        print_warning "Skipped: $(basename "$completed_file")"
                                        FAILED_PARSE+=("$completed_file")
                                    fi
                                    
                                    # Diagnostics
                                    if [[ "$DIAGNOSTICS_MODE" == "true" ]]; then
                                        local job_end_time=$(date '+%Y-%m-%d %H:%M:%S')
                                        echo "[DIAG] Parallel duplicate job END: File='$(basename "$completed_file")' Time=$job_end_time" >&2
                                    fi
                                    
                                    # Remove from arrays
                                    unset 'active_pids[$i]'
                                    unset 'active_files[$i]'
                                    unset 'active_indices[$i]'
                                fi
                            done
                            
                            # Compact arrays
                            active_pids=("${active_pids[@]}")
                            active_files=("${active_files[@]}")
                            active_indices=("${active_indices[@]}")
                            
                            # Now start new jobs for any available slots
                            while [[ ${#active_pids[@]} -lt $PARALLEL_JOBS ]] && [[ $dup_index -lt $dup_total ]]; do
                                local dup_file="${SELECTED_DUPES[$dup_index]}"
                                local display_index=$((dup_index + 1))
                                ((dup_index++))
                                
                                # Show rolling queue activity
                                echo -e "${DIM}[QUEUE] Starting job ${display_index}/${dup_total} (active: ${#active_pids[@]}/${PARALLEL_JOBS})${NC}" >&2
                                
                                # Diagnostics: Log job start
                                if [[ "$DIAGNOSTICS_MODE" == "true" ]]; then
                                    local job_start_time=$(date '+%Y-%m-%d %H:%M:%S')
                                    echo "[DIAG] Parallel duplicate job START: File='$(basename "$dup_file")' Index=$display_index Time=$job_start_time" >&2
                                fi
                                
                                (
                                    echo ""
                                    print_info "========================================="
                                    print_info "Duplicate ${display_index}/${dup_total}: $(basename "$dup_file")"
                                    print_info "========================================="
                                    
                                    if process_file "$dup_file" "$AUTO_MODE"; then
                                        exit 0  # Success
                                    else
                                        exit 1  # Failure
                                    fi
                                ) &
                                
                                local job_pid=$!
                                active_pids+=("$job_pid")
                                active_files+=("$dup_file")
                                active_indices+=("$display_index")
                            done
                            
                            # Small sleep to prevent CPU spinning, but only if jobs are still running
                            if [[ ${#active_pids[@]} -gt 0 ]]; then
                                sleep 0.1
                            fi
                        done
                    
                    else
                        # Batch processing mode - wait for entire batch before starting next
                        local batch_size=$PARALLEL_JOBS
                        local dup_index=0
                        local dup_total=${#SELECTED_DUPES[@]}
                        
                        # Disable posters during parallel processing to prevent terminal corruption
                        export DISABLE_IMAGES="true"
                        
                        while [[ $dup_index -lt $dup_total ]]; do
                            # Start batch of parallel jobs
                            local batch_pids=()
                            local batch_files=()
                            
                            for ((i=0; i<batch_size && dup_index<dup_total; i++)); do
                                local dup_file="${SELECTED_DUPES[$dup_index]}"
                                local display_index=$((dup_index + 1))
                                ((dup_index++))
                                batch_files+=("$dup_file")
                                
                                # Diagnostics: Log job start
                                if [[ "$DIAGNOSTICS_MODE" == "true" ]]; then
                                    local job_start_time=$(date '+%Y-%m-%d %H:%M:%S')
                                    echo "[DIAG] Parallel duplicate job START: File='$(basename "$dup_file")' Index=$display_index Time=$job_start_time" >&2
                                fi
                                
                                (
                                    echo ""
                                    print_info "========================================="
                                    print_info "Duplicate ${display_index}/${dup_total}: $(basename "$dup_file")"
                                    print_info "========================================="
                                    
                                    if process_file "$dup_file" "$AUTO_MODE"; then
                                        exit 0  # Success
                                    else
                                        exit 1  # Failure
                                    fi
                                ) &
                                
                                batch_pids+=($!)
                            done
                            
                            # Wait for entire batch to complete
                            for j in "${!batch_pids[@]}"; do
                                local pid="${batch_pids[$j]}"
                                local dup_file="${batch_files[$j]}"
                                
                                if wait "$pid"; then
                                    ((dup_success++))
                                    ((total_success++))
                                else
                                    ((dup_failed++))
                                    ((total_failed++))
                                    print_warning "Skipped: $(basename "$dup_file")"
                                    FAILED_PARSE+=("$dup_file")
                                fi
                                
                                # Diagnostics: Log job completion
                                if [[ "$DIAGNOSTICS_MODE" == "true" ]]; then
                                    local job_end_time=$(date '+%Y-%m-%d %H:%M:%S')
                                    echo "[DIAG] Parallel duplicate job END: File='$(basename "$dup_file")' Time=$job_end_time" >&2
                                fi
                            done
                        done
                    fi
                    
                else
                    # Sequential processing for duplicates
                    for dup_file in "${SELECTED_DUPES[@]}"; do
                        echo ""
                        print_info "========================================="
                        print_info "File: $(basename "$dup_file")"
                        print_info "========================================="
                        
                        if process_file "$dup_file" "$AUTO_MODE"; then
                            ((dup_success++))
                            ((total_success++))
                        else
                            ((dup_failed++))
                            ((total_failed++))
                            print_warning "Skipped: $(basename "$dup_file")"
                            # Track files that couldn't be parsed
                            FAILED_PARSE+=("$dup_file")
                        fi
                    done
                fi
                
                # Calculate elapsed time
                local dup_elapsed=$((SECONDS - dup_start_time))
                local dup_minutes=$((dup_elapsed / 60))
                local dup_seconds=$((dup_elapsed % 60))
                
                # Calculate average time per file with 2 decimal places
                local dup_avg_time="0.00"
                if [[ $dup_success -gt 0 ]]; then
                    if command -v bc &> /dev/null; then
                        dup_avg_time=$(echo "scale=2; $dup_elapsed / $dup_success" | bc)
                    else
                        dup_avg_time=$(awk "BEGIN {printf \"%.2f\", $dup_elapsed / $dup_success}")
                    fi
                fi
                
                # Calculate total size processed
                local dup_total_size=0
                for dup_file in "${SELECTED_DUPES[@]}"; do
                    local file_size=$(stat -f "%z" "$dup_file" 2>/dev/null || stat -c "%s" "$dup_file" 2>/dev/null)
                    dup_total_size=$((dup_total_size + file_size))
                done
                local dup_size_gb=$((dup_total_size / 1073741824))
                local dup_size_mb=$(((dup_total_size % 1073741824) / 1048576))
                
                # Count cache entries after duplicate processing
                local dup_cache_entries_after=0
                case "$cache_mode" in
                    unified)
                        [[ -f "$CACHE_DIR/MOVIE UNIFIED CACHE.txt" ]] && dup_cache_entries_after=$(wc -l < "$CACHE_DIR/MOVIE UNIFIED CACHE.txt" | tr -d ' ')
                        ;;
                    4k)
                        [[ -f "$CACHE_DIR/MOVIE 4K CACHE.txt" ]] && dup_cache_entries_after=$(wc -l < "$CACHE_DIR/MOVIE 4K CACHE.txt" | tr -d ' ')
                        ;;
                    1080p)
                        [[ -f "$CACHE_DIR/MOVIE 1080p CACHE.txt" ]] && dup_cache_entries_after=$(wc -l < "$CACHE_DIR/MOVIE 1080p CACHE.txt" | tr -d ' ')
                        ;;
                    1080p_softcore)
                        [[ -f "$CACHE_DIR/MOVIE 1080p SOFTCORE CACHE.txt" ]] && dup_cache_entries_after=$(wc -l < "$CACHE_DIR/MOVIE 1080p SOFTCORE CACHE.txt" | tr -d ' ')
                        ;;
                    4k_softcore)
                        [[ -f "$CACHE_DIR/MOVIE 4K SOFTCORE CACHE.txt" ]] && dup_cache_entries_after=$(wc -l < "$CACHE_DIR/MOVIE 4K SOFTCORE CACHE.txt" | tr -d ' ')
                        ;;
                esac
                local dup_new_entries=$((dup_cache_entries_after - dup_cache_entries_before))
                
                echo ""
                print_success "Duplicate processing complete: $dup_success successful, $dup_failed skipped"
                print_info "Time: ${dup_minutes}m ${dup_seconds}s (avg ${dup_avg_time}s per file)"
                print_info "Data processed: ${dup_size_gb}.$(printf "%03d" $dup_size_mb) GB"
                print_info "Cache entries: $dup_cache_entries_before → $dup_cache_entries_after (+$dup_new_entries new)"
                echo ""
            else
                print_warning "No duplicates selected for processing"
                print_info "Note: Duplicate files were not saved to cache"
            fi
        else
            print_info "Skipping duplicate processing"
            print_info "Note: Duplicate files were not saved to cache"
        fi
    fi
    
    # Scan destination for existing files/folders with missing IDs
    if [[ -d "$DESTINATION" ]]; then
        echo ""
        print_info "Scanning destination for files with missing IDs..."
        
        # Use awk for fast pattern matching instead of find loop
        find "$DESTINATION" -mindepth 1 -maxdepth 1 \( -type d -o -type f \) 2>/dev/null | awk -F'/' '
        {
            item = $0
            item_name = $NF
            
            # Check for empty ID patterns
            has_empty = 0
            if (match(item_name, /\[imdbid-\]/) || match(item_name, /\[tmdbid-\]/) || \
                match(item_name, /\[imdb-\]/) || match(item_name, /\[tmdb-\]/) || \
                match(item_name, /\{imdb-\}/) || match(item_name, /\{tmdb-\}/)) {
                has_empty = 1
            }
            
            if (has_empty) {
                # Extract title and year using BSD awk compatible method
                if (match(item_name, /\([0-9]{4}\)/)) {
                    year_match = substr(item_name, RSTART+1, RLENGTH-2)
                    title_match = substr(item_name, 1, RSTART-2)
                    
                    # Check which IDs are missing
                    missing_imdb = ""
                    missing_tmdb = ""
                    
                    if (match(item_name, /\[imdbid-\]/) || match(item_name, /\[imdb-\]/) || match(item_name, /\{imdb-\}/)) {
                        missing_imdb = "yes"
                    }
                    
                    if (match(item_name, /\[tmdbid-\]/) || match(item_name, /\[tmdb-\]/) || match(item_name, /\{tmdb-\}/)) {
                        missing_tmdb = "yes"
                    }
                    
                    print item "|||" title_match "|||" year_match "|||" missing_imdb "|||" missing_tmdb
                }
            }
        }
        ' | while IFS='|||' read -r item title year missing_imdb missing_tmdb; do
            # Check if already tracked
            local already_tracked=0
            for existing in "${FAILED_LOOKUPS[@]}"; do
                if [[ "$existing" =~ ^"$item"(\||\$) ]]; then
                    already_tracked=1
                    break
                fi
            done
            
            if [[ $already_tracked -eq 0 ]]; then
                FAILED_LOOKUPS+=("$item|||$title|||$year|||$missing_imdb|||$missing_tmdb")
            fi
        done
        
        if [[ ${#FAILED_LOOKUPS[@]} -gt 0 ]]; then
            print_success "Found ${#FAILED_LOOKUPS[@]} folder(s) with missing IDs"
        else
            print_success "No files with missing IDs found"
        fi
        
        # Scan for duplicate IMDb/TMDb IDs in destination (video files only)
        echo ""
        print_info "Scanning destination for duplicate IDs..."
        
        # Create temporary files for tracking IDs
        local tmp_imdb_file=$(mktemp)
        local tmp_tmdb_file=$(mktemp)
        
        # Scan video files at depth 2 and extract ID from parent folder
        # Only flag as duplicate when multiple VIDEO files share the same IMDb/TMDb ID
        while IFS= read -r -d '' video_file; do
            local parent_folder=$(dirname "$video_file")
            local folder_name=$(basename "$parent_folder")
            
            # Extract IMDb ID from parent folder name
            if [[ "$folder_name" =~ \[imdbid-(tt[0-9]+)\] ]]; then
                echo "${BASH_REMATCH[1]}|$video_file" >> "$tmp_imdb_file"
            elif [[ "$folder_name" =~ \[imdb-(tt[0-9]+)\] ]]; then
                echo "${BASH_REMATCH[1]}|$video_file" >> "$tmp_imdb_file"
            elif [[ "$folder_name" =~ \{imdb-(tt[0-9]+)\} ]]; then
                echo "${BASH_REMATCH[1]}|$video_file" >> "$tmp_imdb_file"
            fi
            
            # Extract TMDb ID from parent folder name
            if [[ "$folder_name" =~ \[tmdbid-([0-9]+)\] ]]; then
                echo "${BASH_REMATCH[1]}|$video_file" >> "$tmp_tmdb_file"
            elif [[ "$folder_name" =~ \[tmdb-([0-9]+)\] ]]; then
                echo "${BASH_REMATCH[1]}|$video_file" >> "$tmp_tmdb_file"
            elif [[ "$folder_name" =~ \{tmdb-([0-9]+)\} ]]; then
                echo "${BASH_REMATCH[1]}|$video_file" >> "$tmp_tmdb_file"
            fi
        done < <(find "$DESTINATION" -mindepth 2 -maxdepth 2 -type f \( -name "*.mkv" -o -name "*.mp4" -o -name "*.avi" -o -name "*.m4v" -o -name "*.mov" -o -name "*.wmv" -o -name "*.flv" -o -name "*.webm" \) -print0 2>/dev/null)
        
        # Find duplicate IMDb IDs (handle 2+ duplicates properly)
        local duplicate_imdb_count=0
        if [[ -f "$tmp_imdb_file" && -s "$tmp_imdb_file" ]]; then
            # Group by ID and collect all paths for each duplicate ID
            local duplicate_ids=$(sort "$tmp_imdb_file" | awk -F'|' '{id=$1; count[id]++} END {for (i in count) if (count[i] > 1) print i}')
            
            if [[ -n "$duplicate_ids" ]]; then
                echo ""
                print_warning "Found duplicate IMDb IDs:"
                
                # Convert to array for proper stdin handling
                local -a duplicate_ids_array=()
                while IFS= read -r id; do
                    [[ -n "$id" ]] && duplicate_ids_array+=("$id")
                done <<< "$duplicate_ids"
                
                # Process each duplicate with proper stdin
                for id in "${duplicate_ids_array[@]}"; do
                    # Get all items with this ID
                    local items=$(grep "^${id}|" "$tmp_imdb_file" | cut -d'|' -f2)
                    local item_count=$(echo "$items" | wc -l | tr -d ' ')
                    
                    echo ""
                    echo -e "  ${YELLOW}IMDb ID: $id (${item_count} items)${NC}"
                    
                    local idx=1
                    while IFS= read -r item_path; do
                        echo -e "    ${DIM}${idx}. $(basename "$item_path")${NC}"
                        
                        # Show source path if it's a hardlink
                        if [[ -f "$item_path" ]]; then
                            local inode=$(stat -f "%i" "$item_path" 2>/dev/null || stat -c "%i" "$item_path" 2>/dev/null)
                            local link_count=$(stat -f "%l" "$item_path" 2>/dev/null || stat -c "%h" "$item_path" 2>/dev/null)
                            
                            if [[ "$link_count" -gt 1 && -n "$inode" ]]; then
                                # Search in parent directory of SOURCE to find hardlinks in any subfolder
                                local search_dir="$(dirname "$SOURCE")"
                                local source_file=$(find "$search_dir" -type f -inum "$inode" 2>/dev/null | head -1)
                                if [[ -n "$source_file" ]]; then
                                    echo -e "    ${DIM}   Source: $source_file${NC}"
                                fi
                            fi
                        fi
                        
                        echo -e "    ${DIM}   Full path: $item_path${NC}"
                        ((idx++))
                    done <<< "$items"
                    
                    ((duplicate_imdb_count++))
                    
                    echo ""
                    echo -e "${YELLOW}Would you like to correct the IDs for these items? (y/n):${NC}"
                    stty echo 2>/dev/null
                    read -r correct_choice </dev/tty
                    stty -echo 2>/dev/null
                    if [[ "$correct_choice" == "y" ]]; then
                        # Build selection prompt based on number of items
                        if [[ "$item_count" -eq 2 ]]; then
                            echo -e "${YELLOW}Which items to correct? (1=first only, 2=second only, b=both):${NC}"
                        else
                            echo -e "${YELLOW}Which items to correct? (comma-separated numbers like 1,3 or 'a' for all):${NC}"
                        fi
                        stty echo 2>/dev/null
                        read -r item_choice </dev/tty
                        stty -echo 2>/dev/null
                        
                        local -a items_to_correct=()
                        local -a items_array=()
                        
                        # Convert items to array
                        while IFS= read -r item_path; do
                            items_array+=("$item_path")
                        done <<< "$items"
                        
                        # Parse selection
                        if [[ "$item_choice" == "a" ]]; then
                            items_to_correct=("${items_array[@]}")
                        elif [[ "$item_choice" == "b" && "$item_count" -eq 2 ]]; then
                            items_to_correct=("${items_array[@]}")
                        elif [[ "$item_choice" =~ ^[0-9,]+$ ]]; then
                            IFS=',' read -ra selections <<< "$item_choice"
                            for sel in "${selections[@]}"; do
                                sel=$(echo "$sel" | tr -d ' ')
                                if [[ "$sel" =~ ^[0-9]+$ ]] && [[ "$sel" -ge 1 ]] && [[ "$sel" -le "$item_count" ]]; then
                                    items_to_correct+=("${items_array[$((sel-1))]}")
                                fi
                            done
                        elif [[ "$item_choice" =~ ^[0-9]+$ ]]; then
                            local sel="$item_choice"
                            if [[ "$sel" -ge 1 ]] && [[ "$sel" -le "$item_count" ]]; then
                                items_to_correct=("${items_array[$((sel-1))]}")
                            fi
                        else
                            print_warning "Invalid choice, skipping correction"
                            continue
                        fi
                        
                        if [[ ${#items_to_correct[@]} -eq 0 ]]; then
                            print_warning "No valid items selected, skipping correction"
                            continue
                        fi
                        
                        # Process each selected item
                        for item_to_correct in "${items_to_correct[@]}"; do
                            echo ""
                            echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                            echo -e "${GREEN}Correcting: $(basename "$item_to_correct")${NC}"
                            
                            # Find hardlink source by inode
                            if [[ -f "$item_to_correct" ]]; then
                                local inode=$(stat -f "%i" "$item_to_correct" 2>/dev/null || stat -c "%i" "$item_to_correct" 2>/dev/null)
                                local link_count=$(stat -f "%l" "$item_to_correct" 2>/dev/null || stat -c "%h" "$item_to_correct" 2>/dev/null)
                                
                                if [[ "$link_count" -gt 1 && -n "$inode" ]]; then
                                    # This is a hardlink - find the source
                                    local source_file=""
                                    if [[ -n "$SOURCE" && -d "$SOURCE" ]]; then
                                        # Search in parent directory of SOURCE to find hardlinks in any subfolder
                                        local search_dir="$(dirname "$SOURCE")"
                                        source_file=$(find "$search_dir" -type f -inum "$inode" 2>/dev/null | head -1)
                                    fi
                                    
                                    if [[ -n "$source_file" ]]; then
                                        echo -e "${DIM}Source:      $source_file${NC}"
                                    else
                                        echo -e "${DIM}Source:      (hardlink source not found in SOURCE directory)${NC}"
                                    fi
                                else
                                    echo -e "${DIM}Source:      (not a hardlink)${NC}"
                                fi
                            fi
                            
                            echo -e "${DIM}Destination: $item_to_correct${NC}"
                            echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                            
                            # Extract title and year from folder name
                            local folder_name=$(basename "$item_to_correct")
                            local title_year=$(echo "$folder_name" | sed -E 's/[[:space:]]*\[imdb.*$//')
                            local movie_title=$(echo "$title_year" | sed -E 's/[[:space:]]*\([0-9]{4}\)[[:space:]]*$//')
                            local movie_year=$(echo "$title_year" | grep -oE '\([0-9]{4}\)' | tr -d '()')
                            
                            local new_id=""
                            
                            # Always offer IMDb autocomplete for duplicate corrections
                            echo -e "${YELLOW}Use IMDb autocomplete to search for correct ID? (y/n):${NC}"
                            stty echo 2>/dev/null
                            read -r use_autocomplete </dev/tty
                            stty -echo 2>/dev/null
                            if [[ "$use_autocomplete" == "y" ]]; then
                                new_id=$(imdb_autocomplete_search "$movie_title" "$movie_year" || true)
                            fi
                            
                            # If autocomplete wasn't used or failed, ask for manual entry
                            if [[ -z "$new_id" ]]; then
                                echo -e "${YELLOW}Enter correct IMDb ID (tt followed by digits) or TMDb ID (just digits), or 's' to skip:${NC}"
                                stty echo 2>/dev/null
                                read -r new_id </dev/tty
                                stty -echo 2>/dev/null
                                
                                if [[ "$new_id" == "s" || -z "$new_id" ]]; then
                                    print_warning "Skipping correction for this item"
                                    continue
                                fi
                            fi
                            
                            # Determine if it's IMDb or TMDb
                            local new_imdb=""
                            local new_tmdb=""
                            if [[ "$new_id" =~ ^tt[0-9]+$ ]]; then
                                new_imdb="$new_id"
                                print_info "Updating to IMDb ID: $new_imdb"
                                # Get TMDb ID from IMDb using /find endpoint
                                if [[ -n "$TMDB_API_KEY" ]]; then
                                    local find_url="${TMDB_API_BASE}/find/${new_imdb}?api_key=${TMDB_API_KEY}&external_source=imdb_id"
                                    local result=$(curl -s "$find_url" 2>/dev/null)
                                    new_tmdb=$(echo "$result" | grep -oE '"id":[0-9]+' | head -1 | grep -oE '[0-9]+')
                                    [[ -n "$new_tmdb" ]] && echo "  TMDb ID: $new_tmdb"
                                fi
                            elif [[ "$new_id" =~ ^[0-9]+$ ]]; then
                                new_tmdb="$new_id"
                                print_info "Updating to TMDb ID: $new_tmdb"
                                # Get IMDb from TMDb
                                new_imdb=$(get_imdb_from_tmdb "$new_tmdb")
                                [[ -n "$new_imdb" ]] && echo "  IMDb ID: $new_imdb"
                            else
                                print_error "Invalid ID format (use tt123456 for IMDb or 123456 for TMDb)"
                                continue
                            fi
                            
                            # Fetch actual movie details from API for the new ID
                            local correct_title="$movie_title"
                            local correct_year="$movie_year"
                            if [[ -n "$new_tmdb" && -n "$TMDB_API_KEY" ]]; then
                                local movie_url="${TMDB_API_BASE}/movie/${new_tmdb}?api_key=${TMDB_API_KEY}"
                                local movie_data=$(curl -s "$movie_url" 2>/dev/null)
                                if [[ -n "$movie_data" ]]; then
                                    local api_title=$(echo "$movie_data" | grep -oE '"title":"[^"]+' | head -1 | sed 's/"title":"//')
                                    local api_year=$(echo "$movie_data" | grep -oE '"release_date":"[0-9]{4}' | head -1 | grep -oE '[0-9]{4}')
                                    [[ -n "$api_title" ]] && correct_title="$api_title"
                                    [[ -n "$api_year" ]] && correct_year="$api_year"
                                fi
                            fi
                            
                            # Update cache entry if it exists
                            if [[ -n "$CACHE_FILE" && -f "$CACHE_FILE" && -n "$movie_title" && -n "$movie_year" ]]; then
                                # Remove old cache entry (case-insensitive match)
                                local temp_cache=$(mktemp)
                                awk -F'|' -v title="$movie_title" -v year="$movie_year" \
                                    'BEGIN{IGNORECASE=1} tolower($1) != tolower(title) || $2 != year {print}' "$CACHE_FILE" > "$temp_cache"
                                mv "$temp_cache" "$CACHE_FILE"
                                
                                # Add new cache entry with correct title/year from API
                                echo "${correct_title}|${correct_year}|${new_imdb}|${new_tmdb}|$(date +%s)" >> "$CACHE_FILE"
                                print_success "✓ Updated cache entry for: $correct_title ($correct_year)"
                            fi
                            
                            # Rename the folder/file with new ID
                            local old_file_path="$item_to_correct"
                            local old_folder_path=$(dirname "$old_file_path")
                            local old_folder_name=$(basename "$old_folder_path")
                            local old_file_name=$(basename "$old_file_path")
                            
                            # correct_title and correct_year are already set from API fetch above
                            
                            # Extract edition tag from old folder name for preservation
                            local folder_edition_tag=$(echo "$old_folder_name" | grep -oiE '(THEATRICAL|EXTENDED|UNRATED|REMASTERED|RESTORED|IMAX|REDUX|DIRECTORS?[[:space:]]CUT|UNCUT|ULTIMATE|FINAL[[:space:]]CUT)' | head -1 | tr '[:lower:]' '[:upper:]')
                            
                            # Create new folder name with corrected title, year, and IDs
                            local new_folder_name=""
                            if [[ -n "$correct_title" && -n "$correct_year" ]]; then
                                # Use actual title and year from cache
                                local canonical_title=$(echo "$correct_title" | sed 's/[^a-zA-Z0-9]/-/g' | sed 's/-\+/-/g' | sed 's/^-\|-$//g')
                                new_folder_name="${canonical_title} (${correct_year})"
                                [[ -n "$folder_edition_tag" ]] && new_folder_name="${new_folder_name} ${folder_edition_tag}"
                                new_folder_name="${new_folder_name} [imdbid-${new_imdb}]"
                            else
                                # Fallback: just replace the ID in the old folder name
                                new_folder_name="$old_folder_name"
                                if [[ -n "$new_imdb" ]]; then
                                    new_folder_name=$(echo "$new_folder_name" | sed -E "s/\[imdbid-tt[0-9]+\]/[imdbid-$new_imdb]/")
                                    new_folder_name=$(echo "$new_folder_name" | sed -E "s/\[imdb-tt[0-9]+\]/[imdb-$new_imdb]/")
                                    new_folder_name=$(echo "$new_folder_name" | sed -E "s/\{imdb-tt[0-9]+\}/[imdb-$new_imdb]/")
                                fi
                                if [[ -n "$new_tmdb" ]]; then
                                    new_folder_name=$(echo "$new_folder_name" | sed -E "s/\[tmdbid-[0-9]+\]/[tmdbid-$new_tmdb]/")
                                    new_folder_name=$(echo "$new_folder_name" | sed -E "s/\[tmdb-[0-9]+\]/[tmdb-$new_tmdb]/")
                                    new_folder_name=$(echo "$new_folder_name" | sed -E "s/\{tmdb-[0-9]+\}/[tmdb-$new_tmdb]/")
                                fi
                            fi
                            
                            # Create new file name with corrected title, year, and IDs
                            local new_file_name=""
                            if [[ -n "$correct_title" && -n "$correct_year" ]]; then
                                # Extract quality, codec, edition, and release group from old filename
                                local quality_tag=$(echo "$old_file_name" | grep -oE '\[([Bb]luray|[Ww][Ee][Bb]|HDTV|DVDRip)(-[0-9]+p)?\]' | head -1)
                                local audio_tag=$(echo "$old_file_name" | grep -oE '\[([AD][A-Z]+[^]]*|[0-9]\.[0-9])\]' | head -1)
                                local codec_tag=$(echo "$old_file_name" | grep -oE '\[(x26[45]|[Hh]26[45]|[Hh][Ee][Vv][Cc]|AVC|HEVC)\]' | head -1)
                                # Extract edition tags (THEATRICAL, EXTENDED, UNRATED, etc.)
                                local edition_tag=$(echo "$old_file_name" | grep -oiE '(THEATRICAL|EXTENDED|UNRATED|REMASTERED|RESTORED|IMAX|REDUX|DIRECTORS?[[:space:]]CUT|UNCUT|ULTIMATE|FINAL[[:space:]]CUT)' | head -1 | tr '[:lower:]' '[:upper:]')
                                local release_group=$(echo "$old_file_name" | grep -oE '\-[A-Za-z0-9.]+\.(mkv|mp4|avi)$' | sed 's/^\-//;s/\.[^.]*$//')
                                local extension="${old_file_name##*.}"
                                
                                # Build new filename
                                local canonical_title=$(echo "$correct_title" | sed 's/[^a-zA-Z0-9]/-/g' | sed 's/-\+/-/g' | sed 's/^-\|-$//g')
                                new_file_name="${canonical_title} (${correct_year})"
                                [[ -n "$edition_tag" ]] && new_file_name="${new_file_name} ${edition_tag}"
                                new_file_name="${new_file_name} [imdbid-${new_imdb}]"
                                [[ -n "$quality_tag" ]] && new_file_name="${new_file_name} ${quality_tag}"
                                [[ -n "$audio_tag" ]] && new_file_name="${new_file_name} ${audio_tag}"
                                [[ -n "$codec_tag" ]] && new_file_name="${new_file_name} ${codec_tag}"
                                [[ -n "$release_group" ]] && new_file_name="${new_file_name}-${release_group}"
                                new_file_name="${new_file_name}.${extension}"
                            else
                                # Fallback: just replace the ID in the old filename
                                new_file_name="$old_file_name"
                                if [[ -n "$new_imdb" ]]; then
                                    new_file_name=$(echo "$new_file_name" | sed -E "s/\[imdbid-tt[0-9]+\]/[imdbid-$new_imdb]/")
                                    new_file_name=$(echo "$new_file_name" | sed -E "s/\[imdb-tt[0-9]+\]/[imdb-$new_imdb]/")
                                    new_file_name=$(echo "$new_file_name" | sed -E "s/\{imdb-tt[0-9]+\}/[imdb-$new_imdb]/")
                                fi
                                if [[ -n "$new_tmdb" ]]; then
                                    new_file_name=$(echo "$new_file_name" | sed -E "s/\[tmdbid-[0-9]+\]/[tmdbid-$new_tmdb]/")
                                    new_file_name=$(echo "$new_file_name" | sed -E "s/\[tmdb-[0-9]+\]/[tmdb-$new_tmdb]/")
                                    new_file_name=$(echo "$new_file_name" | sed -E "s/\{tmdb-[0-9]+\}/[tmdb-$new_tmdb]/")
                                fi
                            fi
                            
                            if [[ "$new_folder_name" != "$old_folder_name" || "$new_file_name" != "$old_file_name" ]]; then
                                local dest_base=$(dirname "$old_folder_path")
                                local new_folder_path="$dest_base/$new_folder_name"
                                local new_file_path="$new_folder_path/$new_file_name"
                                
                                # Create new folder if it doesn't exist
                                if [[ ! -d "$new_folder_path" ]]; then
                                    mkdir -p "$new_folder_path"
                                    print_info "Created new folder: $new_folder_name"
                                fi
                                
                                # Find source file by inode to remake hardlink
                                if [[ -f "$old_file_path" ]]; then
                                    local inode=$(stat -f "%i" "$old_file_path" 2>/dev/null || stat -c "%i" "$old_file_path" 2>/dev/null)
                                    local link_count=$(stat -f "%l" "$old_file_path" 2>/dev/null || stat -c "%h" "$old_file_path" 2>/dev/null)
                                    
                                    if [[ "$link_count" -gt 1 && -n "$inode" ]]; then
                                        # This is a hardlink - find the source and remake it
                                        local source_file=""
                                        if [[ -n "$SOURCE" && -d "$SOURCE" ]]; then
                                            # Search in parent directory of SOURCE to find hardlinks in any subfolder
                                            local search_dir="$(dirname "$SOURCE")"
                                            source_file=$(find "$search_dir" -type f -inum "$inode" 2>/dev/null | head -1)
                                        fi
                                        
                                        if [[ -n "$source_file" && -f "$source_file" ]]; then
                                            # Remove old hardlink
                                            rm -f "$old_file_path"
                                            # Create new hardlink
                                            ln "$source_file" "$new_file_path" 2>/dev/null || cp "$source_file" "$new_file_path"
                                            print_success "✓ Recreated hardlink: $new_file_name"
                                            print_info "  New location: $new_file_path"
                                        else
                                            # Source not found, just move the file
                                            print_warning "  Hardlink source not found (inode: $inode), moving file instead"
                                            mv "$old_file_path" "$new_file_path"
                                            print_success "✓ Moved file: $new_file_name"
                                            print_info "  New location: $new_file_path"
                                        fi
                                    else
                                        # Not a hardlink, just move it
                                        mv "$old_file_path" "$new_file_path"
                                        print_success "✓ Moved file: $new_file_name"
                                        print_info "  New location: $new_file_path"
                                    fi
                                    
                                    # Move any subtitle/extra files from old folder to new folder
                                    local moved_extras=0
                                    if [[ -d "$old_folder_path" ]]; then
                                        while IFS= read -r extra_file; do
                                            [[ ! -f "$extra_file" ]] && continue
                                            local extra_name=$(basename "$extra_file")
                                            local new_extra_name="$extra_name"
                                            
                                            # Update IDs in extra file names
                                            if [[ -n "$new_imdb" ]]; then
                                                new_extra_name=$(echo "$new_extra_name" | sed -E "s/\[imdbid-tt[0-9]+\]/[imdbid-$new_imdb]/")
                                                new_extra_name=$(echo "$new_extra_name" | sed -E "s/\[imdb-tt[0-9]+\]/[imdb-$new_imdb]/")
                                            fi
                                            if [[ -n "$new_tmdb" ]]; then
                                                new_extra_name=$(echo "$new_extra_name" | sed -E "s/\[tmdbid-[0-9]+\]/[tmdbid-$new_tmdb]/")
                                                new_extra_name=$(echo "$new_extra_name" | sed -E "s/\[tmdb-[0-9]+\]/[tmdb-$new_tmdb]/")
                                            fi
                                            
                                            mv "$extra_file" "$new_folder_path/$new_extra_name"
                                            ((moved_extras++))
                                        done < <(find "$old_folder_path" -maxdepth 1 -type f \( -name "*.srt" -o -name "*.ass" -o -name "*.sub" -o -name "*.idx" -o -name "*.nfo" -o -name "*.jpg" -o -name "*.png" \) 2>/dev/null)
                                        
                                        [[ $moved_extras -gt 0 ]] && print_info "  Moved $moved_extras extra file(s)"
                                        
                                        # Clean up empty old folder
                                        if [[ -d "$old_folder_path" ]]; then
                                            if [[ -z "$(ls -A "$old_folder_path" 2>/dev/null)" ]]; then
                                                rmdir "$old_folder_path"
                                                print_info "  Cleaned up empty folder: $old_folder_name"
                                            fi
                                        fi
                                    fi
                                fi
                            else
                                print_warning "No changes needed (IDs already correct)"
                            fi
                        done
                    fi
                done
            fi
        fi
        
        # Find duplicate TMDb IDs
        local duplicate_tmdb_count=0
        if [[ -f "$tmp_tmdb_file" && -s "$tmp_tmdb_file" ]]; then
            local tmdb_duplicates=$(sort "$tmp_tmdb_file" | awk -F'|' '{id=$1; path=$2; if (seen[id]) print id"|"seen[id]"|"path; seen[id]=path}')
            if [[ -n "$tmdb_duplicates" ]]; then
                echo ""
                print_warning "Found duplicate TMDb IDs:"
                
                # Convert to array for proper stdin handling
                local -a tmdb_dup_array=()
                while IFS='|' read -r id first_item second_item; do
                    [[ -n "$id" ]] && tmdb_dup_array+=("$id|$first_item|$second_item")
                done <<< "$tmdb_duplicates"
                
                # Process each duplicate with proper stdin
                for entry in "${tmdb_dup_array[@]}"; do
                    IFS='|' read -r id first_item second_item <<< "$entry"
                    
                    echo ""
                    echo -e "  ${YELLOW}TMDb ID: $id${NC}"
                    echo -e "    ${DIM}1. $(basename "$first_item")${NC}"
                    echo -e "    ${DIM}   Full path: $first_item${NC}"
                    echo -e "    ${DIM}2. $(basename "$second_item")${NC}"
                    echo -e "    ${DIM}   Full path: $second_item${NC}"
                    ((duplicate_tmdb_count++))
                    
                    # Check if titles are similar (for IMDb autocomplete suggestion)
                    local first_title=$(basename "$first_item" | sed -E 's/[[:space:]]*\([0-9]{4}\).*$//')
                    local second_title=$(basename "$second_item" | sed -E 's/[[:space:]]*\([0-9]{4}\).*$//')
                    local titles_similar=false
                    local first_lower=$(echo "$first_title" | tr '[:upper:]' '[:lower:]')
                    local second_lower=$(echo "$second_title" | tr '[:upper:]' '[:lower:]')
                    if [[ "$first_lower" == "$second_lower" ]]; then
                        titles_similar=true
                    fi
                    
                    echo ""
                    echo -e "${YELLOW}Would you like to correct the IDs for these items? (y/n):${NC}"
                    stty echo 2>/dev/null
                    read -r correct_choice </dev/tty
                    stty -echo 2>/dev/null
                    if [[ "$correct_choice" == "y" ]]; then
                        echo -e "${YELLOW}Which items to correct? (1=first only, 2=second only, b=both):${NC}"
                        stty echo 2>/dev/null
                        read -r item_choice </dev/tty
                        stty -echo 2>/dev/null
                        
                        local items_to_correct=()
                        if [[ "$item_choice" == "1" ]]; then
                            items_to_correct=("$first_item")
                        elif [[ "$item_choice" == "2" ]]; then
                            items_to_correct=("$second_item")
                        elif [[ "$item_choice" == "b" ]]; then
                            items_to_correct=("$first_item" "$second_item")
                        else
                            print_warning "Invalid choice, skipping correction"
                            continue
                        fi
                        
                        # Process each selected item
                        for item_to_correct in "${items_to_correct[@]}"; do
                            echo ""
                            echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                            echo -e "${GREEN}Correcting: $(basename "$item_to_correct")${NC}"
                            
                            # Find hardlink source by inode
                            if [[ -f "$item_to_correct" ]]; then
                                local inode=$(stat -f "%i" "$item_to_correct" 2>/dev/null || stat -c "%i" "$item_to_correct" 2>/dev/null)
                                local link_count=$(stat -f "%l" "$item_to_correct" 2>/dev/null || stat -c "%h" "$item_to_correct" 2>/dev/null)
                                
                                if [[ "$link_count" -gt 1 && -n "$inode" ]]; then
                                    # This is a hardlink - find the source
                                    local source_file=$(find "$SOURCE" -type f -inum "$inode" 2>/dev/null | head -1)
                                    if [[ -n "$source_file" ]]; then
                                        echo -e "${DIM}Source:      $source_file${NC}"
                                    fi
                                fi
                            fi
                            
                            echo -e "${DIM}Destination: $item_to_correct${NC}"
                            echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                            
                            # Extract title and year from folder name
                            local folder_name=$(basename "$item_to_correct")
                            local title_year=$(echo "$folder_name" | sed -E 's/[[:space:]]*\[imdb.*$//')
                            local movie_title=$(echo "$title_year" | sed -E 's/[[:space:]]*\([0-9]{4}\)[[:space:]]*$//')
                            local movie_year=$(echo "$title_year" | grep -oE '\([0-9]{4}\)' | tr -d '()')
                            
                            local new_id=""
                            
                            # Offer IMDb autocomplete if titles are similar
                            if [[ "$titles_similar" == "true" ]]; then
                                echo -e "${YELLOW}Titles are similar. Use IMDb autocomplete to search? (y/n):${NC}"
                                stty echo 2>/dev/null
                                read -r use_autocomplete </dev/tty
                                stty -echo 2>/dev/null
                                if [[ "$use_autocomplete" == "y" ]]; then
                                    new_id=$(imdb_autocomplete_search "$movie_title" "$movie_year")
                                fi
                            fi
                            
                            # If autocomplete wasn't used or failed, ask for manual entry
                            if [[ -z "$new_id" ]]; then
                                echo -e "${YELLOW}Enter correct IMDb ID (tt followed by digits) or TMDb ID (just digits), or 's' to skip:${NC}"
                                stty echo 2>/dev/null
                                read -r new_id </dev/tty
                                stty -echo 2>/dev/null
                                
                                if [[ "$new_id" == "s" || -z "$new_id" ]]; then
                                    print_warning "Skipping correction for this item"
                                    continue
                                fi
                            fi
                            
                            # Determine if it's IMDb or TMDb
                            local new_imdb=""
                            local new_tmdb=""
                            if [[ "$new_id" =~ ^tt[0-9]+$ ]]; then
                                new_imdb="$new_id"
                                print_info "Updating to IMDb ID: $new_imdb"
                                # Get TMDb from IMDb using /find endpoint
                                if [[ -n "$TMDB_API_KEY" ]]; then
                                    local find_url="${TMDB_API_BASE}/find/${new_imdb}?api_key=${TMDB_API_KEY}&external_source=imdb_id"
                                    local result=$(curl -s "$find_url" 2>/dev/null)
                                    new_tmdb=$(echo "$result" | grep -oE '"id":[0-9]+' | head -1 | grep -oE '[0-9]+')
                                fi
                            elif [[ "$new_id" =~ ^[0-9]+$ ]]; then
                                new_tmdb="$new_id"
                                print_info "Updating to TMDb ID: $new_tmdb"
                                # Get IMDb from TMDb
                                new_imdb=$(get_imdb_from_tmdb "$new_tmdb")
                            else
                                print_error "Invalid ID format (use tt123456 for IMDb or 123456 for TMDb)"
                                continue
                            fi
                            
                            # Update cache entry if it exists
                            if [[ -n "$CACHE_FILE" && -f "$CACHE_FILE" && -n "$movie_title" && -n "$movie_year" ]]; then
                                # Remove old cache entry (case-insensitive match)
                                local temp_cache=$(mktemp)
                                awk -F'|' -v title="$movie_title" -v year="$movie_year" \
                                    'BEGIN{IGNORECASE=1} tolower($1) != tolower(title) || $2 != year {print}' "$CACHE_FILE" > "$temp_cache"
                                mv "$temp_cache" "$CACHE_FILE"
                                
                                # Add new cache entry with correct IDs
                                echo "${movie_title}|${movie_year}|${new_imdb}|${new_tmdb}|$(date +%s)" >> "$CACHE_FILE"
                                print_success "✓ Updated cache entry for: $movie_title ($movie_year)"
                            fi
                            
                            # Rename the folder/file with new ID
                            local old_name=$(basename "$item_to_correct")
                            local parent_dir=$(dirname "$item_to_correct")
                            local new_name="$old_name"
                            
                            # Replace old IMDb ID pattern
                            if [[ -n "$new_imdb" ]]; then
                                new_name=$(echo "$new_name" | sed -E "s/\[imdbid-[^\]]*\]/[imdbid-$new_imdb]/")
                                new_name=$(echo "$new_name" | sed -E "s/\[imdb-[^\]]*\]/[imdb-$new_imdb]/")
                            fi
                            
                            # Update TMDb ID
                            new_name=$(echo "$new_name" | sed -E "s/\[tmdbid-[^\]]*\]/[tmdbid-$new_tmdb]/")
                            new_name=$(echo "$new_name" | sed -E "s/\[tmdb-[^\]]*\]/[tmdb-$new_tmdb]/")
                            
                            if [[ "$new_name" != "$old_name" ]]; then
                                mv "$item_to_correct" "$parent_dir/$new_name"
                                print_success "✓ Renamed: $old_name → $new_name"
                            fi
                        done
                    fi
                done
            fi
        fi
        
        if [[ $duplicate_imdb_count -eq 0 && $duplicate_tmdb_count -eq 0 ]]; then
            print_success "No duplicate IDs found"
        fi
        
        # Cleanup temp files
        rm -f "$tmp_imdb_file" "$tmp_tmdb_file"
    fi
    
    # Show troubleshooting info, failed parse, and failed hardlinks
    show_troubleshooting_info "$total_failed"
    
    # Restore terminal echo
    stty echo 2>/dev/null
    
    # Temp files cleaned up automatically by trap
}

# Post-processing function for missing IDs
handle_missing_ids_post_processing() {
    # Ensure CACHE_FILE is set based on cache mode
    local cache_mode_file="$CACHE_DIR/cache_mode.txt"
    local cache_mode="4k"
    [[ -f "$cache_mode_file" ]] && cache_mode=$(cat "$cache_mode_file")
    
    case "$cache_mode" in
        unified)
            CACHE_FILE="$CACHE_DIR/MOVIE UNIFIED CACHE.txt"
            ;;
        4k)
            CACHE_FILE="$CACHE_DIR/MOVIE 4K CACHE.txt"
            ;;
        1080p)
            CACHE_FILE="$CACHE_DIR/MOVIE 1080p CACHE.txt"
            ;;
        1080p_softcore)
            CACHE_FILE="$CACHE_DIR/MOVIE 1080p SOFTCORE CACHE.txt"
            ;;
        4k_softcore)
            CACHE_FILE="$CACHE_DIR/MOVIE 4K SOFTCORE CACHE.txt"
            ;;
    esac
    
    echo ""
    echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${YELLOW}⚠  POST-PROCESSING: ${#FAILED_LOOKUPS[@]} file(s) with missing IDs${NC}"
    echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
    echo -e "${CYAN}These files were successfully processed (hardlinked/renamed) but with placeholder IDs:${NC}"
    echo -e "${DIM}The IMDb and/or TMDb API lookups either failed or returned no information, so folders contain [imdbid-] or [tmdbid-] placeholders.${NC}"
    echo ""
    echo -e "${CYAN}Files with missing IDs:${NC}"
        for i in "${!FAILED_LOOKUPS[@]}"; do
            local entry="${FAILED_LOOKUPS[$i]}"
            IFS='|||' read -r file title year missing_imdb missing_tmdb <<< "$entry"
            
            local missing_msg=""
            if [[ "$missing_imdb" == "yes" && "$missing_tmdb" == "yes" ]]; then
                missing_msg="${RED}Missing: IMDb & TMDb${NC}"
            elif [[ "$missing_imdb" == "yes" ]]; then
                missing_msg="${YELLOW}Missing: IMDb${NC}"
            elif [[ "$missing_tmdb" == "yes" ]]; then
                missing_msg="${YELLOW}Missing: TMDb${NC}"
            fi
            
            echo -e "  ${YELLOW}$((i+1)).${NC} $title ($year) - $missing_msg"
            echo -e "      ${DIM}File: $(basename "$file")${NC}"
        done
        echo ""
        echo -e "${CYAN}How would you like to update these entries?${NC}"
        echo -e "  ${GREEN}1)${NC} Use IMDb autocomplete search (interactive)"
        echo -e "  ${GREEN}2)${NC} Manually provide IMDb/TMDb links"
        echo -e "  ${GREEN}3)${NC} Skip"
        echo ""
        echo -e "${YELLOW}Enter choice (1-3):${NC}"
        read -r update_choice
        
        if [[ "$update_choice" == "3" ]] || [[ ! "$update_choice" =~ ^[12]$ ]]; then
            print_info "Skipped post-processing"
        else
            # Track files to rename using parallel arrays (Bash 3.2 compatible)
            local -a RENAME_PATHS=()
            local -a RENAME_IDS=()
            
            for i in "${!FAILED_LOOKUPS[@]}"; do
                local entry="${FAILED_LOOKUPS[$i]}"
                IFS='|||' read -r file title year missing_imdb missing_tmdb <<< "$entry"
                
                # If title/year are empty, extract from filename
                if [[ -z "$title" || -z "$year" ]]; then
                    # Check cache first, then parse if needed
                    local cached_data=$(lookup_parse_cache "$file")
                    if [[ -n "$cached_data" ]]; then
                        PARSED_TITLE="${cached_data%%|*}"
                        PARSED_YEAR="${cached_data#*|}"
                    else
                        parse_filename "$file"
                    fi
                    
                    # Extract CLEAN title for cache (remove quality tags, IDs, etc.)
                    local item_name=$(basename "$file")
                    if [[ "$item_name" =~ ^([^[{]+)\ \(([0-9]{4})\) ]]; then
                        title="${BASH_REMATCH[1]}"
                        title="${title% }"  # trim trailing space
                        year="${BASH_REMATCH[2]}"
                    else
                        title="$PARSED_TITLE"
                        year="$PARSED_YEAR"
                    fi
                fi
                
                echo ""
                echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                echo -e "${GREEN}$((i+1))/${#FAILED_LOOKUPS[@]}: $title ($year)${NC}"
                
                if [[ "$missing_imdb" == "yes" && "$missing_tmdb" == "yes" ]]; then
                    echo -e "${RED}Missing: Both IMDb and TMDb IDs${NC}"
                elif [[ "$missing_imdb" == "yes" ]]; then
                    echo -e "${YELLOW}Missing: IMDb ID${NC}"
                elif [[ "$missing_tmdb" == "yes" ]]; then
                    echo -e "${YELLOW}Missing: TMDb ID${NC}"
                fi
                
                echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                echo ""
                
                local new_imdb=""
                local new_tmdb=""
                
                if [[ "$update_choice" == "1" ]]; then
                    # Use IMDb autocomplete search
                    echo -e "${YELLOW}Searching IMDb for: $title ($year)${NC}"
                    local selected_imdb=$(imdb_autocomplete_search "$title" "$year" || true)
                    
                    if [[ -z "$selected_imdb" ]]; then
                        print_warning "No selection made from autocomplete"
                        echo ""
                        echo -e "${CYAN}Would you like to manually enter the IMDb/TMDb link instead? (y/n)${NC}"
                        read -r manual_fallback </dev/tty
                        
                        if [[ ! "$manual_fallback" =~ ^[Yy]$ ]]; then
                            print_info "Skipped"
                            continue
                        fi
                        
                        # Fall through to manual entry
                        update_choice="2"
                    else
                        new_imdb="$selected_imdb"
                        print_success "Selected IMDb ID: $new_imdb"
                        
                        # Get TMDb ID from IMDb
                        if [[ "$missing_tmdb" == "yes" ]]; then
                            new_tmdb=$(search_tmdb "$title" "$year" "$new_imdb")
                            if [[ -n "$new_tmdb" ]]; then
                                print_success "Found TMDb ID from IMDb: $new_tmdb"
                            else
                                print_warning "Could not find TMDb ID from IMDb"
                            fi
                        fi
                    fi
                fi
                
                if [[ "$update_choice" == "2" ]]; then
                    # Manual link entry (option 2)
                    if [[ "$missing_imdb" == "yes" && "$missing_tmdb" == "yes" ]]; then
                        echo -e "${YELLOW}Paste IMDb link (https://www.imdb.com/title/tt1234567/) OR TMDb link (https://www.themoviedb.org/movie/12345):${NC}"
                        echo -e "${DIM}• Paste one or both links (any order), one per line${NC}"
                        echo -e "${DIM}• Press ENTER after each link${NC}"
                        flash_instruction "• Press ENTER twice when finished to continue" "$GREEN"
                        echo -e "${DIM}• Script will auto-fetch the missing ID if you provide only one${NC}"
                    elif [[ "$missing_imdb" == "yes" ]]; then
                        echo -e "${YELLOW}Paste IMDb link (https://www.imdb.com/title/tt1234567/):${NC}"
                        flash_instruction "Press ENTER twice after pasting to continue" "$GREEN"
                        echo -e "${RED}⚠ Only IMDb links accepted - TMDb links will be rejected${NC}"
                    elif [[ "$missing_tmdb" == "yes" ]]; then
                        echo -e "${YELLOW}Paste TMDb link (https://www.themoviedb.org/movie/12345/):${NC}"
                        flash_instruction "Press ENTER twice after pasting to continue" "$GREEN"
                        echo -e "${RED}⚠ Only TMDb links accepted - IMDb links will be rejected${NC}"
                    fi
                    echo -e "${DIM}Or press Enter to skip${NC}"
                    
                    # Collect all input lines (for multiple links)
                    local link_input=""
                    local first_line=1
                    while IFS= read -r line; do
                        [[ -z "$line" ]] && break
                        [[ $first_line -eq 1 ]] && first_line=0 || link_input+=$'\n'
                        link_input+="$line"
                    done
                    
                    if [[ -z "$link_input" ]]; then
                        print_info "Skipped"
                        continue
                    fi
                    
                    # Check for IMDb link
                    if [[ "$link_input" =~ imdb\.com/title/(tt[0-9]+) ]]; then
                        new_imdb="${BASH_REMATCH[1]}"
                        print_success "Extracted IMDb ID: $new_imdb"
                        
                        # Try to get TMDb ID from IMDb if TMDb is missing
                        if [[ "$missing_tmdb" == "yes" ]]; then
                            new_tmdb=$(search_tmdb "$title" "$year" "$new_imdb")
                            [[ -n "$new_tmdb" ]] && print_success "Found TMDb ID from IMDb: $new_tmdb"
                        fi
                    fi
                    
                    # Check for TMDb link
                    if [[ "$link_input" =~ themoviedb\.org/movie/([0-9]+) ]]; then
                        new_tmdb="${BASH_REMATCH[1]}"
                        print_success "Extracted TMDb ID: $new_tmdb"
                        
                        # Try to get IMDb ID from TMDb if IMDb is missing and we don't have it yet
                        if [[ "$missing_imdb" == "yes" && -z "$new_imdb" ]]; then
                            new_imdb=$(get_imdb_from_tmdb "$new_tmdb")
                            [[ -n "$new_imdb" ]] && print_success "Found IMDb ID from TMDb: $new_imdb"
                        fi
                    fi
                fi
                
                # Validate that we got the required ID type
                local validation_failed=0
                if [[ "$missing_imdb" == "yes" && "$missing_tmdb" == "yes" ]]; then
                    # Both missing - accept either but warn if only one provided
                    if [[ -z "$new_imdb" && -z "$new_tmdb" ]]; then
                        print_error "Please provide at least one valid IMDb or TMDb link"
                        validation_failed=1
                    fi
                elif [[ "$missing_imdb" == "yes" && -z "$new_imdb" ]]; then
                    # Only IMDb missing but wasn't provided
                    print_error "This file needs an IMDb ID - please provide an IMDb link (https://www.imdb.com/title/tt...)"
                    validation_failed=1
                elif [[ "$missing_tmdb" == "yes" && -z "$new_tmdb" ]]; then
                    # Only TMDb missing but wasn't provided
                    print_error "This file needs a TMDb ID - please provide a TMDb link (https://www.themoviedb.org/movie/...)"
                    validation_failed=1
                fi
                
                # Skip if validation failed
                if [[ $validation_failed -eq 1 ]]; then
                    print_warning "Skipping this entry - please try again"
                    continue
                fi
                
                # Update cache and fetch poster if we got IDs
                if [[ -n "$new_imdb" || -n "$new_tmdb" ]]; then
                    # Fetch and display poster
                    if [[ -n "$new_imdb" ]]; then
                        echo ""
                        local poster_url=$(get_imdb_poster "$new_imdb" || true)
                        if [[ -n "$poster_url" ]]; then
                            print_info "Fetching poster..."
                            show_poster "$new_imdb" "$poster_url" 30 || true
                            echo ""
                        fi
                    fi
                    
                    # Get existing IDs from cache if available
                    local existing_imdb=""
                    local existing_tmdb=""
                    local cached_line=$(awk -F'|' -v t="$title" -v y="$year" '$1 == t && $2 == y {print; exit}' "$CACHE_FILE" 2>/dev/null)
                    if [[ -n "$cached_line" ]]; then
                        IFS='|' read -r _ _ existing_imdb existing_tmdb _ <<< "$cached_line"
                    fi
                    
                    # Merge new IDs with existing ones
                    local final_imdb="${new_imdb:-$existing_imdb}"
                    local final_tmdb="${new_tmdb:-$existing_tmdb}"
                    
                    # Check if entry exists in cache
                    if awk -F'|' -v t="$title" -v y="$year" '$1 == t && $2 == y {found=1; exit} END {exit !found}' "$CACHE_FILE" 2>/dev/null; then
                        # Update existing entry
                        local temp_file="${CACHE_FILE}.tmp"
                        while IFS='|' read -r cached_title cached_year cached_imdb cached_tmdb cached_ts; do
                            if [[ "$cached_title" == "$title" && "$cached_year" == "$year" ]]; then
                                echo "${cached_title}|${cached_year}|${final_imdb}|${final_tmdb}|${cached_ts}"
                                print_success "Updated cache: $title ($year) - IMDb: $final_imdb, TMDb: $final_tmdb"
                            else
                                echo "${cached_title}|${cached_year}|${cached_imdb}|${cached_tmdb}|${cached_ts}"
                            fi
                        done < "$CACHE_FILE" > "$temp_file"
                        mv "$temp_file" "$CACHE_FILE"
                    else
                        # Add new entry (only if both IDs exist)
                        if [[ -n "$final_imdb" && -n "$final_tmdb" ]]; then
                            save_to_cache "$title" "$year" "$final_imdb" "$final_tmdb"
                            print_success "Added to cache: $title ($year) - IMDb: $final_imdb, TMDb: $final_tmdb"
                        else
                            print_warning "Cannot add to cache - missing IMDb='$final_imdb' or TMDb='$final_tmdb'"
                        fi
                    fi
                    
                    # Track for renaming if we got new IDs
                    if [[ -n "$new_tmdb" || -n "$new_imdb" ]]; then
                        RENAME_PATHS+=("$file")
                        RENAME_IDS+=("$final_tmdb|||$final_imdb")
                    fi
                else
                    print_warning "Could not extract IMDb or TMDb ID from link"
                fi
            done
            
            # Rename files/folders if we have updates
            if [[ ${#RENAME_PATHS[@]} -gt 0 ]]; then
                echo ""
                echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                echo -e "${CYAN}Renaming files with updated IDs...${NC}"
                echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                echo ""
                
                for i in "${!RENAME_PATHS[@]}"; do
                    local old_path="${RENAME_PATHS[$i]}"
                    local ids="${RENAME_IDS[$i]}"
                    IFS='|||' read -r final_tmdb final_imdb <<< "$ids"
                    
                    # Parse the filename
                    parse_filename "$old_path"
                    local old_name=$(basename "$old_path")
                    local dir_path=$(dirname "$old_path")
                    
                    # Build new filename with updated IDs
                    local new_name="$old_name"
                    
                    # Replace empty TMDb IDs (all naming schemes)
                    if [[ -n "$final_tmdb" ]]; then
                        # Jellyfin & Emby files: [tmdbid-]
                        if [[ "$new_name" =~ \[tmdbid-\] ]]; then
                            new_name="${new_name//\[tmdbid-\]/[tmdbid-$final_tmdb]}"
                        fi
                        # Emby folders: [tmdb-]
                        if [[ "$new_name" =~ \[tmdb-\] ]]; then
                            new_name="${new_name//\[tmdb-\]/[tmdb-$final_tmdb]}"
                        fi
                        # Plex: {tmdb-}
                        if [[ "$new_name" =~ \{tmdb-\} ]]; then
                            new_name="${new_name//\{tmdb-\}/\{tmdb-$final_tmdb\}}"
                        fi
                    fi
                    
                    # Replace empty IMDb IDs (all naming schemes)
                    if [[ -n "$final_imdb" ]]; then
                        # Jellyfin & Emby files: [imdbid-]
                        if [[ "$new_name" =~ \[imdbid-\] ]]; then
                            new_name="${new_name//\[imdbid-\]/[imdbid-$final_imdb]}"
                        fi
                        # Emby folders: [imdb-]
                        if [[ "$new_name" =~ \[imdb-\] ]]; then
                            new_name="${new_name//\[imdb-\]/[imdb-$final_imdb]}"
                        fi
                        # Plex: {imdb-}
                        if [[ "$new_name" =~ \{imdb-\} ]]; then
                            new_name="${new_name//\{imdb-\}/\{imdb-$final_imdb\}}"
                        fi
                    fi
                    
                    # Only rename if the name changed
                    if [[ "$old_name" != "$new_name" ]]; then
                        local new_path="${dir_path}/${new_name}"
                        
                        if [[ -e "$new_path" ]]; then
                            # New file already exists - check if it's the same file (hardlink)
                            local old_inode=$(stat -f "%i" "$old_path" 2>/dev/null || stat -c "%i" "$old_path" 2>/dev/null)
                            local new_inode=$(stat -f "%i" "$new_path" 2>/dev/null || stat -c "%i" "$new_path" 2>/dev/null)
                            
                            if [[ "$old_inode" == "$new_inode" ]]; then
                                # Same file - just remove the old hardlink
                                rm "$old_path"
                                print_success "Removed old filename: $old_name"
                                print_info "     (kept: $new_name)"
                            else
                                print_warning "Skipped (different file exists): $new_name"
                            fi
                        else
                            if mv "$old_path" "$new_path" 2>/dev/null; then
                                print_success "Renamed: $old_name"
                                print_info "     → $new_name"
                            else
                                print_warning "Failed to rename: $old_name"
                            fi
                        fi
                    fi
                done
                
                echo ""
                print_success "File renaming complete!"
            else
                echo ""
                print_success "Cache update complete!"
            fi
        fi
}

# Show cache info if any files failed
show_troubleshooting_info() {
    if [[ $1 -gt 0 ]]; then
        echo ""
        echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${YELLOW}⚠  TROUBLESHOOTING: Some movies failed to process${NC}"
        echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
        echo -e "${CYAN}To manually add missing movies to cache:${NC}" or $HOME/user/.movie_simulator/cache_option_you_chose_in_menut.txt
        echo ""
        echo -e "  ${GREEN}1) Open cache file:${NC}"
        echo -e "     ${DIM}nano ${CACHE_FILE}${NC}"
        echo ""
        echo -e "  ${GREEN}2) Add a line with this format:${NC}"
        echo -e "     ${DIM}Movie Title|Year|tt1234567|12345|1234567890${NC}"
        echo ""
        echo -e "  ${GREEN}3) Find IMDb ID:${NC}"
        echo -e "     ${DIM}https://www.imdb.com/${NC} → copy 'tt' number from URL"
        echo ""
        echo -e "  ${GREEN}4) Find TMDb ID:${NC}"
        echo -e "     ${DIM}https://www.themoviedb.org/${NC} → copy number from URL"
        echo ""
        echo -e "  ${GREEN}5) Generate timestamp:${NC}"
        echo -e "     ${DIM}date +%s${NC}  (or use any number)"
        echo ""
        echo -e "${YELLOW}Example cache entry:${NC}"
        echo -e "  ${DIM}The Matrix|1999|tt0133093|603|1699564800${NC}"
        echo ""
        echo -e "${CYAN}Cache locations:${NC}"
        echo -e "  ${DIM}• Movie cache: ${CACHE_FILE}${NC}"
        echo -e "  ${DIM}• Poster cache: ${POSTER_CACHE_DIR}${NC}"
        echo -e "  ${DIM}• Documentation: See script lines 33-85${NC}"
        echo ""
        echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    fi

    # Handle failed hardlinks (cross-volume/filesystem issues)
    if [[ ${#FAILED_HARDLINKS[@]} -gt 0 ]]; then
        echo ""
        echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${YELLOW}⚠  HARDLINK FAILURES DETECTED${NC}"
        echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
        echo -e "${CYAN}Some files could not be hardlinked (usually due to different volumes/filesystems).${NC}"
        echo -e "${CYAN}For each file, you can choose to create a symbolic link, copy the file, or skip it.${NC}"
        echo ""
        
        local failed_count=0
        local symlinked_count=0
        local copied_count=0
        local skipped_count=0
        
        for failed_entry in "${FAILED_HARDLINKS[@]}"; do
            IFS=$'\t' read -r source_file dest_file title year <<< "$failed_entry"
            failed_count=$((failed_count + 1))
            
            echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
            echo -e "${CYAN}Movie:${NC} ${title} (${year})"
            echo -e "${CYAN}Source:${NC} ${DIM}${source_file}${NC}"
            echo -e "${CYAN}Destination:${NC} ${DIM}${dest_file}${NC}"
            echo ""
            echo -e "${GREEN}Options:${NC}"
            echo -e "  ${GREEN}1)${NC} Create symbolic link (soft link to original file)"
            echo -e "  ${GREEN}2)${NC} Copy file (duplicate the file - uses disk space)"
            echo -e "  ${GREEN}3)${NC} Skip this file (leave destination empty)"
            echo -e "  ${GREEN}4)${NC} Cancel all remaining files"
            echo ""
            
            while true; do
                read -p "Choose an option (1-4): " choice
                case "$choice" in
                    1)
                        # Create symbolic link
                        movie_folder=$(dirname "$dest_file")
                        mkdir -p "$movie_folder"
                        if ln -s "$source_file" "$dest_file" 2>/dev/null; then
                            echo -e "${GREEN}✓ Symbolic link created${NC}"
                            symlinked_count=$((symlinked_count + 1))
                        else
                            echo -e "${RED}✗ Failed to create symbolic link${NC}"
                            skipped_count=$((skipped_count + 1))
                        fi
                        break
                        ;;
                    2)
                        # Copy file
                        movie_folder=$(dirname "$dest_file")
                        mkdir -p "$movie_folder"
                        if cp "$source_file" "$dest_file" 2>/dev/null; then
                            echo -e "${GREEN}✓ File copied${NC}"
                            copied_count=$((copied_count + 1))
                        else
                            echo -e "${RED}✗ Failed to copy file${NC}"
                            skipped_count=$((skipped_count + 1))
                        fi
                        break
                        ;;
                    3)
                        # Skip
                        echo -e "${YELLOW}⊘ Skipped${NC}"
                        skipped_count=$((skipped_count + 1))
                        break
                        ;;
                    4)
                        # Cancel all remaining
                        echo -e "${RED}Cancelling remaining failed hardlinks...${NC}"
                        remaining=$((${#FAILED_HARDLINKS[@]} - failed_count))
                        skipped_count=$((skipped_count + remaining))
                        break 2
                        ;;
                    *)
                        echo -e "${RED}Invalid choice. Please enter 1, 2, 3, or 4.${NC}"
                        ;;
                esac
            done
            echo ""
        done
        
        # Show summary
        echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${CYAN}Failed Hardlinks Summary:${NC}"
        echo -e "  ${GREEN}• Symbolic links created:${NC} ${symlinked_count}"
        echo -e "  ${GREEN}• Files copied:${NC} ${copied_count}"
        echo -e "  ${YELLOW}• Skipped:${NC} ${skipped_count}"
        echo -e "  ${CYAN}• Total failed hardlinks:${NC} ${#FAILED_HARDLINKS[@]}"
        echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
    fi
}

# Show usage
usage() {
    cat << EOF
Usage: $0 [options]
  Run without options for interactive mode

Options:
  --view-cache       View cached movie data
  --clear-cache      Clear the cache
  -h, --help         Show this help
EOF
    exit 0
}

# Main
# Clean up any stale locks from previous interrupted runs
rm -rf /tmp/tv_lookup_locks 2>/dev/null
mkdir -p /tmp/tv_lookup_locks 2>/dev/null

if [[ $# -eq 0 ]]; then
    interactive_mode
else
    case "$1" in
        --view-cache)
            if [[ -f "$CACHE_FILE" ]]; then
                echo ""
                print_info "Cached Movies"
                printf "%-40s %-6s %-12s %-10s\n" "TITLE" "YEAR" "IMDB" "TMDB"
                echo "--------------------------------------------------------------------------------"
                while IFS='|' read -r title year imdb tmdb timestamp; do
                    printf "%-40s %-6s %-12s %-10s\n" "$title" "$year" "$imdb" "$tmdb"
                done < "$CACHE_FILE"
                echo ""
                count=$(wc -l < "$CACHE_FILE")
                print_success "Total: ${count// /}"
            else
                print_warning "No cache found"
            fi
            ;;
        --clear-cache)
            if [[ -f "$CACHE_FILE" ]]; then
                rm "$CACHE_FILE"
                print_success "Cache cleared"
            else
                print_info "Cache already empty"
            fi
            ;;
        -h|--help)
            usage
            ;;
        *)
            print_error "Unknown option: $1"
            usage
            exit 1
            ;;
    esac
fi
